# v1.1.0 Release Automation & Scripts

**Purpose**: Automated tools and scripts to streamline release execution and reduce manual errors
**Audience**: Release Manager, Engineering Team
**Last Updated**: January 8, 2026

---

## Overview

This document provides production-ready scripts for automating repetitive release tasks. Each script includes error handling, logging, and safety checks.

**Philosophy**: Automate the boring stuff, focus humans on decisions.

**Script Categories**:
1. [Pre-Beta Verification](#pre-beta-verification-scripts)
2. [Beta Testing](#beta-testing-scripts)
3. [Data Collection](#data-collection-scripts)
4. [Release Execution](#release-execution-scripts)
5. [Monitoring](#monitoring-scripts)
6. [Emergency Response](#emergency-response-scripts)

---

## Script Installation

All scripts should be placed in `.claude/releases/scripts/` directory:

```bash
# Create scripts directory
mkdir -p .claude/releases/scripts

# Make scripts executable
chmod +x .claude/releases/scripts/*.sh
```

---

## Pre-Beta Verification Scripts

### 1. Pre-Flight Verification Script

**File**: `scripts/preflight-check.sh`
**Purpose**: Automated pre-flight checklist execution
**Usage**: `./scripts/preflight-check.sh`
**When**: January 12, 2026

```bash
#!/bin/bash
set -euo pipefail

# Preflight Verification Script for Caro v1.1.0-beta
# Runs comprehensive verification before beta launch

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Log file
LOG_FILE=".claude/releases/logs/preflight-$(date +%Y%m%d-%H%M%S).log"
mkdir -p .claude/releases/logs

echo "ğŸš€ Caro v1.1.0-beta Pre-Flight Verification" | tee -a "$LOG_FILE"
echo "Started: $(date)" | tee -a "$LOG_FILE"
echo "" | tee -a "$LOG_FILE"

FAILED_CHECKS=0
TOTAL_CHECKS=0

# Function to run a check
check() {
    local name="$1"
    local command="$2"
    local critical="${3:-no}"

    TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
    echo -n "Checking: $name... " | tee -a "$LOG_FILE"

    if eval "$command" >> "$LOG_FILE" 2>&1; then
        echo -e "${GREEN}âœ“ PASS${NC}" | tee -a "$LOG_FILE"
        return 0
    else
        echo -e "${RED}âœ— FAIL${NC}" | tee -a "$LOG_FILE"
        FAILED_CHECKS=$((FAILED_CHECKS + 1))

        if [ "$critical" = "yes" ]; then
            echo -e "${RED}CRITICAL CHECK FAILED - BLOCKING${NC}" | tee -a "$LOG_FILE"
        fi
        return 1
    fi
}

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"
echo "1. BUILD VERIFICATION" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"

check "Clean build succeeds" \
    "cargo clean && cargo build --release" \
    "yes"

check "All tests pass" \
    "cargo test --all-features" \
    "yes"

check "Clippy clean" \
    "cargo clippy -- -D warnings" \
    "yes"

check "No security warnings" \
    "cargo audit" \
    "yes"

check "Binary size acceptable (<15MB)" \
    "[ \$(stat -f%z target/release/caro 2>/dev/null || stat -c%s target/release/caro) -lt 15728640 ]" \
    "no"

echo "" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"
echo "2. PRIVACY AUDIT" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"

check "Privacy test suite passes" \
    "cargo test privacy -- --nocapture" \
    "yes"

check "PII validation tests pass" \
    "cargo test pii_validation -- --nocapture" \
    "yes"

# Manual telemetry export check
echo "" | tee -a "$LOG_FILE"
echo -e "${YELLOW}âš  MANUAL CHECK REQUIRED${NC}" | tee -a "$LOG_FILE"
echo "Please verify telemetry export contains ZERO PII:" | tee -a "$LOG_FILE"
echo "  1. Run: ./target/release/caro telemetry export test-export.json" | tee -a "$LOG_FILE"
echo "  2. Inspect: cat test-export.json | jq ." | tee -a "$LOG_FILE"
echo "  3. Verify: No emails, paths, IPs, or personal data" | tee -a "$LOG_FILE"
read -p "Press Enter after manual verification (or Ctrl+C to abort)..."

echo "" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"
echo "3. TELEMETRY VERIFICATION" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"

check "Telemetry tests pass" \
    "cargo test telemetry -- --nocapture" \
    "yes"

check "Fire-and-forget performance (<5ms)" \
    "cargo bench --bench telemetry_benchmarks | grep -q 'time:.*[0-4]\.[0-9]* ms'" \
    "no"

echo "" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"
echo "4. SAFETY VALIDATION" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"

check "Safety tests pass" \
    "cargo test safety -- --nocapture" \
    "yes"

check "Dangerous commands blocked" \
    "cargo test dangerous_commands -- --nocapture" \
    "yes"

echo "" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"
echo "5. DOCUMENTATION REVIEW" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"

check "README.md exists and not empty" \
    "[ -s README.md ]" \
    "no"

check "TELEMETRY.md exists" \
    "[ -f docs/TELEMETRY.md ]" \
    "yes"

check "CLI help works" \
    "./target/release/caro --help | grep -q 'Usage:'" \
    "yes"

check "Examples available" \
    "./target/release/caro --examples | grep -q 'Examples:'" \
    "no"

echo "" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"
echo "6. PLATFORM TESTING" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"

# Detect platform
if [[ "$OSTYPE" == "darwin"* ]]; then
    PLATFORM="macOS"
    check "macOS binary runs" \
        "./target/release/caro --version | grep -q 'caro'" \
        "yes"
elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    PLATFORM="Linux"
    check "Linux binary runs" \
        "./target/release/caro --version | grep -q 'caro'" \
        "yes"
fi

check "Static matcher smoke test" \
    "./target/release/caro 'list files in current directory' | grep -q 'ls'" \
    "yes"

echo "" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"
echo "PREFLIGHT SUMMARY" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"

PASSED=$((TOTAL_CHECKS - FAILED_CHECKS))
echo "Total Checks: $TOTAL_CHECKS" | tee -a "$LOG_FILE"
echo "Passed: $PASSED" | tee -a "$LOG_FILE"
echo "Failed: $FAILED_CHECKS" | tee -a "$LOG_FILE"
echo "" | tee -a "$LOG_FILE"

if [ $FAILED_CHECKS -eq 0 ]; then
    echo -e "${GREEN}âœ… ALL CHECKS PASSED - GO FOR BETA LAUNCH${NC}" | tee -a "$LOG_FILE"
    echo "" | tee -a "$LOG_FILE"
    echo "Next Steps:" | tee -a "$LOG_FILE"
    echo "1. Send Day 0 setup email to beta testers (6 PM PT)" | tee -a "$LOG_FILE"
    echo "2. Prepare for Day 1 launch tomorrow (Jan 13)" | tee -a "$LOG_FILE"
    echo "" | tee -a "$LOG_FILE"
    exit 0
else
    echo -e "${RED}âŒ $FAILED_CHECKS CHECK(S) FAILED - NO-GO FOR BETA${NC}" | tee -a "$LOG_FILE"
    echo "" | tee -a "$LOG_FILE"
    echo "Review failures in log: $LOG_FILE" | tee -a "$LOG_FILE"
    echo "Fix issues and re-run preflight check" | tee -a "$LOG_FILE"
    echo "" | tee -a "$LOG_FILE"
    exit 1
fi
```

---

### 2. Privacy Audit Script

**File**: `scripts/privacy-audit.sh`
**Purpose**: Manual privacy audit helper
**Usage**: `./scripts/privacy-audit.sh <telemetry-export.json>`
**When**: Jan 12, 15, 17, 19 (every telemetry export)

```bash
#!/bin/bash
set -euo pipefail

# Privacy Audit Script
# Scans telemetry export for potential PII

if [ $# -ne 1 ]; then
    echo "Usage: $0 <telemetry-export.json>"
    exit 1
fi

EXPORT_FILE="$1"

if [ ! -f "$EXPORT_FILE" ]; then
    echo "Error: File $EXPORT_FILE not found"
    exit 1
fi

echo "ğŸ”’ Privacy Audit for: $EXPORT_FILE"
echo "Started: $(date)"
echo ""

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

VIOLATIONS=0

# Check for emails
echo -n "Checking for email addresses... "
if grep -E "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}" "$EXPORT_FILE" > /dev/null 2>&1; then
    echo -e "${RED}FOUND - VIOLATION!${NC}"
    grep -n -E "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}" "$EXPORT_FILE"
    VIOLATIONS=$((VIOLATIONS + 1))
else
    echo -e "${GREEN}âœ“ None found${NC}"
fi

# Check for file paths
echo -n "Checking for file paths (/home, /Users)... "
if grep -E "/(home|Users)/[^/\s]+" "$EXPORT_FILE" > /dev/null 2>&1; then
    echo -e "${RED}FOUND - VIOLATION!${NC}"
    grep -n -E "/(home|Users)/[^/\s]+" "$EXPORT_FILE"
    VIOLATIONS=$((VIOLATIONS + 1))
else
    echo -e "${GREEN}âœ“ None found${NC}"
fi

# Check for IP addresses
echo -n "Checking for IP addresses... "
if grep -E "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" "$EXPORT_FILE" > /dev/null 2>&1; then
    echo -e "${YELLOW}FOUND - Review needed${NC}"
    grep -n -E "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" "$EXPORT_FILE"
    echo "Note: Could be example IPs (127.0.0.1, 0.0.0.0) - manual review required"
else
    echo -e "${GREEN}âœ“ None found${NC}"
fi

# Check for API keys/tokens
echo -n "Checking for API keys/tokens... "
if grep -E "(api[_-]?key|token|secret|password)=\S+" "$EXPORT_FILE" > /dev/null 2>&1; then
    echo -e "${RED}FOUND - VIOLATION!${NC}"
    grep -n -E "(api[_-]?key|token|secret|password)=\S+" "$EXPORT_FILE"
    VIOLATIONS=$((VIOLATIONS + 1))
else
    echo -e "${GREEN}âœ“ None found${NC}"
fi

# Check for environment variables
echo -n "Checking for environment variables... "
if grep -E "\$[A-Z_]{3,}" "$EXPORT_FILE" > /dev/null 2>&1; then
    echo -e "${YELLOW}FOUND - Review needed${NC}"
    grep -n -E "\$[A-Z_]{3,}" "$EXPORT_FILE"
    echo "Note: Environment variable references found - ensure no sensitive values exposed"
else
    echo -e "${GREEN}âœ“ None found${NC}"
fi

# Check for hostnames
echo -n "Checking for hostnames... "
if grep -E "[a-zA-Z0-9-]+\.(local|internal|corp|lan)" "$EXPORT_FILE" > /dev/null 2>&1; then
    echo -e "${YELLOW}FOUND - Review needed${NC}"
    grep -n -E "[a-zA-Z0-9-]+\.(local|internal|corp|lan)" "$EXPORT_FILE"
    echo "Note: Internal hostnames found - may expose network topology"
else
    echo -e "${GREEN}âœ“ None found${NC}"
fi

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "AUDIT SUMMARY"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

if [ $VIOLATIONS -eq 0 ]; then
    echo -e "${GREEN}âœ… ZERO PII VIOLATIONS - EXPORT APPROVED${NC}"
    echo ""
    echo "This export is safe to aggregate and analyze."
    exit 0
else
    echo -e "${RED}âŒ $VIOLATIONS PII VIOLATION(S) FOUND - EXPORT REJECTED${NC}"
    echo ""
    echo "CRITICAL: Do NOT use this export!"
    echo "Actions:"
    echo "1. Investigate how PII got into telemetry"
    echo "2. Fix validation layers immediately"
    echo "3. Delete this export securely"
    echo "4. Re-audit telemetry system before continuing"
    echo ""
    echo "This is a RELEASE BLOCKER!"
    exit 1
fi
```

---

## Beta Testing Scripts

### 3. Daily Metrics Collection

**File**: `scripts/collect-daily-metrics.sh`
**Purpose**: Automated daily data collection during beta
**Usage**: `./scripts/collect-daily-metrics.sh`
**When**: Every day Jan 13-17 at 9 PM PT

```bash
#!/bin/bash
set -euo pipefail

# Daily Metrics Collection Script
# Collects metrics during beta testing period

DATE=$(date +%Y-%m-%d)
METRICS_FILE=".claude/releases/metrics/daily-$DATE.json"
mkdir -p .claude/releases/metrics

echo "ğŸ“Š Collecting daily metrics for $DATE"

# Initialize JSON
cat > "$METRICS_FILE" <<EOF
{
  "date": "$DATE",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "github_issues": {},
  "telemetry": {},
  "checkins": {},
  "beta_testers": {}
}
EOF

# Function to update JSON
update_json() {
    local key="$1"
    local value="$2"
    jq "$key = $value" "$METRICS_FILE" > "${METRICS_FILE}.tmp"
    mv "${METRICS_FILE}.tmp" "$METRICS_FILE"
}

# Collect GitHub issue counts
echo "Collecting GitHub issues..."
if command -v gh &> /dev/null; then
    P0_COUNT=$(gh issue list --label "beta-tester,P0" --json number | jq 'length')
    P1_COUNT=$(gh issue list --label "beta-tester,P1" --json number | jq 'length')
    P2_COUNT=$(gh issue list --label "beta-tester,P2" --json number | jq 'length')
    P3_COUNT=$(gh issue list --label "beta-tester,P3" --json number | jq 'length')
    TOTAL_COUNT=$(gh issue list --label "beta-tester" --json number | jq 'length')

    update_json '.github_issues.p0' "$P0_COUNT"
    update_json '.github_issues.p1' "$P1_COUNT"
    update_json '.github_issues.p2' "$P2_COUNT"
    update_json '.github_issues.p3' "$P3_COUNT"
    update_json '.github_issues.total' "$TOTAL_COUNT"

    echo "  P0: $P0_COUNT, P1: $P1_COUNT, P2: $P2_COUNT, P3: $P3_COUNT (Total: $TOTAL_COUNT)"
else
    echo "  Warning: gh CLI not found, skipping GitHub metrics"
fi

# Count telemetry exports received
echo "Counting telemetry exports..."
EXPORT_DIR=".claude/releases/beta-telemetry-exports"
if [ -d "$EXPORT_DIR" ]; then
    EXPORT_COUNT=$(ls -1 "$EXPORT_DIR"/*.json 2>/dev/null | wc -l | tr -d ' ')
    update_json '.telemetry.exports_received' "$EXPORT_COUNT"
    echo "  Exports received: $EXPORT_COUNT"
else
    echo "  Warning: Export directory not found"
fi

# Check-in responses (manual count - update this)
echo "Check-in responses (manual input required):"
read -p "  How many check-in responses today? " CHECKIN_COUNT
update_json '.checkins.responses' "$CHECKIN_COUNT"

# Beta tester activity (manual tracking)
echo "Beta tester engagement (manual input):"
read -p "  How many testers active today? " ACTIVE_TESTERS
update_json '.beta_testers.active_today' "$ACTIVE_TESTERS"

echo ""
echo "âœ… Metrics saved to: $METRICS_FILE"
echo ""
echo "Summary for $DATE:"
jq . "$METRICS_FILE"

echo ""
echo "To view all daily metrics:"
echo "  jq -s '.' .claude/releases/metrics/daily-*.json"
```

---

### 4. Beta Tester Email Helper

**File**: `scripts/send-beta-email.sh`
**Purpose**: Template-based email sending helper
**Usage**: `./scripts/send-beta-email.sh <template-name>`
**When**: Throughout beta testing

```bash
#!/bin/bash
set -euo pipefail

# Beta Tester Email Helper
# Helps send templated emails to beta testers

TEMPLATE_DIR=".claude/releases/email-templates"
TESTERS_FILE=".claude/releases/beta-testers.txt"

if [ $# -ne 1 ]; then
    echo "Usage: $0 <template-name>"
    echo ""
    echo "Available templates:"
    ls -1 "$TEMPLATE_DIR"/*.txt 2>/dev/null | xargs -n1 basename | sed 's/\.txt$//' || echo "  No templates found"
    exit 1
fi

TEMPLATE="$1"
TEMPLATE_FILE="$TEMPLATE_DIR/$TEMPLATE.txt"

if [ ! -f "$TEMPLATE_FILE" ]; then
    echo "Error: Template $TEMPLATE not found"
    echo "Expected: $TEMPLATE_FILE"
    exit 1
fi

if [ ! -f "$TESTERS_FILE" ]; then
    echo "Error: Beta testers file not found: $TESTERS_FILE"
    echo ""
    echo "Create file with format:"
    echo "  name@example.com,First Name"
    exit 1
fi

echo "ğŸ“§ Beta Tester Email Helper"
echo "Template: $TEMPLATE"
echo ""

# Read template
SUBJECT=$(head -n1 "$TEMPLATE_FILE")
BODY=$(tail -n+2 "$TEMPLATE_FILE")

echo "Subject: $SUBJECT"
echo ""
echo "Preview (first 5 lines):"
echo "$BODY" | head -n5
echo "..."
echo ""

# Read testers
TESTER_COUNT=$(wc -l < "$TESTERS_FILE" | tr -d ' ')
echo "Recipients: $TESTER_COUNT beta testers"
echo ""

read -p "Send emails? (yes/no): " CONFIRM

if [ "$CONFIRM" != "yes" ]; then
    echo "Aborted."
    exit 0
fi

# Send emails (this is a placeholder - actual sending depends on your email setup)
echo ""
echo "Generating mailto links for each tester:"
echo ""

while IFS=',' read -r email name; do
    # Personalize body
    PERSONALIZED_BODY=$(echo "$BODY" | sed "s/\[First Name\]/$name/g")

    # URL encode (basic)
    ENCODED_SUBJECT=$(echo "$SUBJECT" | sed 's/ /%20/g')
    ENCODED_BODY=$(echo "$PERSONALIZED_BODY" | sed 's/ /%20/g' | sed 's/$/%0A/g' | tr -d '\n')

    echo "To: $email ($name)"
    echo "  mailto:$email?subject=$ENCODED_SUBJECT&body=$ENCODED_BODY"
    echo ""
done < "$TESTERS_FILE"

echo "âœ… Email links generated above"
echo ""
echo "Note: This script generates mailto: links."
echo "For bulk sending, integrate with your email service (SendGrid, SES, etc.)"
```

---

## Data Collection Scripts

### 5. Telemetry Aggregation

**File**: `scripts/aggregate-telemetry.sh`
**Purpose**: Combine all telemetry exports into single file
**Usage**: `./scripts/aggregate-telemetry.sh`
**When**: Jan 18 (analysis phase)

```bash
#!/bin/bash
set -euo pipefail

# Telemetry Aggregation Script
# Combines all beta telemetry exports

EXPORT_DIR=".claude/releases/beta-telemetry-exports"
OUTPUT_FILE=".claude/releases/analysis/aggregated-telemetry.json"
mkdir -p .claude/releases/analysis

echo "ğŸ“Š Aggregating telemetry exports"
echo ""

if [ ! -d "$EXPORT_DIR" ]; then
    echo "Error: Export directory not found: $EXPORT_DIR"
    exit 1
fi

EXPORT_COUNT=$(ls -1 "$EXPORT_DIR"/*.json 2>/dev/null | wc -l | tr -d ' ')

if [ "$EXPORT_COUNT" -eq 0 ]; then
    echo "Error: No telemetry exports found in $EXPORT_DIR"
    exit 1
fi

echo "Found $EXPORT_COUNT telemetry exports"
echo ""

# Combine all JSON files
echo "Combining exports..."
jq -s 'add' "$EXPORT_DIR"/*.json > "$OUTPUT_FILE"

echo "âœ… Aggregated telemetry saved to: $OUTPUT_FILE"
echo ""

# Calculate summary statistics
echo "Summary Statistics:"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

TOTAL_EVENTS=$(jq 'length' "$OUTPUT_FILE")
echo "Total events: $TOTAL_EVENTS"

COMMAND_GEN=$(jq '[.[] | select(.event == "CommandGeneration")] | length' "$OUTPUT_FILE")
echo "Command generations: $COMMAND_GEN"

SUCCESS_COUNT=$(jq '[.[] | select(.event == "CommandGeneration" and .success == true)] | length' "$OUTPUT_FILE")
SUCCESS_RATE=$(jq -n "$SUCCESS_COUNT / $COMMAND_GEN * 100")
echo "Success rate: ${SUCCESS_RATE}%"

AVG_LATENCY=$(jq '[.[] | select(.event == "CommandGeneration") | .latency_ms] | add / length' "$OUTPUT_FILE")
echo "Average latency: ${AVG_LATENCY}ms"

STATIC_COUNT=$(jq '[.[] | select(.event == "CommandGeneration" and .backend == "static")] | length' "$OUTPUT_FILE")
EMBEDDED_COUNT=$(jq '[.[] | select(.event == "CommandGeneration" and .backend == "embedded")] | length' "$OUTPUT_FILE")
echo "Backend usage: Static=$STATIC_COUNT, Embedded=$EMBEDDED_COUNT"

echo ""
echo "âœ… Ready for analysis phase"
echo ""
echo "Next steps:"
echo "1. Run privacy audit: ./scripts/privacy-audit.sh $OUTPUT_FILE"
echo "2. Fill out analysis template: .claude/releases/v1.1.0-beta-analysis-template.md"
echo "3. Calculate detailed metrics for go/no-go decision"
```

---

## Release Execution Scripts

### 6. Release Build Script

**File**: `scripts/build-release.sh`
**Purpose**: Build release binaries for all platforms
**Usage**: `./scripts/build-release.sh <version>`
**When**: Jan 23 (if GO decision)

```bash
#!/bin/bash
set -euo pipefail

# Release Build Script
# Builds binaries for all platforms

if [ $# -ne 1 ]; then
    echo "Usage: $0 <version>"
    echo "Example: $0 v1.1.0-beta"
    exit 1
fi

VERSION="$1"
BUILD_DIR="target/release-builds/$VERSION"
mkdir -p "$BUILD_DIR"

echo "ğŸ”¨ Building Caro $VERSION for all platforms"
echo ""

# Clean first
echo "Cleaning previous builds..."
cargo clean

# macOS ARM64 (Apple Silicon)
echo ""
echo "Building for macOS ARM64 (Apple Silicon)..."
cargo build --release --target aarch64-apple-darwin
cp target/aarch64-apple-darwin/release/caro "$BUILD_DIR/caro-$VERSION-macos-aarch64"
echo "âœ… macOS ARM64 build complete"

# macOS x86_64 (Intel)
echo ""
echo "Building for macOS x86_64 (Intel)..."
cargo build --release --target x86_64-apple-darwin
cp target/x86_64-apple-darwin/release/caro "$BUILD_DIR/caro-$VERSION-macos-x86_64"
echo "âœ… macOS x86_64 build complete"

# macOS Universal Binary
echo ""
echo "Creating macOS universal binary..."
lipo -create \
    target/aarch64-apple-darwin/release/caro \
    target/x86_64-apple-darwin/release/caro \
    -output "$BUILD_DIR/caro-$VERSION-macos-universal"
echo "âœ… macOS universal binary complete"

# Linux x86_64
echo ""
echo "Building for Linux x86_64..."
cargo build --release --target x86_64-unknown-linux-gnu
cp target/x86_64-unknown-linux-gnu/release/caro "$BUILD_DIR/caro-$VERSION-linux-x86_64"
echo "âœ… Linux x86_64 build complete"

# Generate checksums
echo ""
echo "Generating SHA256 checksums..."
cd "$BUILD_DIR"
sha256sum caro-* > SHA256SUMS
cd - > /dev/null
echo "âœ… Checksums generated"

# Create archives
echo ""
echo "Creating .tar.gz archives..."
for binary in "$BUILD_DIR"/caro-*; do
    if [ -f "$binary" ] && [[ ! "$binary" =~ \.tar\.gz$ ]]; then
        tar -czf "${binary}.tar.gz" -C "$BUILD_DIR" "$(basename "$binary")"
        echo "  Created: $(basename "$binary").tar.gz"
    fi
done

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "âœ… BUILD COMPLETE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "Artifacts in: $BUILD_DIR"
ls -lh "$BUILD_DIR"
echo ""
echo "Next steps:"
echo "1. Test each binary on target platform"
echo "2. Upload to GitHub release"
echo "3. Publish to crates.io: cargo publish"
```

---

## Monitoring Scripts

### 7. Post-Release Monitoring

**File**: `scripts/collect-weekly-metrics.sh`
**Purpose**: Collect weekly metrics post-release
**Usage**: `./scripts/collect-weekly-metrics.sh`
**When**: Every Friday at 5 PM PT (Jan 25 - Feb 13)

```bash
#!/bin/bash
set -euo pipefail

# Weekly Metrics Collection Script
# Collects metrics during post-release monitoring

WEEK=$(date +%Y-W%U)
METRICS_FILE=".claude/releases/metrics/weekly-$WEEK.json"
mkdir -p .claude/releases/metrics

echo "ğŸ“Š Collecting weekly metrics for $WEEK"
echo ""

# Initialize JSON
cat > "$METRICS_FILE" <<EOF
{
  "week": "$WEEK",
  "start_date": "$(date -v-7d +%Y-%m-%d)",
  "end_date": "$(date +%Y-%m-%d)",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "downloads": {},
  "github": {},
  "issues": {},
  "telemetry": {}
}
EOF

# Update JSON helper
update_json() {
    local key="$1"
    local value="$2"
    jq "$key = $value" "$METRICS_FILE" > "${METRICS_FILE}.tmp"
    mv "${METRICS_FILE}.tmp" "$METRICS_FILE"
}

echo "Collecting crates.io downloads..."
if command -v curl &> /dev/null; then
    DOWNLOADS=$(curl -s "https://crates.io/api/v1/crates/caro" | jq '.crate.downloads')
    update_json '.downloads.total' "$DOWNLOADS"
    echo "  Total downloads: $DOWNLOADS"
else
    echo "  Warning: curl not found"
fi

echo ""
echo "Collecting GitHub metrics..."
if command -v gh &> /dev/null; then
    STARS=$(gh repo view --json stargazerCount -q '.stargazerCount')
    WATCHERS=$(gh repo view --json watcherCount -q '.watcherCount')

    update_json '.github.stars' "$STARS"
    update_json '.github.watchers' "$WATCHERS"

    echo "  Stars: $STARS"
    echo "  Watchers: $WATCHERS"

    # Issue counts
    P0=$(gh issue list --label "P0" --json number | jq 'length')
    P1=$(gh issue list --label "P1" --json number | jq 'length')
    TOTAL=$(gh issue list --json number | jq 'length')

    update_json '.issues.p0' "$P0"
    update_json '.issues.p1' "$P1"
    update_json '.issues.total' "$TOTAL"

    echo "  Issues: P0=$P0, P1=$P1, Total=$TOTAL"
else
    echo "  Warning: gh CLI not found"
fi

echo ""
echo "âœ… Metrics saved to: $METRICS_FILE"
echo ""
echo "Weekly summary:"
jq . "$METRICS_FILE"

echo ""
echo "To compare weeks:"
echo "  jq -s '.' .claude/releases/metrics/weekly-*.json"
```

---

## Emergency Response Scripts

### 8. Emergency Rollback

**File**: `scripts/emergency-rollback.sh`
**Purpose**: Quick rollback for critical issues
**Usage**: `./scripts/emergency-rollback.sh <reason>`
**When**: Only if P0 bug requires immediate rollback

```bash
#!/bin/bash
set -euo pipefail

# Emergency Rollback Script
# Quick rollback for critical production issues

if [ $# -lt 1 ]; then
    echo "Usage: $0 <reason>"
    echo "Example: $0 'Privacy violation found in v1.1.0-beta'"
    exit 1
fi

REASON="$1"
TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
LOG_FILE=".claude/releases/logs/rollback-$TIMESTAMP.log"
mkdir -p .claude/releases/logs

echo "ğŸš¨ EMERGENCY ROLLBACK INITIATED" | tee -a "$LOG_FILE"
echo "Timestamp: $TIMESTAMP" | tee -a "$LOG_FILE"
echo "Reason: $REASON" | tee -a "$LOG_FILE"
echo "" | tee -a "$LOG_FILE"

RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${RED}WARNING: This is an emergency procedure${NC}" | tee -a "$LOG_FILE"
echo "" | tee -a "$LOG_FILE"

read -p "Confirm rollback? (type 'ROLLBACK' to proceed): " CONFIRM

if [ "$CONFIRM" != "ROLLBACK" ]; then
    echo "Rollback aborted." | tee -a "$LOG_FILE"
    exit 0
fi

echo "" | tee -a "$LOG_FILE"
echo "Step 1: Yanking crate from crates.io..." | tee -a "$LOG_FILE"
cargo yank --vers 1.1.0-beta 2>&1 | tee -a "$LOG_FILE"
echo "âœ… Crate yanked" | tee -a "$LOG_FILE"

echo "" | tee -a "$LOG_FILE"
echo "Step 2: Marking GitHub release as draft..." | tee -a "$LOG_FILE"
echo "  Manual action required:" | tee -a "$LOG_FILE"
echo "  1. Go to https://github.com/caro-project/caro/releases" | tee -a "$LOG_FILE"
echo "  2. Edit v1.1.0-beta release" | tee -a "$LOG_FILE"
echo "  3. Check 'This is a pre-release'" | tee -a "$LOG_FILE"
echo "  4. Prepend title with '[ROLLED BACK]'" | tee -a "$LOG_FILE"
read -p "  Press Enter when complete..."

echo "" | tee -a "$LOG_FILE"
echo "Step 3: Posting GitHub Discussions notice..." | tee -a "$LOG_FILE"
echo "  Manual action required:" | tee -a "$LOG_FILE"
echo "  1. Create post: 'URGENT: v1.1.0-beta Rolled Back'" | tee -a "$LOG_FILE"
echo "  2. Include reason: $REASON" | tee -a "$LOG_FILE"
echo "  3. Pin post to top" | tee -a "$LOG_FILE"
read -p "  Press Enter when complete..."

echo "" | tee -a "$LOG_FILE"
echo "Step 4: Notifying users via email..." | tee -a "$LOG_FILE"
./scripts/send-beta-email.sh rollback-notice 2>&1 | tee -a "$LOG_FILE"

echo "" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"
echo "ROLLBACK COMPLETE" | tee -a "$LOG_FILE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | tee -a "$LOG_FILE"
echo "" | tee -a "$LOG_FILE"
echo "Reason: $REASON" | tee -a "$LOG_FILE"
echo "Log: $LOG_FILE" | tee -a "$LOG_FILE"
echo "" | tee -a "$LOG_FILE"
echo "Next steps:" | tee -a "$LOG_FILE"
echo "1. Investigate root cause" | tee -a "$LOG_FILE"
echo "2. Fix critical issue" | tee -a "$LOG_FILE"
echo "3. Re-test thoroughly" | tee -a "$LOG_FILE"
echo "4. New release when ready" | tee -a "$LOG_FILE"
echo "" | tee -a "$LOG_FILE"
```

---

## Script Testing

Before using in production, test all scripts:

```bash
# Create test environment
mkdir -p .claude/releases/scripts-test

# Test preflight check (dry run)
./scripts/preflight-check.sh 2>&1 | tee test-output.log

# Test privacy audit with sample data
echo '{"query": "test", "success": true}' > test-export.json
./scripts/privacy-audit.sh test-export.json

# Test daily metrics (dry run)
./scripts/collect-daily-metrics.sh

# Clean up
rm -rf .claude/releases/scripts-test test-*.json test-*.log
```

---

## Script Maintenance

**Update Schedule**:
- Review after each release phase
- Update based on lessons learned
- Add new scripts as needed
- Remove obsolete scripts

**Version Control**:
- All scripts in git
- Document changes in commits
- Tag script versions with releases

**Security**:
- Never commit credentials
- Use environment variables for secrets
- Audit scripts before execution
- Log all automated actions

---

## Additional Scripts (Planned)

Future automation opportunities:

1. **Benchmark Runner**: Automated performance benchmarking
2. **Coverage Reporter**: Test coverage tracking
3. **Changelog Generator**: Automated from commit messages
4. **Release Notes Builder**: Combines multiple sources
5. **Community Report Generator**: Weekly community metrics
6. **Survey Results Aggregator**: Process Google Forms exports
7. **GA Readiness Calculator**: Automated GO/NO-GO scoring

---

## Version History

**Document Version**: 1.0
**Created**: January 8, 2026
**Last Updated**: January 8, 2026
**Scripts Included**: 8 production-ready scripts

---

## References

- Preflight checklist: `v1.1.0-beta-preflight-checklist.md`
- Privacy audit guide: `v1.1.0-security-audit-guide.md`
- Metrics tracking: `v1.1.0-metrics-kpi-tracking.md`
- Release timeline: `v1.1.0-release-timeline.md`
- Emergency procedures: `v1.1.0-emergency-rollback-playbook.md`
