# Contributor Onboarding & Development Guide - v1.1.0

**Audience**: New Contributors, Open Source Community
**Last Updated**: January 8, 2026

---

## Table of Contents

1. [Welcome](#welcome)
2. [Getting Started](#getting-started)
3. [Codebase Architecture](#codebase-architecture)
4. [Development Workflow](#development-workflow)
5. [Coding Standards](#coding-standards)
6. [Testing Guidelines](#testing-guidelines)
7. [Safety Pattern Contributions](#safety-pattern-contributions)
8. [Documentation Contributions](#documentation-contributions)
9. [First Contribution Ideas](#first-contribution-ideas)
10. [Community & Communication](#community--communication)

---

## Welcome

### Thank You for Contributing! ðŸŽ‰

Welcome to the Caro community! We're excited you're here. Whether you're fixing a typo, adding a safety pattern, or implementing a major feature, every contribution makes Caro better.

### What is Caro?

Caro is a **privacy-first, safety-focused CLI tool** that converts natural language to shell commands. It helps developers work faster without memorizing syntax while maintaining privacy and safety.

**Core Values**:
- **Privacy First**: Zero PII, opt-in telemetry, user control
- **Safety Always**: Block dangerous commands, warn on risky operations
- **Open Source**: Community-driven, transparent development
- **Quality**: Well-tested, maintainable, documented code

---

## Getting Started

### Prerequisites

**Required**:
- **Rust**: 1.75 or later (`rustup install stable`)
- **Git**: For version control
- **GitHub Account**: For submitting PRs

**Platform**:
- macOS (Intel or Apple Silicon)
- Linux (Ubuntu, Fedora, Arch, etc.)
- WSL2 (Windows Subsystem for Linux)

---

### Clone the Repository

```bash
# Clone the repo
git clone https://github.com/[org]/caro.git
cd caro

# Create a branch for your work
git checkout -b feature/my-contribution
```

---

### Build Caro

```bash
# Build the project
cargo build

# Run tests
cargo test

# Run Caro locally
cargo run -- "list files modified today"
```

**First build may take 5-10 minutes** (Rust compiles dependencies).

---

### Verify Your Setup

```bash
# Run all tests
cargo test

# Expected output: All tests should pass
# running 127 tests
# test result: ok. 127 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

# Run clippy (linter)
cargo clippy

# Expected: No warnings

# Check formatting
cargo fmt --check

# Expected: No output (formatting is correct)
```

If all checks pass, you're ready to contribute! ðŸš€

---

## Codebase Architecture

### Project Structure

```
caro/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs                 # Entry point
â”‚   â”œâ”€â”€ cli.rs                  # CLI argument parsing
â”‚   â”œâ”€â”€ agent/                  # Command generation logic
â”‚   â”‚   â”œâ”€â”€ mod.rs              # Agent orchestration
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ backends/               # Inference backends
â”‚   â”‚   â”œâ”€â”€ static_matcher.rs  # Static pattern matching
â”‚   â”‚   â”œâ”€â”€ embedded/           # Local LLM (SmolLM, Qwen)
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ prompts/                # Prompt engineering
â”‚   â”‚   â”œâ”€â”€ smollm_prompt.rs   # SmolLM prompts
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ safety/                 # Safety validation
â”‚   â”‚   â”œâ”€â”€ patterns.rs         # Dangerous command patterns
â”‚   â”‚   â””â”€â”€ validator.rs        # Validation logic
â”‚   â”œâ”€â”€ telemetry/              # Privacy-preserving telemetry
â”‚   â”‚   â”œâ”€â”€ collector.rs        # Event collection
â”‚   â”‚   â”œâ”€â”€ privacy.rs          # PII validation
â”‚   â”‚   â””â”€â”€ storage.rs          # Local SQLite storage
â”‚   â”œâ”€â”€ platform/               # Platform detection (macOS/Linux)
â”‚   â””â”€â”€ config/                 # Configuration management
â”œâ”€â”€ tests/                      # Integration tests
â”œâ”€â”€ docs/                       # Documentation
â”œâ”€â”€ scripts/                    # Utility scripts
â””â”€â”€ Cargo.toml                  # Dependencies and metadata
```

---

### Key Components

#### 1. Agent (`src/agent/`)

**Responsibility**: Orchestrate command generation

**Flow**:
1. User query â†’ Agent
2. Agent tries Static Matcher first (fast)
3. If no match, fallback to LLM backend
4. Validate safety
5. Return command to user

**Key Files**:
- `mod.rs`: Main agent logic
- `context.rs`: Query context (platform, history, etc.)

---

#### 2. Backends (`src/backends/`)

**Responsibility**: Generate commands from natural language

**Static Matcher** (`static_matcher.rs`):
- Fast, deterministic pattern matching
- 100+ pre-defined patterns (e.g., "list files" â†’ `ls`)
- 86.2% accuracy across 58 test cases

**Embedded Backend** (`embedded/`):
- Local LLM inference (SmolLM 135M, Qwen 1.5B)
- Fallback when static matcher doesn't match
- Runs on-device, no network required

---

#### 3. Safety Validation (`src/safety/`)

**Responsibility**: Prevent dangerous commands

**Patterns** (`patterns.rs`):
- 100+ dangerous command patterns
- Examples: `rm -rf /`, fork bombs, recursive deletions
- Regex-based matching

**Validator** (`validator.rs`):
- Check generated commands against patterns
- Return warnings or errors
- User always maintains control

**Example Pattern**:
```rust
DangerousPattern {
    name: "rm_rf_root",
    pattern: r"rm\s+-rf\s+/",
    severity: Severity::Critical,
    message: "DANGER: This will delete your entire filesystem!",
}
```

---

#### 4. Telemetry (`src/telemetry/`)

**Responsibility**: Privacy-preserving usage analytics

**Key Principles**:
- **Zero PII**: Email, paths, IPs, API keys stripped
- **Opt-in**: Disabled by default
- **Local storage**: SQLite, user can inspect
- **Transparent**: User can export and delete

**Privacy Validation** (`privacy.rs`):
- Regex checks for PII patterns
- 220+ automated tests
- Dual manual audits before each release

---

### Data Flow Example

**User Query**: `"list files modified today"`

```
1. CLI (main.rs)
   â””â”€> Parse arguments
       â””â”€> "list files modified today"

2. Agent (agent/mod.rs)
   â””â”€> Detect platform: macOS
       â””â”€> Try Static Matcher first

3. Static Matcher (backends/static_matcher.rs)
   â””â”€> Match pattern: "list files {time_filter}"
       â””â”€> Template: "find . -type f -mtime -1"
       â””â”€> Success!

4. Safety Validator (safety/validator.rs)
   â””â”€> Check command: "find . -type f -mtime -1"
       â””â”€> No dangerous patterns detected
       â””â”€> Safe âœ…

5. Return to User
   â””â”€> Output: "find . -type f -mtime -1"
```

**If Static Matcher Failed**:
```
3. Static Matcher
   â””â”€> No match found
       â””â”€> Fallback to Embedded Backend

3b. Embedded Backend (backends/embedded/)
    â””â”€> Load SmolLM model
        â””â”€> Generate command via LLM
        â””â”€> Validate JSON output
        â””â”€> Return command

4. Safety Validator...
```

---

## Development Workflow

### Step 1: Find Something to Work On

**Options**:

1. **Good First Issues**: Tagged `good-first-issue` on GitHub
   - Simple, well-defined tasks
   - Great for first-time contributors

2. **Help Wanted**: Tagged `help-wanted`
   - More complex, but valuable contributions

3. **Bug Reports**: Tagged `bug`
   - Fix reported issues

4. **Feature Requests**: Tagged `enhancement`
   - Implement requested features

5. **Documentation**: Tagged `documentation`
   - Improve README, guides, code comments

**Browse**: https://github.com/[org]/caro/issues

---

### Step 2: Claim the Issue

**Comment on the issue**:
```
I'd like to work on this! I'll have a PR ready within [timeframe].
```

**Wait for confirmation** from a maintainer before starting work (to avoid duplicate effort).

---

### Step 3: Create a Branch

```bash
# Update main
git checkout main
git pull origin main

# Create feature branch
git checkout -b feature/issue-123-description

# Naming convention:
# - feature/123-short-description (for features)
# - fix/123-short-description (for bug fixes)
# - docs/123-short-description (for documentation)
```

---

### Step 4: Make Your Changes

**Tips**:
- **Small commits**: Commit logical units of work
- **Clear commit messages**: `fix(safety): Block rm -rf with wildcards`
- **Test as you go**: Run `cargo test` frequently
- **Follow style**: Run `cargo fmt` before committing

**Commit Message Format**:
```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types**: `feat`, `fix`, `docs`, `test`, `refactor`, `style`, `chore`

**Example**:
```
feat(safety): Add pattern for dangerous chmod commands

- Block chmod 000 on important directories
- Add tests for new pattern
- Update safety pattern documentation

Fixes #123
```

---

### Step 5: Test Your Changes

```bash
# Run all tests
cargo test

# Run specific test
cargo test test_name

# Run with output
cargo test -- --nocapture

# Run clippy
cargo clippy

# Format code
cargo fmt
```

**All checks must pass** before submitting PR.

---

### Step 6: Push and Create PR

```bash
# Push your branch
git push origin feature/issue-123-description
```

**Create Pull Request** on GitHub:

1. Go to https://github.com/[org]/caro/pulls
2. Click "New Pull Request"
3. Select your branch
4. Fill in PR template:
   - **Title**: Clear, concise (e.g., "Add safety pattern for chmod")
   - **Description**: What, why, how
   - **Testing**: How did you test this?
   - **Closes**: #123 (link to issue)

**PR Template**:
```markdown
## Description
[What does this PR do? Why is it needed?]

## Changes
- [Change 1]
- [Change 2]

## Testing
- [ ] Unit tests added/updated
- [ ] Manual testing performed
- [ ] All tests pass locally

## Checklist
- [ ] Code follows style guide
- [ ] Tests pass (`cargo test`)
- [ ] Clippy passes (`cargo clippy`)
- [ ] Formatted (`cargo fmt`)
- [ ] Documentation updated (if needed)

Closes #[issue number]
```

---

### Step 7: Code Review

**What to Expect**:
- Maintainers will review your PR
- May request changes or ask questions
- This is normal! Code review makes code better

**Responding to Feedback**:
1. Read feedback carefully
2. Ask questions if unclear
3. Make requested changes
4. Push new commits to your branch
5. Respond to comments when done

**Example**:
```
Reviewer: "Can you add a test for the edge case where the file path has spaces?"
You: "Good catch! Added test in commit abc123. Let me know if it looks good."
```

---

### Step 8: PR Merged! ðŸŽ‰

**After Merge**:
1. Your code is now part of Caro!
2. You'll be credited in release notes
3. Your GitHub profile shows your contribution
4. Optional: Join Discord, introduce yourself

**Clean Up**:
```bash
# Delete local branch
git checkout main
git branch -D feature/issue-123-description

# Delete remote branch (if needed)
git push origin --delete feature/issue-123-description
```

---

## Coding Standards

### Rust Style Guide

**Follow Rust conventions**:
- Use `cargo fmt` (automatic formatting)
- Use `cargo clippy` (linter)
- Follow naming conventions:
  - Functions: `snake_case`
  - Types: `PascalCase`
  - Constants: `SCREAMING_SNAKE_CASE`

---

### Code Quality Principles

1. **Clarity Over Cleverness**
   - Write simple, readable code
   - Avoid unnecessary abstractions
   - Comment complex logic

2. **Error Handling**
   - Use `Result<T, E>` for fallible operations
   - Provide clear error messages
   - Don't use `unwrap()` in production code (except for guaranteed cases with comments)

3. **Testing**
   - Write tests for new functionality
   - Test edge cases
   - Test error conditions

4. **Performance**
   - Avoid unnecessary allocations
   - Use references where possible
   - Profile before optimizing (don't pre-optimize)

---

### Example: Good vs Bad Code

**Bad**:
```rust
// Too clever, hard to read
fn x(s: &str) -> Option<String> {
    s.split_whitespace().nth(1).map(|x| x.to_string())
}
```

**Good**:
```rust
/// Extract the second word from a string
fn get_second_word(input: &str) -> Option<String> {
    input
        .split_whitespace()
        .nth(1)
        .map(|word| word.to_string())
}
```

---

## Testing Guidelines

### Test Structure

**Unit Tests**: Test individual functions
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pattern_matches_simple_case() {
        let pattern = DangerousPattern::new("rm -rf /");
        assert!(pattern.matches("rm -rf /"));
    }

    #[test]
    fn test_pattern_does_not_match_safe_command() {
        let pattern = DangerousPattern::new("rm -rf /");
        assert!(!pattern.matches("rm file.txt"));
    }
}
```

**Integration Tests**: Test component interactions
```rust
// tests/integration_test.rs
#[test]
fn test_command_generation_end_to_end() {
    let query = "list files modified today";
    let result = generate_command(query).unwrap();

    assert!(result.command.contains("find"));
    assert!(result.command.contains("-mtime"));
}
```

---

### Running Tests

```bash
# All tests
cargo test

# Specific test
cargo test test_pattern_matches

# With output
cargo test -- --nocapture

# Integration tests only
cargo test --test '*'

# Doc tests
cargo test --doc
```

---

### Test Coverage

**Goal**: >80% code coverage

**Check coverage** (using tarpaulin):
```bash
cargo install cargo-tarpaulin
cargo tarpaulin --out Html
```

---

## Safety Pattern Contributions

### What are Safety Patterns?

Safety patterns **block dangerous commands** that could cause irreversible damage.

**Examples**:
- `rm -rf /` â†’ Deletes entire filesystem
- `:(){ :|:& };:` â†’ Fork bomb (crashes system)
- `chmod -R 000 /` â†’ Makes all files unreadable

---

### How to Add a Safety Pattern

**1. Identify the Dangerous Command**

What command do you want to block? Why is it dangerous?

**Example**: `dd if=/dev/zero of=/dev/sda`
- **Why dangerous**: Overwrites hard drive with zeros (data loss)

---

**2. Write the Pattern**

Add to `src/safety/patterns.rs`:

```rust
DangerousPattern {
    name: "dd_overwrite_disk",
    pattern: r"dd\s+if=/dev/(zero|random|urandom)\s+of=/dev/(sd[a-z]|nvme[0-9]n[0-9])",
    severity: Severity::Critical,
    message: "DANGER: This command will erase your hard drive!",
    suggestion: Some("Use a specific file instead: dd if=/dev/zero of=myfile.img bs=1M count=100"),
}
```

**Fields**:
- `name`: Unique identifier
- `pattern`: Regex pattern (Rust regex syntax)
- `severity`: `Critical`, `High`, `Medium`, `Low`
- `message`: User-facing warning
- `suggestion`: Optional alternative (safe command)

---

**3. Add Tests**

Add to `src/safety/patterns.rs` (in test module):

```rust
#[test]
fn test_blocks_dd_overwrite_disk() {
    let validator = SafetyValidator::new();

    // Should block
    assert!(validator.is_dangerous("dd if=/dev/zero of=/dev/sda"));

    // Should allow (safe)
    assert!(!validator.is_dangerous("dd if=/dev/zero of=myfile.img bs=1M count=100"));
}
```

---

**4. Test Manually**

```bash
cargo test test_blocks_dd_overwrite_disk

# Try it live
cargo run -- "overwrite my hard drive with zeros"

# Expected: Caro should warn or block
```

---

**5. Submit PR**

- Title: `feat(safety): Block dd disk overwrite pattern`
- Description: Explain what and why
- Link to examples or incidents (if available)

---

### Safety Pattern Best Practices

**Do**:
- âœ… Block genuinely dangerous commands
- âœ… Provide clear, actionable warnings
- âœ… Suggest safe alternatives (if possible)
- âœ… Test both positive and negative cases

**Don't**:
- âŒ Block too broadly (false positives)
- âŒ Use vague messages ("This is bad")
- âŒ Add patterns for mildly risky commands (warn instead of block)

---

## Documentation Contributions

### Types of Documentation

1. **Code Comments**: Explain complex logic
2. **Doc Comments**: Public API documentation (`///`)
3. **README**: Project overview, installation, usage
4. **Guides**: INSTALL.md, CONTRIBUTING.md, etc.
5. **Examples**: Code examples in docs

---

### Writing Good Documentation

**Principles**:
- **Clear**: Simple language, no jargon
- **Concise**: Short sentences, bullet points
- **Complete**: Cover all common cases
- **Examples**: Show, don't just tell
- **Updated**: Keep docs in sync with code

---

### Doc Comment Example

**Good**:
```rust
/// Validates a command against safety patterns.
///
/// Returns `Ok(())` if the command is safe, or an error with details
/// if a dangerous pattern is detected.
///
/// # Examples
///
/// ```
/// let validator = SafetyValidator::new();
/// assert!(validator.validate("ls -la").is_ok());
/// assert!(validator.validate("rm -rf /").is_err());
/// ```
///
/// # Errors
///
/// Returns an error if the command matches a dangerous pattern.
pub fn validate(&self, command: &str) -> Result<(), SafetyError> {
    // ...
}
```

---

## First Contribution Ideas

### Easy (Good First Issue)

1. **Add Safety Pattern**: Block a new dangerous command
2. **Fix Typo**: README, comments, error messages
3. **Add Example**: Show a new use case in docs
4. **Add Test**: Improve test coverage
5. **Improve Error Message**: Make errors clearer

---

### Medium

1. **Add Static Matcher Pattern**: Expand static matcher coverage
2. **Improve Platform Detection**: Better OS/version detection
3. **Add Command Category**: New category (e.g., network, database)
4. **Performance Improvement**: Optimize slow code path
5. **Documentation Guide**: Write tutorial or guide

---

### Advanced

1. **New Backend**: Integrate new LLM or API
2. **Feature Implementation**: Implement requested feature
3. **Architectural Improvement**: Refactor for better design
4. **Integration**: VS Code extension, Oh My Zsh plugin
5. **Major Bug Fix**: Complex, multi-file fix

---

## Community & Communication

### Discord

**Join**: https://discord.gg/[invite]

**Channels**:
- `#welcome`: Introduce yourself!
- `#contributors`: Contributor discussions
- `#support`: Get help
- `#showcase`: Share your work

---

### GitHub Discussions

**Use for**:
- Feature ideas (before creating issue)
- Design discussions
- Q&A

**URL**: https://github.com/[org]/caro/discussions

---

### Code of Conduct

**Be Respectful**:
- Kind, inclusive, welcoming
- Constructive feedback
- No harassment, discrimination, or abuse

**Full Code of Conduct**: https://github.com/[org]/caro/blob/main/CODE_OF_CONDUCT.md

---

## Getting Help

**Stuck? Ask for help!**

1. **Discord #contributors**: Real-time help
2. **GitHub Discussions**: Async Q&A
3. **Issue Comments**: Ask on the issue you're working on
4. **Email**: [email address] (for sensitive topics)

**We're here to help!** Don't hesitate to ask questions.

---

## Recognition

### How We Thank Contributors

1. **Credits in Release Notes**: Listed by name
2. **CONTRIBUTORS.md**: Permanent record
3. **Discord Role**: "Contributor" badge
4. **GitHub Profile**: Contribution shows on your profile
5. **Shout-Outs**: Twitter, Discord announcements

**Every contribution matters!** ðŸ™Œ

---

## Summary

### Quick Start Checklist

- [ ] Clone repo: `git clone https://github.com/[org]/caro.git`
- [ ] Build: `cargo build`
- [ ] Test: `cargo test` (all pass)
- [ ] Find issue: Browse `good-first-issue` label
- [ ] Claim issue: Comment "I'll work on this"
- [ ] Create branch: `git checkout -b feature/123-description`
- [ ] Make changes: Code, test, format
- [ ] Submit PR: Clear title, description, link to issue
- [ ] Celebrate! ðŸŽ‰

---

### Resources

- **GitHub**: https://github.com/[org]/caro
- **Discord**: https://discord.gg/[invite]
- **Discussions**: https://github.com/[org]/caro/discussions
- **Issues**: https://github.com/[org]/caro/issues
- **CONTRIBUTING.md**: https://github.com/[org]/caro/blob/main/CONTRIBUTING.md

---

**Welcome to the Caro community! We're excited to build the future of command-line interaction with you.** ðŸš€

---

**Document Version**: 1.0
**Last Updated**: January 8, 2026
**Maintainer**: Core Team
