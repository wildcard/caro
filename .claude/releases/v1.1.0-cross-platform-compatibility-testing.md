# Release Cross-Platform Compatibility & Testing Strategy

**Version**: 1.0
**Last Updated**: 2026-01-08
**Owner**: Engineering Lead + Platform Engineer
**Status**: Active

---

## Document Purpose

This document defines the comprehensive cross-platform compatibility and testing strategy for the v1.1.0-beta release, ensuring caro works reliably across all supported operating systems, architectures, and shell environments. It establishes platform support matrix, compatibility testing procedures, platform-specific considerations, and quality assurance across diverse environments.

**Audience**: Engineering Team, Platform Engineer, QA Team, Release Manager

**Related Documents**:
- `v1.1.0-release-qa-testing-strategy.md` - Overall QA strategy including platform testing
- `v1.1.0-performance-optimization-benchmarking.md` - Platform-specific performance optimization
- `v1.1.0-release-runbook-sop.md` - Platform-specific build and release procedures
- `BUILD.md` - Build instructions for all platforms

---

## Table of Contents

1. [Platform Support Philosophy](#platform-support-philosophy)
2. [Platform Support Matrix](#platform-support-matrix)
3. [Compatibility Challenges](#compatibility-challenges)
4. [Platform-Specific Testing](#platform-specific-testing)
5. [Shell Compatibility](#shell-compatibility)
6. [Architecture-Specific Testing](#architecture-specific-testing)
7. [Cross-Platform Build Strategy](#cross-platform-build-strategy)
8. [Compatibility Assurance](#compatibility-assurance)
9. [Platform-Specific Documentation](#platform-specific-documentation)

---

## Platform Support Philosophy

### Core Principles

**1. First-Class Support for Primary Platforms**
- macOS (Intel + Apple Silicon): Primary target (60% of user base)
- Linux (x86_64): Primary target (40% of user base)
- Both platforms receive equal attention, testing, and optimization

**2. Best-Effort Support for Secondary Platforms**
- Linux ARM (Raspberry Pi, AWS Graviton): Community-driven
- Windows (WSL): Future consideration (not v1.1.0-beta)
- If it works, great. If not, accept contributions but don't block release.

**3. Platform Abstraction, Not Platform-Specific Code**
- Write portable Rust code (leverage std library cross-platform APIs)
- Avoid platform-specific `#[cfg(target_os = "...")]` when possible
- When necessary, abstract behind traits (e.g., `ShellDetector` trait)

**4. Test on Real Hardware, Not Just CI**
- CI covers common cases (Ubuntu, macOS on GitHub Actions)
- Real hardware testing catches edge cases (M1 Mac, Raspberry Pi, specific Linux distros)
- Community testing is valuable (diverse environments)

**5. Graceful Degradation**
- If a feature doesn't work on a platform, degrade gracefully (don't crash)
- Example: MLX backend (Apple Silicon only) ‚Üí Fall back to embedded backend on Intel
- Clear error messages: "MLX backend not available on this platform. Using embedded backend instead."

---

## Platform Support Matrix

### Supported Platforms (v1.1.0-beta)

| Platform | Architecture | Support Level | Testing | Binary Distribution | Notes |
|----------|--------------|---------------|---------|---------------------|-------|
| **macOS 13+** | x86_64 (Intel) | ‚úÖ **Tier 1** | CI + Manual | ‚úÖ Yes | Primary target |
| **macOS 13+** | aarch64 (Apple Silicon) | ‚úÖ **Tier 1** | CI + Manual | ‚úÖ Yes | Primary target, MLX support (v1.2.0) |
| **Linux (Ubuntu 22.04+)** | x86_64 | ‚úÖ **Tier 1** | CI + Manual | ‚úÖ Yes | Primary target |
| **Linux (Debian 12+)** | x86_64 | ‚úÖ **Tier 1** | Manual | ‚úÖ Yes (same as Ubuntu) | Compatibility expected |
| **Linux (Fedora 38+)** | x86_64 | üü° **Tier 2** | Manual | ‚úÖ Yes (same as Ubuntu) | Best-effort |
| **Linux (Arch)** | x86_64 | üü° **Tier 2** | Community | ‚úÖ Yes (same as Ubuntu) | Best-effort |
| **Linux** | aarch64 (ARM) | üü° **Tier 2** | Manual | ‚úÖ Yes | Raspberry Pi, AWS Graviton |
| **Windows (WSL2)** | x86_64 | üîµ **Experimental** | Manual | ‚ùå No (use Linux binary) | Works but not officially supported |
| **FreeBSD** | x86_64 | ‚ùå **Unsupported** | None | ‚ùå No | May work, no guarantees |

**Support Level Definitions**:
- **Tier 1**: Fully supported, tested in CI + manual, binaries provided, bugs are P1
- **Tier 2**: Best-effort support, manual testing, binaries provided, bugs are P2
- **Experimental**: May work, minimal testing, no official binaries, bugs are P3
- **Unsupported**: No testing, no binaries, bugs closed as "won't fix"

---

### Shell Support Matrix

| Shell | macOS | Linux | Support Level | Notes |
|-------|-------|-------|---------------|-------|
| **bash** | ‚úÖ | ‚úÖ | ‚úÖ **Tier 1** | Default on most systems |
| **zsh** | ‚úÖ (default) | ‚úÖ | ‚úÖ **Tier 1** | macOS default since 10.15 |
| **fish** | ‚úÖ | ‚úÖ | üü° **Tier 2** | Different syntax (no pipes with `|`) |
| **sh (POSIX)** | ‚úÖ | ‚úÖ | ‚úÖ **Tier 1** | Lowest common denominator |
| **tcsh** | ‚úÖ | ‚úÖ | üîµ **Experimental** | Rare, different syntax |
| **PowerShell** | ‚ùå | ‚ùå | ‚ùå **Unsupported** | Windows-only, incompatible syntax |

**Key Insight**: Caro generates POSIX-compatible commands by default (works in bash, zsh, sh). Shell-specific features (e.g., zsh arrays) require explicit user request.

---

### Command Compatibility (BSD vs. GNU)

**Major Challenge**: macOS uses BSD commands, Linux uses GNU commands. Flags differ.

| Command | macOS (BSD) | Linux (GNU) | Compatibility Issue |
|---------|-------------|-------------|---------------------|
| `ls` | `ls -lh` | `ls -lh` | ‚úÖ Compatible (basic flags) |
| `ps` | `ps aux` | `ps aux` | ‚úÖ Compatible (common flags) |
| `find` | `find . -mtime -7` | `find . -mtime -7` | ‚úÖ Compatible (POSIX flags) |
| `stat` | `stat -f %z file` | `stat -c %s file` | ‚ùå **Incompatible** (different flags) |
| `date` | `date -r 1609459200` | `date -d @1609459200` | ‚ùå **Incompatible** (different flags) |
| `sed` | `sed -i '' 's/foo/bar/g'` | `sed -i 's/foo/bar/g'` | ‚ùå **Incompatible** (in-place editing) |
| `tar` | `tar -xzf` | `tar -xzf` | ‚úÖ Compatible (common flags) |
| `grep` | `grep -E` | `grep -E` | ‚úÖ Compatible (POSIX ERE) |

**Strategy**: Detect platform at runtime, generate platform-specific commands.

---

## Compatibility Challenges

### Challenge 1: BSD vs. GNU Command Differences

**Problem**: Same command, different flags between macOS and Linux.

**Example**:
```bash
# Get file size
macOS (BSD):   stat -f %z file.txt
Linux (GNU):   stat -c %s file.txt
```

**Solution**: Platform detection + conditional command generation

```rust
// src/platform/mod.rs
pub enum Platform {
    MacOS,
    Linux,
    Unknown,
}

impl Platform {
    pub fn detect() -> Self {
        #[cfg(target_os = "macos")]
        return Platform::MacOS;

        #[cfg(target_os = "linux")]
        return Platform::Linux;

        #[cfg(not(any(target_os = "macos", target_os = "linux")))]
        return Platform::Unknown;
    }

    pub fn stat_format_flag(&self) -> &str {
        match self {
            Platform::MacOS => "-f %z",   // BSD format
            Platform::Linux => "-c %s",   // GNU format
            Platform::Unknown => "-c %s", // Assume GNU
        }
    }
}

// Usage in command generation
let platform = Platform::detect();
let stat_cmd = format!("stat {} file.txt", platform.stat_format_flag());
// macOS: "stat -f %z file.txt"
// Linux: "stat -c %s file.txt"
```

**Testing**: Verify command works on both macOS and Linux (CI + manual)

---

### Challenge 2: Shell-Specific Syntax

**Problem**: Different shells have different syntax (especially fish).

**Example**:
```bash
# Pipe output to another command
bash/zsh:  ls | grep foo
fish:      ls | grep foo  (same, but fish has different variable syntax)

# Variable expansion
bash/zsh:  echo $HOME
fish:      echo $HOME  (same for simple cases)

# Arrays (non-POSIX)
bash:      arr=(a b c); echo ${arr[0]}
zsh:       arr=(a b c); echo $arr[1]  # 1-indexed!
fish:      set arr a b c; echo $arr[1]  # Different syntax
```

**Solution**: Generate POSIX-compatible commands (work in bash, zsh, sh)

```rust
// Avoid shell-specific features
‚ùå BAD:  "echo ${arr[0]}"  // Arrays not POSIX
‚úÖ GOOD: "echo $HOME"      // Simple variables are POSIX

‚ùå BAD:  "source ~/.bashrc"  // Bash-specific
‚úÖ GOOD: ". ~/.profile"      // POSIX dot command
```

**Exception**: If user explicitly requests shell-specific feature, generate it with warning.

---

### Challenge 3: Architecture Differences (x86 vs. ARM)

**Problem**: Some commands or paths differ between architectures.

**Example**:
```bash
# Homebrew installation paths
macOS Intel (x86_64):        /usr/local/bin/brew
macOS Apple Silicon (ARM64): /opt/homebrew/bin/brew

# Library paths
Linux x86_64:                /usr/lib/x86_64-linux-gnu/
Linux ARM64:                 /usr/lib/aarch64-linux-gnu/
```

**Solution**: Detect architecture, adjust paths accordingly

```rust
pub enum Architecture {
    X86_64,
    Aarch64,
    Unknown,
}

impl Architecture {
    pub fn detect() -> Self {
        #[cfg(target_arch = "x86_64")]
        return Architecture::X86_64;

        #[cfg(target_arch = "aarch64")]
        return Architecture::Aarch64;

        #[cfg(not(any(target_arch = "x86_64", target_arch = "aarch64")))]
        return Architecture::Unknown;
    }

    pub fn homebrew_path(&self, platform: &Platform) -> Option<&str> {
        match (platform, self) {
            (Platform::MacOS, Architecture::X86_64) => Some("/usr/local/bin/brew"),
            (Platform::MacOS, Architecture::Aarch64) => Some("/opt/homebrew/bin/brew"),
            _ => None,
        }
    }
}
```

---

### Challenge 4: Filesystem Differences

**Problem**: Filesystem case sensitivity, path separators, special files differ.

| Feature | macOS | Linux | Notes |
|---------|-------|-------|-------|
| **Case Sensitivity** | ‚ùå No (by default) | ‚úÖ Yes | macOS APFS can be case-sensitive (rare) |
| **Path Separator** | `/` | `/` | ‚úÖ Same (Unix-like) |
| **Hidden Files** | `.filename` | `.filename` | ‚úÖ Same |
| **Special Dirs** | `/Volumes/` (mount points) | `/mnt/` or `/media/` | Different conventions |
| **Home Dir** | `/Users/username` | `/home/username` | Different paths |
| **Temp Dir** | `/tmp/` | `/tmp/` | ‚úÖ Same |

**Solution**: Use Rust `std::env` and `std::path` for portable paths

```rust
use std::env;
use std::path::PathBuf;

// ‚úÖ Portable: Get home directory
let home: PathBuf = env::var("HOME").unwrap().into();

// ‚úÖ Portable: Join paths
let config_path = home.join(".config").join("caro").join("config.toml");
// macOS: /Users/alice/.config/caro/config.toml
// Linux: /home/alice/.config/caro/config.toml
```

---

### Challenge 5: System Command Availability

**Problem**: Some commands exist on one platform but not the other.

| Command | macOS | Linux | Notes |
|---------|-------|-------|-------|
| `brew` | ‚úÖ Yes (if installed) | ‚ùå No | macOS-specific (Homebrew) |
| `apt` | ‚ùå No | ‚úÖ Yes (Debian/Ubuntu) | Linux-specific |
| `yum` / `dnf` | ‚ùå No | ‚úÖ Yes (Red Hat/Fedora) | Linux-specific |
| `open` | ‚úÖ Yes | ‚ùå No | macOS-specific (use `xdg-open` on Linux) |
| `pbcopy` / `pbpaste` | ‚úÖ Yes | ‚ùå No | macOS-specific (use `xclip` on Linux) |
| `systemctl` | ‚ùå No | ‚úÖ Yes | Linux-specific (systemd) |
| `launchctl` | ‚úÖ Yes | ‚ùå No | macOS-specific (launchd) |

**Solution**: Check command availability before generating

```rust
pub fn command_exists(cmd: &str) -> bool {
    std::process::Command::new("which")
        .arg(cmd)
        .output()
        .map(|output| output.status.success())
        .unwrap_or(false)
}

// Usage
if platform == Platform::MacOS && command_exists("brew") {
    "brew install package"
} else if platform == Platform::Linux && command_exists("apt") {
    "apt install package"
} else {
    // Generic fallback or error
    return Err("Package manager not found".into());
}
```

---

## Platform-Specific Testing

### Testing Strategy

**1. CI/CD Testing** (Automated, Every Commit)
- **Platform**: Ubuntu 22.04 (GitHub Actions), macOS 13 (GitHub Actions)
- **Architecture**: x86_64 (both), aarch64 (macOS only)
- **Scope**: Unit tests, integration tests, safety tests
- **Coverage**: All code paths, all backends

**GitHub Actions Matrix**:
```yaml
strategy:
  matrix:
    os: [ubuntu-22.04, macos-13, macos-14]  # macos-14 = Apple Silicon
    rust: [stable]
```

---

**2. Manual Testing** (Pre-Release, Week 1 Day 6)
- **Platforms**: macOS Intel, macOS Apple Silicon, Linux x86_64, Linux ARM (Raspberry Pi)
- **Distros**: Ubuntu 22.04, Debian 12, Fedora 38, Arch
- **Shells**: bash, zsh, fish
- **Scope**: E2E user workflows, platform-specific commands

**Manual Test Checklist** (per platform):
```markdown
## Platform: macOS Apple Silicon (M1)

- [ ] Install caro from install.sh
- [ ] Run first command: `caro "list files"`
- [ ] Test static matcher: `caro "show processes"`
- [ ] Test embedded backend: `caro "find large log files"`
- [ ] Test BSD-specific commands: `caro "get file size of README.md"` ‚Üí `stat -f %z README.md`
- [ ] Test safety validation: `caro "delete all files"` ‚Üí Blocked
- [ ] Test shell compatibility: Run in bash, zsh
- [ ] Check binary size: `ls -lh /usr/local/bin/caro`
- [ ] Check memory usage: `ps aux | grep caro`
- [ ] Test uninstall: `rm /usr/local/bin/caro`
```

---

**3. Community Testing** (Beta Release, Week 1)
- **Goal**: Catch edge cases on diverse hardware/distros
- **Method**: Call for beta testers in Discord, provide testing guide
- **Incentive**: Early access, beta badge, acknowledgment in release notes
- **Feedback**: GitHub issues, Discord #bugs

**Beta Testing Guide** (`.claude/beta-testing/community-testing-guide.md`):
```markdown
# Caro v1.1.0-beta Community Testing Guide

Thank you for helping test caro! üôè

## Your Environment
Please report your environment:
- OS: [macOS 13 / Ubuntu 22.04 / etc.]
- Architecture: [Intel x86_64 / Apple Silicon ARM64 / etc.]
- Shell: [bash / zsh / fish]

## What to Test
1. Installation: `curl -sSL https://caro-cli.dev/install.sh | sh`
2. First command: `caro "list files"`
3. Try 10 different queries (file management, system monitoring, etc.)
4. Report any errors, unexpected behavior, or slow performance

## How to Report Issues
- GitHub: https://github.com/user/caro/issues
- Discord: #bugs channel
- Include: Your environment, the query you ran, the expected vs. actual result
```

---

### Platform-Specific Test Cases

**macOS-Specific Tests**:
```markdown
1. BSD command flags
   - Query: "get file size of README.md"
   - Expected: `stat -f %z README.md` (NOT `stat -c %s`)

2. Homebrew detection
   - Query: "install package foo"
   - Expected: `brew install foo` (if brew is available)

3. macOS system commands
   - Query: "open a file in default app"
   - Expected: `open file.txt` (NOT `xdg-open`)

4. Apple Silicon specifics (M1/M2/M3)
   - Query: Check homebrew path: `/opt/homebrew/bin/brew` (NOT `/usr/local/bin/brew`)
```

**Linux-Specific Tests**:
```markdown
1. GNU command flags
   - Query: "get file size of README.md"
   - Expected: `stat -c %s README.md` (NOT `stat -f %z`)

2. Package manager detection
   - Query: "install package foo"
   - Expected: `apt install foo` (Ubuntu) OR `dnf install foo` (Fedora)

3. Linux system commands
   - Query: "open a file in default app"
   - Expected: `xdg-open file.txt` (NOT `open`)

4. systemd services
   - Query: "restart nginx service"
   - Expected: `systemctl restart nginx` (NOT `launchctl`)
```

---

## Shell Compatibility

### POSIX Compliance Strategy

**Goal**: Generate commands that work in POSIX-compliant shells (bash, zsh, sh)

**POSIX-Safe Features**:
- ‚úÖ Simple variable expansion: `$VAR`, `${VAR}`
- ‚úÖ Command substitution: `$(command)` or `` `command` ``
- ‚úÖ Pipes: `cmd1 | cmd2`
- ‚úÖ Redirects: `cmd > file`, `cmd < file`, `cmd 2>&1`
- ‚úÖ Conditionals: `[ condition ]`, `test condition`
- ‚úÖ Loops: `for`, `while`

**Non-POSIX Features to Avoid**:
- ‚ùå Arrays: `arr=(a b c)` (bash/zsh-specific)
- ‚ùå Associative arrays: `declare -A map` (bash 4+ only)
- ‚ùå Extended globs: `**/*.js` (zsh/bash with shopt)
- ‚ùå Process substitution: `<(command)` (bash/zsh-specific)
- ‚ùå Here-strings: `<<< "text"` (bash/zsh-specific)

**Example: POSIX-Compatible Command Generation**:
```rust
// ‚úÖ GOOD: POSIX-compatible
"find . -name '*.log' -mtime -7"  // Works in bash, zsh, sh

// ‚ùå BAD: bash-specific
"find . -name '*.log' -mtime -7 -print0 | xargs -0 ls -lh"  // -print0 is GNU findutils
```

---

### Shell Detection

**Goal**: Detect user's shell, provide shell-specific installation instructions

```rust
pub fn detect_shell() -> Option<String> {
    env::var("SHELL").ok().and_then(|shell_path| {
        std::path::Path::new(&shell_path)
            .file_name()
            .and_then(|name| name.to_str())
            .map(|s| s.to_string())
    })
}

// Usage
match detect_shell().as_deref() {
    Some("bash") => println!("Add to ~/.bashrc: export PATH=$PATH:/usr/local/bin"),
    Some("zsh") => println!("Add to ~/.zshrc: export PATH=$PATH:/usr/local/bin"),
    Some("fish") => println!("Add to ~/.config/fish/config.fish: set -gx PATH $PATH /usr/local/bin"),
    _ => println!("Add to shell config: export PATH=$PATH:/usr/local/bin"),
}
```

---

## Architecture-Specific Testing

### x86_64 Testing

**Test Environments**:
- macOS Intel (Core i7)
- Linux Ubuntu 22.04 (AMD Ryzen / Intel Xeon)

**Focus Areas**:
- AVX2/AVX-512 SIMD optimizations (performance)
- Standard x86_64 instruction set
- Homebrew paths (`/usr/local/bin` on macOS Intel)

---

### ARM64 Testing

**Test Environments**:
- macOS Apple Silicon (M1/M2/M3)
- Linux ARM (Raspberry Pi 4, AWS Graviton)

**Focus Areas**:
- ARM NEON optimizations (performance)
- Homebrew paths (`/opt/homebrew/bin` on Apple Silicon)
- Memory-constrained devices (Raspberry Pi with 4GB RAM)

**Raspberry Pi-Specific Considerations**:
- Slower I/O (microSD card)
- Less RAM (4-8GB vs. 16GB on typical desktop)
- Thermal throttling (CPU slowdown under load)

**Testing**:
```bash
# On Raspberry Pi 4 (8GB RAM, ARM64)
1. Install caro from install.sh
2. Run 10 queries (measure latency, memory usage)
3. Verify embedded backend works (may be slower than desktop)
4. Check for OOM (out-of-memory) errors
```

---

## Cross-Platform Build Strategy

### Build Matrix

**GitHub Actions** (`.github/workflows/release.yml`):
```yaml
strategy:
  matrix:
    include:
      # macOS Intel
      - os: macos-13
        target: x86_64-apple-darwin
        artifact: caro-x86_64-apple-darwin

      # macOS Apple Silicon
      - os: macos-14  # M1 runners
        target: aarch64-apple-darwin
        artifact: caro-aarch64-apple-darwin

      # Linux x86_64
      - os: ubuntu-22.04
        target: x86_64-unknown-linux-gnu
        artifact: caro-x86_64-unknown-linux-gnu

      # Linux ARM64
      - os: ubuntu-22.04
        target: aarch64-unknown-linux-gnu
        artifact: caro-aarch64-unknown-linux-gnu
        cross: true  # Use cross-compilation tool

steps:
  - name: Build
    run: |
      if [ "${{ matrix.cross }}" = "true" ]; then
        cargo install cross
        cross build --release --target ${{ matrix.target }}
      else
        cargo build --release --target ${{ matrix.target }}
      fi
```

---

### Binary Naming Convention

```
caro-{arch}-{os}
```

**Examples**:
- `caro-x86_64-apple-darwin` (macOS Intel)
- `caro-aarch64-apple-darwin` (macOS Apple Silicon)
- `caro-x86_64-unknown-linux-gnu` (Linux x86_64)
- `caro-aarch64-unknown-linux-gnu` (Linux ARM64)

---

### Installation Script Platform Detection

**install.sh**:
```bash
#!/bin/sh
set -e

# Detect OS
OS="$(uname -s)"
case "$OS" in
    Darwin) OS="apple-darwin" ;;
    Linux)  OS="unknown-linux-gnu" ;;
    *)      echo "Unsupported OS: $OS"; exit 1 ;;
esac

# Detect architecture
ARCH="$(uname -m)"
case "$ARCH" in
    x86_64)  ARCH="x86_64" ;;
    aarch64|arm64) ARCH="aarch64" ;;
    *)       echo "Unsupported architecture: $ARCH"; exit 1 ;;
esac

# Download binary
BINARY="caro-${ARCH}-${OS}"
URL="https://github.com/user/caro/releases/latest/download/${BINARY}"

echo "Downloading caro for ${ARCH}-${OS}..."
curl -L "$URL" -o /usr/local/bin/caro
chmod +x /usr/local/bin/caro

echo "‚úÖ Caro installed successfully!"
echo "Run: caro --help"
```

---

## Compatibility Assurance

### Compatibility Testing Checklist (Pre-Release)

```markdown
## Week 1, Day 6: Cross-Platform Compatibility Review

### CI/CD Tests (Automated)
- [ ] All CI tests passing on Ubuntu 22.04 (x86_64)
- [ ] All CI tests passing on macOS 13 (x86_64)
- [ ] All CI tests passing on macOS 14 (ARM64)

### Manual Tests (Tier 1 Platforms)
- [ ] macOS Intel: Install, run 10 queries, verify BSD commands
- [ ] macOS Apple Silicon: Install, run 10 queries, verify homebrew paths
- [ ] Linux Ubuntu 22.04: Install, run 10 queries, verify GNU commands
- [ ] Linux Debian 12: Install, run 10 queries, verify compatibility

### Manual Tests (Tier 2 Platforms)
- [ ] Linux Fedora 38: Install, basic smoke test (5 queries)
- [ ] Linux ARM (Raspberry Pi): Install, basic smoke test, check memory usage

### Shell Compatibility
- [ ] bash: Run 10 queries, verify POSIX compliance
- [ ] zsh: Run 10 queries, verify POSIX compliance
- [ ] fish: Run 5 queries, verify basic compatibility (may have limitations)

### Platform-Specific Commands
- [ ] macOS BSD commands: `stat -f`, `date -r`, `sed -i ''`
- [ ] Linux GNU commands: `stat -c`, `date -d`, `sed -i`
- [ ] Package managers: `brew` (macOS), `apt` (Ubuntu), `dnf` (Fedora)

### Binary Distribution
- [ ] All 4 binaries build successfully (macOS x86/ARM, Linux x86/ARM)
- [ ] Binaries are properly signed (macOS) and have correct permissions
- [ ] Install script detects platform and downloads correct binary
- [ ] Checksums (SHA256) published for all binaries

### Documentation
- [ ] README includes platform-specific installation instructions
- [ ] Known platform limitations documented (e.g., "fish shell has limited support")
- [ ] Troubleshooting guide includes platform-specific issues
```

---

## Platform-Specific Documentation

### Platform-Specific README Sections

**Installation (Platform-Specific)**:
```markdown
## Installation

### macOS (Intel & Apple Silicon)
\`\`\`bash
curl -sSL https://caro-cli.dev/install.sh | sh
\`\`\`

Or install manually:
\`\`\`bash
# Intel
curl -L https://github.com/user/caro/releases/latest/download/caro-x86_64-apple-darwin -o /usr/local/bin/caro

# Apple Silicon
curl -L https://github.com/user/caro/releases/latest/download/caro-aarch64-apple-darwin -o /usr/local/bin/caro

chmod +x /usr/local/bin/caro
\`\`\`

### Linux (Ubuntu, Debian, Fedora, Arch)
\`\`\`bash
curl -sSL https://caro-cli.dev/install.sh | sh
\`\`\`

Or install manually:
\`\`\`bash
# x86_64
curl -L https://github.com/user/caro/releases/latest/download/caro-x86_64-unknown-linux-gnu -o /usr/local/bin/caro

# ARM64 (Raspberry Pi, AWS Graviton)
curl -L https://github.com/user/caro/releases/latest/download/caro-aarch64-unknown-linux-gnu -o /usr/local/bin/caro

chmod +x /usr/local/bin/caro
\`\`\`
```

---

### Troubleshooting (Platform-Specific)

```markdown
## Troubleshooting

### macOS: "caro cannot be opened because the developer cannot be verified"

**Solution**: Allow the binary in System Preferences
\`\`\`bash
xattr -d com.apple.quarantine /usr/local/bin/caro
\`\`\`

Or: System Preferences ‚Üí Security & Privacy ‚Üí Allow apps from: Anywhere

### macOS Apple Silicon: Homebrew not found

**Issue**: Caro looks for brew at `/usr/local/bin/brew` but it's at `/opt/homebrew/bin/brew`

**Solution**: Already handled in caro v1.1.0+ (automatic detection)

### Linux: "command not found: caro"

**Issue**: `/usr/local/bin` not in PATH

**Solution**: Add to shell config
\`\`\`bash
# bash/zsh
echo 'export PATH=$PATH:/usr/local/bin' >> ~/.bashrc
source ~/.bashrc

# fish
echo 'set -gx PATH $PATH /usr/local/bin' >> ~/.config/fish/config.fish
\`\`\`

### Linux: Permission denied when installing

**Issue**: No write access to `/usr/local/bin`

**Solution**: Install to user directory
\`\`\`bash
curl -L https://github.com/user/caro/releases/latest/download/caro-x86_64-unknown-linux-gnu -o ~/.local/bin/caro
chmod +x ~/.local/bin/caro
export PATH=$PATH:~/.local/bin
\`\`\`
```

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2026-01-08 | Engineering Lead + Platform Engineer | Initial cross-platform compatibility & testing strategy |

---

**End of Document**
