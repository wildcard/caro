# Feature Flags & Progressive Rollout Strategy

**Release**: v1.1.0-beta
**Created**: 2026-01-08
**Owner**: Engineering Lead
**Last Updated**: 2026-01-08

---

## Purpose

This document defines the feature flag and progressive rollout strategy for v1.1.0-beta release and beyond, enabling safe deployment of new features with controlled exposure, rapid rollback, and data-driven decisions about feature adoption.

---

## Audience

- **Primary**: Engineering Lead, Release Manager
- **Secondary**: Engineers, Product Manager
- **Tertiary**: SRE/DevOps (for infrastructure)

---

## Why Feature Flags?

### Benefits

1. **Risk Mitigation**: Deploy code without exposing features, reduce blast radius
2. **Progressive Rollout**: Gradual exposure (1% ‚Üí 5% ‚Üí 25% ‚Üí 50% ‚Üí 100%)
3. **A/B Testing**: Compare feature variants, data-driven decisions
4. **Quick Rollback**: Disable features instantly without code deployment
5. **Separation of Deployment and Release**: Deploy anytime, release when ready
6. **Trunk-Based Development**: No long-lived feature branches

### v1.1.0-beta Use Cases

**Immediate** (v1.1.0-beta):
- None (simple release, no complex features requiring flags)
- Infrastructure established for future use

**Near-Term** (v1.2.0):
- Telemetry cloud sync (opt-in, gradual rollout)
- New command generation model (A/B test quality)
- Enhanced safety patterns (progressive rollout)

**Long-Term** (v1.3.0+):
- New backends (Anthropic Claude, Google Gemini)
- Advanced features (command history, suggestions)
- UI/UX experiments

---

## Section 1: Feature Flag Architecture

### Implementation Approaches

**Option 1: Simple Config-Based Flags** (v1.1.0-beta)
- Flags stored in user config file: `~/.caro/config.toml`
- User controls via CLI: `caro config feature --enable <feature>`
- No remote control, no percentage rollouts
- Simple, privacy-friendly, sufficient for beta

**Option 2: Remote Flag Service** (v1.2.0+)
- Flags fetched from backend on startup
- Percentage-based rollouts
- A/B testing support
- Requires backend infrastructure

**Option 3: Third-Party Service** (v1.3.0+, if needed)
- LaunchDarkly, Split.io, Unleash, etc.
- Full-featured flag management
- Higher cost, external dependency

**Recommendation for v1.1.0-beta**: Start with Option 1 (simple config-based)

---

### Simple Config-Based Implementation

**Config Schema** (`~/.caro/config.toml`):

```toml
[feature_flags]
# Format: feature_name = true/false
telemetry_cloud_sync = false
enhanced_safety_v2 = false
command_history = false
mlx_backend = true  # Enabled by default for Apple Silicon users

# Override specific features
[feature_flags.overrides]
# Can be set by user or by remote config (future)
```

**Rust Implementation**:

```rust
// src/features/mod.rs

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FeatureFlags {
    /// Feature flag map: feature_name -> enabled
    pub flags: HashMap<String, bool>,

    /// User-specific overrides (takes precedence)
    pub overrides: HashMap<String, bool>,
}

impl FeatureFlags {
    /// Check if a feature is enabled
    pub fn is_enabled(&self, feature: &str) -> bool {
        // Priority: overrides > flags > default false
        self.overrides
            .get(feature)
            .or_else(|| self.flags.get(feature))
            .copied()
            .unwrap_or(false)
    }

    /// Enable a feature
    pub fn enable(&mut self, feature: &str) {
        self.overrides.insert(feature.to_string(), true);
    }

    /// Disable a feature
    pub fn disable(&mut self, feature: &str) {
        self.overrides.insert(feature.to_string(), false);
    }

    /// Load from config file
    pub fn load() -> Result<Self, Error> {
        let config_path = dirs::home_dir()
            .ok_or(Error::HomeDirectoryNotFound)?
            .join(".caro/config.toml");

        if !config_path.exists() {
            return Ok(Self::default());
        }

        let config_str = std::fs::read_to_string(config_path)?;
        let config: Config = toml::from_str(&config_str)?;
        Ok(config.feature_flags)
    }

    /// Save to config file
    pub fn save(&self) -> Result<(), Error> {
        let config_path = dirs::home_dir()
            .ok_or(Error::HomeDirectoryNotFound)?
            .join(".caro/config.toml");

        let mut config = if config_path.exists() {
            let config_str = std::fs::read_to_string(&config_path)?;
            toml::from_str::<Config>(&config_str)?
        } else {
            Config::default()
        };

        config.feature_flags = self.clone();

        let config_str = toml::to_string_pretty(&config)?;
        std::fs::write(config_path, config_str)?;
        Ok(())
    }
}

impl Default for FeatureFlags {
    fn default() -> Self {
        let mut flags = HashMap::new();

        // Default feature states
        flags.insert("telemetry_cloud_sync".to_string(), false);
        flags.insert("enhanced_safety_v2".to_string(), false);
        flags.insert("command_history".to_string(), false);

        // Platform-specific defaults
        if cfg!(target_os = "macos") && cfg!(target_arch = "aarch64") {
            flags.insert("mlx_backend".to_string(), true); // Apple Silicon
        } else {
            flags.insert("mlx_backend".to_string(), false);
        }

        Self {
            flags,
            overrides: HashMap::new(),
        }
    }
}
```

**Usage in Code**:

```rust
// src/backends/mod.rs

pub fn select_backend(config: &Config) -> Box<dyn Backend> {
    let flags = &config.feature_flags;

    // Check feature flag before using backend
    if flags.is_enabled("mlx_backend") && is_apple_silicon() {
        Box::new(MLXBackend::new())
    } else if flags.is_enabled("ollama_backend") {
        Box::new(OllamaBackend::new())
    } else {
        Box::new(EmbeddedBackend::new())
    }
}
```

**CLI Commands**:

```bash
# List all feature flags
caro features list

# Enable a feature
caro features enable telemetry_cloud_sync

# Disable a feature
caro features disable telemetry_cloud_sync

# Reset to defaults
caro features reset
```

---

## Section 2: Feature Lifecycle

### Feature Stages

```
1. Development      2. Internal Testing   3. Beta Release      4. General Availability   5. Deprecation
   (flag: off)         (flag: on for        (flag: on for        (flag: always on)        (flag: removed)
                       team only)           opt-in users)

   Code exists         Team tests           Public beta          Default enabled           Code removed
   Not exposed         Give feedback        Collect data         Flag cleanup              Migration complete
```

**Stage Durations**:
- Development: 1-2 weeks (implement feature behind flag)
- Internal Testing: 3-5 days (team dogfooding)
- Beta Release: 1-4 weeks (gradual rollout to users)
- General Availability: Ongoing (feature is default)
- Deprecation: 1-3 months (migrate users off old feature)

---

### Example: Telemetry Cloud Sync Feature

**Stage 1: Development** (v1.2.0 sprint 1)
```rust
// Feature code exists but flag is off
if config.feature_flags.is_enabled("telemetry_cloud_sync") {
    telemetry.sync_to_cloud().await?;
} else {
    // Local-only telemetry (current behavior)
    telemetry.store_locally()?;
}
```
- Flag default: `false`
- User visible: No
- Testing: Unit and integration tests

**Stage 2: Internal Testing** (v1.2.0 sprint 2, days 1-5)
```toml
# Team members manually enable
[feature_flags.overrides]
telemetry_cloud_sync = true
```
- Flag default: `false`, team overrides to `true`
- User visible: No (only team)
- Testing: Team dogfooding, bug fixes

**Stage 3: Beta Release** (v1.2.0 sprint 2, days 6-14)
```bash
# Users opt-in
caro features enable telemetry_cloud_sync
```
- Flag default: `false`, users can opt-in
- User visible: Yes, documented in release notes
- Testing: Real user data, monitor metrics

**Stage 4: General Availability** (v1.2.1, 2 weeks later)
```rust
// Feature is default-on, flag remains for rollback
if config.feature_flags.is_enabled("telemetry_cloud_sync") {
    telemetry.sync_to_cloud().await?;
} else {
    telemetry.store_locally()?;
}
```
- Flag default: `true`
- User visible: Yes, opt-out available
- Testing: Monitor for issues, ready to rollback

**Stage 5: Flag Cleanup** (v1.3.0, 3 months later)
```rust
// Flag removed, feature is always on
telemetry.sync_to_cloud().await?;
```
- Flag removed from code
- Feature is permanent (or has new flag for deprecation)

---

## Section 3: Progressive Rollout Strategy

### Rollout Percentages (Future - Requires Remote Flags)

**Standard Rollout Schedule**:
```
Day 1: 1% of users (Canary)
Day 2: 5% of users (Early adopters)
Day 4: 10% of users
Day 6: 25% of users
Day 8: 50% of users
Day 10: 75% of users
Day 12: 100% of users (Full release)
```

**Accelerated Rollout** (low-risk features):
```
Day 1: 10%
Day 2: 50%
Day 3: 100%
```

**Cautious Rollout** (high-risk features):
```
Week 1: 1%
Week 2: 5%
Week 3: 10%
Week 4: 25%
Week 5: 50%
Week 6: 100%
```

---

### Rollout Criteria & Gates

**Proceed to Next Percentage**:
- ‚úÖ Error rate <5% for current cohort
- ‚úÖ Crash rate <0.1% for current cohort
- ‚úÖ User satisfaction ‚â•80% (from feedback)
- ‚úÖ No P0 bugs reported
- ‚úÖ Performance within targets
- ‚úÖ 24-hour soak time at current percentage

**Pause Rollout**:
- ‚ö†Ô∏è Error rate >5% for new cohort
- ‚ö†Ô∏è Crash rate >0.1% for new cohort
- ‚ö†Ô∏è User satisfaction <80%
- ‚ö†Ô∏è P1 bug affecting >10% of cohort

**Rollback Immediately**:
- üö® P0 bug (crashes, data loss, security)
- üö® Error rate >20%
- üö® Crash rate >1%
- üö® Negative feedback >50%

---

### Monitoring During Rollout

**Metrics to Track**:
```sql
-- Feature adoption rate
SELECT
    COUNT(DISTINCT CASE WHEN feature_enabled = true THEN user_id END) * 100.0 / COUNT(DISTINCT user_id) as adoption_rate
FROM feature_flag_events
WHERE feature_name = 'telemetry_cloud_sync'
  AND timestamp >= NOW() - INTERVAL '7 days';

-- Error rate by feature flag
SELECT
    feature_enabled,
    COUNT(*) FILTER (WHERE event_type = 'Error') * 100.0 / COUNT(*) as error_rate
FROM events
WHERE feature_name = 'telemetry_cloud_sync'
  AND timestamp >= NOW() - INTERVAL '24 hours'
GROUP BY feature_enabled;

-- Performance by feature flag
SELECT
    feature_enabled,
    AVG(response_time_ms) as avg_response_time,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time_ms) as p95_response_time
FROM events
WHERE feature_name = 'telemetry_cloud_sync'
  AND timestamp >= NOW() - INTERVAL '24 hours'
GROUP BY feature_enabled;
```

**Alerts**:
- Error rate spike for feature cohort (>2x baseline)
- Performance degradation (>1.5x baseline response time)
- Negative feedback surge (>5x baseline)

---

## Section 4: Feature Flag Best Practices

### Naming Conventions

**Good Names**:
- `telemetry_cloud_sync` (clear, specific)
- `enhanced_safety_v2` (versioned, clear upgrade path)
- `mlx_backend` (specific backend)
- `command_history` (feature name)

**Bad Names**:
- `new_feature` (vague)
- `experiment_123` (unclear purpose)
- `temp_fix` (temporary flags should be short-lived)
- `alice_test` (personal flags should be development-only)

**Naming Pattern**: `<domain>_<feature>_<version?>`
- Domain: telemetry, safety, backend, ui, etc.
- Feature: cloud_sync, pattern_v2, history, etc.
- Version: v2, v3, etc. (if multiple iterations)

---

### Flag Hygiene

**Short-Lived Flags**:
- Flags should be temporary (weeks to months, not years)
- Set expiration date when creating flag
- Review flags quarterly, remove unused ones
- Maximum lifespan: 6 months (then remove or make permanent)

**Long-Lived Flags**:
- Kill switches for critical features (acceptable long-term)
- Operational toggles (backend selection, feature opt-in)
- Platform-specific flags (iOS, Android, etc.)

**Flag Cleanup Process**:
```rust
// Before removing flag from code, ensure:
// 1. Flag has been 100% for ‚â•30 days
// 2. No rollback needed in that time
// 3. Users informed of change (release notes)

// Old code (with flag)
if config.feature_flags.is_enabled("command_history") {
    show_command_history();
} else {
    show_nothing();
}

// New code (flag removed, feature permanent)
show_command_history();

// Commit message: "feat: Make command_history permanent, remove feature flag"
```

---

### Flag Documentation

**Required Documentation** (for each flag):

```rust
/// Feature flag: telemetry_cloud_sync
///
/// **Description**: Enable cloud sync for telemetry data
///
/// **Added**: v1.2.0 (2026-02-01)
/// **Default**: false (opt-in)
/// **Expires**: v1.3.0 (2026-05-01) - should be default by then
///
/// **Status**: Beta testing
/// **Rollout**: 25% of opted-in users (2026-02-10)
///
/// **Risks**:
/// - Privacy: Ensure no PII in synced data
/// - Performance: Additional network latency
/// - Cost: Backend infrastructure costs
///
/// **Metrics to Monitor**:
/// - Sync success rate (target: >95%)
/// - Sync latency (target: <500ms)
/// - Error rate (target: <5%)
///
/// **Rollback Plan**: Disable flag remotely, local-only fallback
///
/// **Owner**: @alice
/// **Tracking**: Issue #245
pub const TELEMETRY_CLOUD_SYNC: &str = "telemetry_cloud_sync";
```

---

### Testing with Feature Flags

**Test Both States**:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_telemetry_local_only() {
        let mut config = Config::default();
        config.feature_flags.disable("telemetry_cloud_sync");

        let telemetry = Telemetry::new(config);
        telemetry.record_event(...);

        // Assert: Event stored locally, NOT synced to cloud
        assert!(telemetry.local_db_has_event(...));
        assert!(!telemetry.cloud_has_event(...));
    }

    #[test]
    fn test_telemetry_cloud_sync() {
        let mut config = Config::default();
        config.feature_flags.enable("telemetry_cloud_sync");

        let telemetry = Telemetry::new(config);
        telemetry.record_event(...);

        // Assert: Event synced to cloud AND stored locally
        assert!(telemetry.local_db_has_event(...));
        assert!(telemetry.cloud_has_event(...));
    }

    #[test]
    fn test_telemetry_cloud_sync_fallback() {
        let mut config = Config::default();
        config.feature_flags.enable("telemetry_cloud_sync");

        // Simulate cloud unavailable
        let telemetry = Telemetry::new_with_mock_cloud(MockCloud::unavailable());
        telemetry.record_event(...);

        // Assert: Falls back to local-only, no data loss
        assert!(telemetry.local_db_has_event(...));
        assert!(!telemetry.cloud_has_event(...));
    }
}
```

---

## Section 5: A/B Testing Framework (Future)

### A/B Test Structure

**Example**: Test new command generation model

```rust
pub struct ABTest {
    pub name: String,
    pub variants: Vec<Variant>,
    pub allocation: HashMap<String, f32>, // variant -> percentage
    pub metrics: Vec<String>,
}

pub struct Variant {
    pub name: String,
    pub config: Value, // JSON config for this variant
}

// Example: Model comparison
let ab_test = ABTest {
    name: "command_model_comparison".to_string(),
    variants: vec![
        Variant {
            name: "control".to_string(),
            config: json!({"model": "smollm-135m"}),
        },
        Variant {
            name: "treatment".to_string(),
            config: json!({"model": "qwen2-1.5b"}),
        },
    ],
    allocation: [
        ("control".to_string(), 0.5),
        ("treatment".to_string(), 0.5),
    ].iter().cloned().collect(),
    metrics: vec![
        "command_success_rate".to_string(),
        "response_time_ms".to_string(),
        "user_satisfaction".to_string(),
    ],
};
```

---

### A/B Test Analysis

**Statistical Significance**:
```python
# Python script for A/B test analysis
import scipy.stats as stats

# Data from metrics
control_success_rate = 0.94  # 94% success
treatment_success_rate = 0.97  # 97% success

control_n = 1000
treatment_n = 1000

# Chi-square test for proportions
control_successes = control_success_rate * control_n
treatment_successes = treatment_success_rate * treatment_n

chi2, p_value = stats.chisquare([control_successes, treatment_successes])

if p_value < 0.05:
    print(f"‚úÖ Statistically significant improvement: p={p_value:.4f}")
    print(f"Treatment is {(treatment_success_rate / control_success_rate - 1) * 100:.1f}% better")
else:
    print(f"‚ùå No significant difference: p={p_value:.4f}")
```

**Decision Criteria**:
- Statistical significance: p < 0.05
- Practical significance: >5% improvement
- No regression in other metrics
- Sample size: ‚â•1000 users per variant

**Decision**:
- If treatment wins: Roll out to 100%
- If control wins: Keep current implementation
- If no difference: Keep simpler/cheaper option

---

## Section 6: Kill Switches

### Emergency Kill Switches

**Purpose**: Instantly disable features in production without deployment

**Implementation**:

```rust
// src/features/kill_switches.rs

/// Critical kill switches (can disable entire features)
pub struct KillSwitches {
    /// Disable telemetry entirely (for privacy incidents)
    pub telemetry_disabled: bool,

    /// Disable LLM backends (for quality incidents)
    pub llm_backends_disabled: bool,

    /// Disable command execution (for safety incidents)
    pub command_execution_disabled: bool,
}

impl KillSwitches {
    /// Load from local config or remote (future)
    pub fn load() -> Self {
        // Priority: Remote config > Local config > Defaults
        let remote = Self::fetch_remote().ok();
        let local = Self::load_local().ok();

        remote.or(local).unwrap_or_default()
    }

    /// Check if feature should be disabled
    pub fn is_disabled(&self, feature: &str) -> bool {
        match feature {
            "telemetry" => self.telemetry_disabled,
            "llm_backends" => self.llm_backends_disabled,
            "command_execution" => self.command_execution_disabled,
            _ => false,
        }
    }
}

impl Default for KillSwitches {
    fn default() -> Self {
        Self {
            telemetry_disabled: false,
            llm_backends_disabled: false,
            command_execution_disabled: false,
        }
    }
}
```

**Usage**:

```rust
// Check kill switch before executing critical code
let kill_switches = KillSwitches::load();

if kill_switches.is_disabled("telemetry") {
    // Telemetry disabled, skip all telemetry code
    return Ok(());
}

// Normal telemetry code
telemetry.record_event(...);
```

**Kill Switch Activation** (Crisis scenario):

```bash
# Emergency: Privacy incident detected
# T+5 min: Disable telemetry via kill switch

# Option 1: Local config (user's machine)
caro features kill-switch --enable telemetry_disabled

# Option 2: Remote config (future - backend push)
curl -X POST https://api.caro.sh/admin/kill-switches \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -d '{"telemetry_disabled": true}'

# Option 3: Update install script to set default
sed -i 's/TELEMETRY_DEFAULT=true/TELEMETRY_DEFAULT=false/' install.sh
git push  # New installs have telemetry disabled by default
```

---

### Kill Switch Monitoring

**Alerts**:
- Kill switch activated ‚Üí Alert all engineers immediately
- Kill switch remains active >24 hours ‚Üí Escalate to leadership
- Kill switch removed ‚Üí Notify team, monitor closely

**Documentation**:
- Document why kill switch was activated
- Track duration of activation
- Post-mortem to prevent future need

---

## Section 7: Feature Flag Security

### Security Considerations

**Flag Tampering**:
- Local config file is user-controlled (acceptable risk)
- Remote config (future) must be signed and verified
- Malicious flags could enable experimental/unsafe features
- Mitigation: Critical features require additional authentication

**PII in Flags**:
- Never include user PII in flag names or values
- Never log flag states with user identifiers
- Aggregate metrics only (no per-user flag states)

**Backdoor Flags**:
- Avoid "debug" or "admin" flags in production
- If needed, require authentication + logging
- Time-limited (expire after 24 hours)

---

### Access Control (Future - Remote Flags)

**Who Can Toggle Flags**:
- Release Manager: All flags
- Engineering Lead: Feature flags (not kill switches)
- Engineers: Development flags only
- Users: Opt-in flags only

**Audit Log**:
```
2026-01-15 14:32:01 - @alice enabled feature flag: telemetry_cloud_sync
2026-01-15 18:45:23 - @bob disabled kill switch: llm_backends_disabled
2026-01-16 09:12:45 - @charlie increased rollout percentage: 25% ‚Üí 50%
```

---

## Section 8: Implementation Roadmap

### v1.1.0-beta (Current Release)

**Implemented**:
- ‚ùå No feature flags (not needed for simple release)
- ‚ùå Infrastructure not yet built

**Planned for v1.2.0**:
- ‚úÖ Simple config-based feature flags
- ‚úÖ CLI commands for flag management
- ‚úÖ Platform-specific defaults (e.g., MLX on Apple Silicon)

---

### v1.2.0 (Q1 2026)

**Features to Flag**:
1. **Telemetry Cloud Sync** (P1)
   - Opt-in, gradual rollout
   - Monitor sync success rate, latency, errors

2. **Enhanced Safety Patterns v2** (P1)
   - More comprehensive validation
   - A/B test: v1 vs v2 accuracy

3. **Command History** (P2)
   - New feature, test user adoption
   - Monitor storage usage, performance impact

**Implementation**:
- Simple config-based flags
- CLI commands: `caro features {list|enable|disable|reset}`
- Testing framework for both flag states

---

### v1.3.0+ (Q2 2026 and beyond)

**Advanced Features**:
- Remote flag service (percentage rollouts, A/B testing)
- Kill switches with remote activation
- Feature experimentation framework
- Automated rollout based on metrics

**Infrastructure**:
- Backend API for flag management
- Admin dashboard for flag control
- Real-time metrics and alerting
- Automated rollback on issues

---

## Section 9: Documentation for Users

### User-Facing Documentation

**README Section** (for v1.2.0):

```markdown
## Experimental Features

Caro includes experimental features that you can opt into. These features are under active development and may change.

### Available Features

#### Telemetry Cloud Sync (Beta)
Sync your telemetry data to the cloud for cross-device insights.

**Enable**: `caro features enable telemetry_cloud_sync`
**Status**: Beta (25% rollout)
**Privacy**: Zero PII, encrypted in transit

#### Enhanced Safety Patterns v2 (Beta)
More comprehensive command safety validation.

**Enable**: `caro features enable enhanced_safety_v2`
**Status**: Beta (50% rollout)
**Note**: May block more commands, err on side of safety

### Managing Features

```bash
# List all features
caro features list

# Enable a feature
caro features enable <feature_name>

# Disable a feature
caro features disable <feature_name>

# Reset to defaults
caro features reset
```

### Providing Feedback

Try experimental features and share feedback:
- Discord: #feedback channel
- GitHub: Open an issue with "feedback" label
- Email: feedback@caro.sh
```

---

## Document Control

**Document Version**: 1.0
**Last Reviewed**: 2026-01-08
**Next Review**: 2026-02-15 (before v1.2.0 feature flag implementation)
**Owner**: Engineering Lead
**Approvers**: Release Manager, Product Manager

**Change History**:
- 2026-01-08: Initial creation (Engineering Lead)

---

**End of Feature Flags & Progressive Rollout Strategy**

This strategy enables safe, controlled deployment of new features with quick rollback capabilities, progressive exposure, and data-driven decisions about feature adoption throughout v1.2.0 and beyond.

**For v1.1.0-beta**: Feature flag infrastructure is planned but not implemented. Simple release with no complex features requiring flags.

**For v1.2.0+**: Feature flags enable safer, faster iteration on new capabilities with reduced risk and data-driven rollout decisions.
