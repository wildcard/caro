# Release Version Control & Branching Strategy

**Version**: 1.0
**Last Updated**: 2026-01-08
**Owner**: Engineering Lead + Release Manager
**Status**: Active

---

## Document Purpose

This document defines the version control strategy, branching model, merge policies, and release tagging conventions for the v1.1.0-beta release and beyond. It ensures consistent, safe, and predictable code management across the team.

**Audience**: Engineering Lead, All Developers, Release Manager, Contributors

**Related Documents**:
- `v1.1.0-release-automation-cicd-pipeline.md` - CI/CD automation and builds
- `v1.1.0-release-runbook-sop.md` - Day-to-day release procedures
- `v1.1.0-quality-assurance-testing-strategy.md` - Testing requirements
- `v1.1.0-release-rollback-recovery-procedures.md` - Rollback procedures

---

## Table of Contents

1. [Branching Philosophy](#branching-philosophy)
2. [Branch Structure](#branch-structure)
3. [Branching Workflow](#branching-workflow)
4. [Commit Conventions](#commit-conventions)
5. [Pull Request Process](#pull-request-process)
6. [Release Tagging](#release-tagging)
7. [Merge Policies](#merge-policies)

---

## Branching Philosophy

### Core Principles

**1. Main is Always Releasable**: `main` branch is production-ready at all times
**2. Feature Branches for Everything**: All changes go through feature branches + PR
**3. Fast-Forward When Possible**: Clean, linear history for easier debugging
**4. Semantic Versioning**: Clear version numbers (MAJOR.MINOR.PATCH-LABEL)
**5. Tags Mark Releases**: Git tags are source of truth for releases

### Branching Model: GitHub Flow (Simplified)

We use a simplified **GitHub Flow** model optimized for continuous delivery:

```
main (always deployable)
  ↑
  ├─ feat/new-feature → PR → merge
  ├─ fix/bug-fix → PR → merge
  ├─ docs/documentation → PR → merge
  └─ hotfix/critical-fix → PR → merge (fast-track)
```

**Why Not Git Flow?**
- Git Flow is overkill for our small team and rapid iteration
- We don't need long-lived `develop` branch (main serves that purpose)
- Release branches are created only when needed (for patching old versions)
- Simpler = fewer merge conflicts, faster velocity

---

## Branch Structure

### Protected Branches

**main** (protected):
- **Purpose**: Production-ready code, always deployable
- **Protection Rules**:
  - Require PR for all changes (no direct commits)
  - Require 1 approval from code owner
  - Require all CI checks to pass
  - Require branch to be up-to-date before merge
  - Require linear history (squash or rebase, no merge commits)
- **Who Can Merge**: Maintainers only (Engineering Lead, Release Manager)

### Temporary Branches (Created on Demand)

**Feature Branches** (`feat/*`, `feature/*`):
```
feat/multi-step-commands
feat/command-history
feature/backend-ollama-streaming
```
- **Purpose**: New features, enhancements
- **Lifetime**: Created → Developed → PR → Merged → Deleted
- **Naming**: `feat/` or `feature/` + kebab-case description
- **Branch From**: `main`
- **Merge Into**: `main` (via PR)

**Bug Fix Branches** (`fix/*`, `bugfix/*`):
```
fix/issue-123-validation-crash
fix/macos-arm-build-failure
bugfix/json-parse-error
```
- **Purpose**: Bug fixes (non-critical)
- **Lifetime**: Created → Fixed → PR → Merged → Deleted
- **Naming**: `fix/` or `bugfix/` + issue-number + description
- **Branch From**: `main`
- **Merge Into**: `main` (via PR)

**Hotfix Branches** (`hotfix/*`):
```
hotfix/p0-security-validation-bypass
hotfix/critical-crash-on-startup
```
- **Purpose**: Critical bugs (P0) that need immediate deployment
- **Lifetime**: Created → Fixed → PR (fast-track) → Merged → Deployed → Deleted
- **Naming**: `hotfix/` + severity + brief description
- **Branch From**: `main` (or release tag if patching old version)
- **Merge Into**: `main` (via fast-track PR, 30 min max review)
- **Special**: CI/CD auto-deploys on merge, skips normal release process

**Documentation Branches** (`docs/*`):
```
docs/installation-guide
docs/api-reference
docs/troubleshooting-macos
```
- **Purpose**: Documentation updates, README changes
- **Lifetime**: Created → Written → PR → Merged → Deleted
- **Naming**: `docs/` + description
- **Branch From**: `main`
- **Merge Into**: `main` (via PR, expedited review)

**Refactoring Branches** (`refactor/*`):
```
refactor/backend-trait-cleanup
refactor/error-handling
```
- **Purpose**: Code refactoring (no behavior change)
- **Lifetime**: Created → Refactored → PR → Merged → Deleted
- **Naming**: `refactor/` + description
- **Branch From**: `main`
- **Merge Into**: `main` (via PR, require extra test coverage)

**Testing Branches** (`test/*`):
```
test/integration-tests-expansion
test/e2e-macos-scenarios
```
- **Purpose**: Test improvements (no production code changes)
- **Lifetime**: Created → Written → PR → Merged → Deleted
- **Naming**: `test/` + description
- **Branch From**: `main`
- **Merge Into**: `main` (via PR)

**Release Branches** (`release/v*`) - *Rarely Used*:
```
release/v1.0.x
release/v1.1.x
```
- **Purpose**: Patching old releases (if users can't upgrade immediately)
- **Lifetime**: Created from release tag → Patched → Tagged → Kept (long-lived)
- **Naming**: `release/v` + MAJOR.MINOR + `.x`
- **Branch From**: Release tag (e.g., `v1.0.0`)
- **Merge Into**: Self (never merge back to main)
- **Special**: Only created when needed (most releases don't need this)

---

## Branching Workflow

### Standard Feature Workflow

**Step 1: Create Branch from Latest Main**
```bash
# Ensure main is up-to-date
git checkout main
git pull origin main

# Create feature branch
git checkout -b feat/command-history

# Verify you're on the new branch
git branch
```

**Step 2: Develop with Frequent Commits**
```bash
# Make changes, commit often (small commits)
git add src/history.rs
git commit -m "feat(history): Add command history storage"

git add src/main.rs
git commit -m "feat(history): Integrate history with CLI"

git add tests/history_tests.rs
git commit -m "test(history): Add unit tests for history storage"

# Push to remote frequently (backup + collaboration)
git push origin feat/command-history
```

**Step 3: Keep Branch Updated with Main**
```bash
# Periodically rebase on main to avoid conflicts
git fetch origin
git rebase origin/main

# If conflicts, resolve them, then continue
git rebase --continue

# Force push after rebase (rewriting history)
git push origin feat/command-history --force-with-lease
```

**Step 4: Open Pull Request**
```bash
# Using GitHub CLI (recommended)
gh pr create \
  --title "feat(history): Add command history feature" \
  --body "Implements command history storage and retrieval. Fixes #234."

# Or via GitHub web UI
```

**Step 5: Address Review Feedback**
```bash
# Make changes based on review
git add .
git commit -m "refactor(history): Use Vec instead of LinkedList per review"
git push origin feat/command-history

# CI/CD automatically re-runs tests
```

**Step 6: Merge (Maintainer Only)**
```bash
# After approval, maintainer merges using "Squash and merge"
# This creates a single commit on main with all changes

# GitHub UI: Click "Squash and merge"
# Or via CLI:
gh pr merge 123 --squash --delete-branch
```

**Step 7: Cleanup (Automatic)**
```bash
# Branch is automatically deleted after merge
# Locally, clean up:
git checkout main
git pull origin main
git branch -d feat/command-history
```

---

### Hotfix Workflow (P0 Bugs)

**Step 1: Create Hotfix Branch Immediately**
```bash
git checkout main
git pull origin main
git checkout -b hotfix/p0-validation-bypass
```

**Step 2: Implement Fix with Tests**
```bash
# Make minimal change to fix issue
git add src/safety/validator.rs
git commit -m "fix(critical): Prevent validation bypass in edge case

Fixes #456

Impact: P0 - Security issue allowing dangerous commands
Root cause: Missing validation for compound commands
Fix: Add validation for ';' and '&&' separators
Tested: Added 5 regression tests"
```

**Step 3: Run Full Test Suite Locally**
```bash
cargo test --all-features
# Must pass 100% before pushing
```

**Step 4: Push and Create Fast-Track PR**
```bash
git push origin hotfix/p0-validation-bypass

gh pr create \
  --title "[HOTFIX P0] Prevent validation bypass" \
  --body "Critical security fix. Requires immediate merge and deploy." \
  --label "priority:P0"
```

**Step 5: Fast-Track Review (30 Min Max)**
- Tag Engineering Lead for immediate review
- Focus on: Does it fix the issue? Are tests sufficient? Any regressions?
- Approve if all checks pass

**Step 6: Merge and Auto-Deploy**
```bash
# Maintainer merges immediately
gh pr merge 456 --squash --delete-branch

# CI/CD automatically:
# 1. Merges to main
# 2. Runs full test suite
# 3. Builds all platforms
# 4. Creates hotfix tag (e.g., v1.1.0-hotfix.1)
# 5. Deploys to GitHub releases
# 6. Notifies team in Discord
```

**Step 7: Monitor for 30 Minutes**
```bash
# Watch metrics dashboard
# Monitor error logs
# Check user reports

# If issues, immediate rollback (see rollback procedures doc)
```

**Hotfix SLA**: From P0 confirmation to deployed fix: **4 hours maximum**

---

## Commit Conventions

### Commit Message Format (Conventional Commits)

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Type** (required):
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation only
- `refactor`: Code refactoring (no behavior change)
- `test`: Test additions or improvements
- `perf`: Performance improvements
- `ci`: CI/CD changes
- `chore`: Maintenance tasks (dependencies, build config)

**Scope** (optional but recommended):
- Component/module affected: `backend`, `safety`, `cli`, `prompts`, etc.
- Special scopes: `critical`, `breaking`

**Subject** (required):
- Imperative mood: "Add feature" not "Added feature"
- No period at the end
- Max 50 characters
- Lowercase (except proper nouns)

**Body** (optional but recommended for non-trivial changes):
- Explain what and why, not how
- Wrap at 72 characters
- Separate from subject with blank line

**Footer** (optional):
- Reference issues: `Fixes #123`, `Closes #456`, `Related to #789`
- Breaking changes: `BREAKING CHANGE: <description>`

### Commit Message Examples

**Good Examples**:

```
feat(backend): Add retry logic for model loading

Implements exponential backoff retry when model loading fails.
This improves reliability on systems with limited memory.

Fixes #234
```

```
fix(safety): Prevent command injection via semicolon

Added validation for ';' separator to prevent injection attacks.

Impact: P0 - Security vulnerability
Root cause: Missing separator validation
Fix: Check for ';', '&&', '||' in generated commands
Tested: 5 regression tests added

Fixes #456
```

```
docs: Update installation guide for Apple Silicon

Added specific instructions for M1/M2/M3 Macs.
Clarified Rosetta 2 requirements.
```

```
refactor(prompts): Extract platform detection to helper

No behavior change. Makes code more testable and reusable.
```

**Bad Examples**:

```
❌ updated stuff
   (Too vague, no type, not imperative)

❌ Fix bug.
   (No scope, no description of what bug)

❌ Added a really cool new feature that does amazing things
   (Too long subject, not descriptive, hype over substance)

❌ WIP commit
   (Work-in-progress commits should be squashed before PR)
```

### Atomic Commits

**Principle**: Each commit should be a single logical change

**Good** (atomic):
```
commit 1: feat(history): Add storage module
commit 2: feat(history): Add retrieval functions
commit 3: feat(history): Integrate with CLI
commit 4: test(history): Add unit tests
```

**Bad** (non-atomic):
```
commit 1: Work in progress (mixed changes)
commit 2: More work (still mixed)
commit 3: Fix bugs and add tests and refactor (way too much)
```

**Why Atomic Commits?**
- Easier to review (one logical change per commit)
- Easier to revert (revert one change without affecting others)
- Easier to debug (bisect to find which commit introduced bug)
- Better history (understand why each change was made)

---

## Pull Request Process

### PR Creation Checklist

Before creating PR:
- [ ] Branch is up-to-date with main (rebased)
- [ ] All commits follow commit conventions
- [ ] All tests pass locally (`cargo test --all-features`)
- [ ] Code formatted (`cargo fmt`)
- [ ] No clippy warnings (`cargo clippy --all-features`)
- [ ] Documentation updated (if user-facing changes)
- [ ] CHANGELOG entry added (if user-facing changes)

### PR Template

```markdown
## Description

Brief description of what this PR does.

## Type of Change

- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] New feature (non-breaking change which adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] Documentation update

## Testing

- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

**Manual Test Plan**:
1. [Step 1]
2. [Step 2]
3. [Expected result]

## Checklist

- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Comments added for complex logic
- [ ] Documentation updated
- [ ] No new warnings
- [ ] Backward compatible (or breaking change justified)

## Related Issues

Fixes #[issue_number]
Related to #[issue_number]

## Screenshots (if applicable)

[Add screenshots for UI changes]
```

### PR Review Process

**Reviewer Checklist**:

**Correctness**:
- [ ] Does it solve the stated problem?
- [ ] Are there edge cases not handled?
- [ ] Is error handling comprehensive?

**Code Quality**:
- [ ] Is code readable and maintainable?
- [ ] Are names clear and descriptive?
- [ ] Is complexity appropriate (not over-engineered)?
- [ ] Are there code smells (duplicated code, god objects, etc.)?

**Testing**:
- [ ] Are tests sufficient (happy path + edge cases)?
- [ ] Do tests actually test the right thing?
- [ ] Is test coverage maintained or improved?

**Safety & Security**:
- [ ] No command injection vulnerabilities?
- [ ] Input validation sufficient?
- [ ] No secrets hardcoded?
- [ ] Safe error messages (no PII leaks)?

**Performance**:
- [ ] No obvious performance issues?
- [ ] Algorithms efficient for expected input sizes?
- [ ] No memory leaks or excessive allocations?

**Documentation**:
- [ ] User-facing changes documented?
- [ ] Complex logic has comments?
- [ ] API changes reflected in docs?

### PR Review SLA

| PR Type | Review SLA | Examples |
|---------|------------|----------|
| **Hotfix (P0)** | 30 minutes | Critical security fixes, production outages |
| **Bug Fix (P1)** | 4 hours | High-priority bugs affecting users |
| **Feature** | 24 hours | New features, enhancements |
| **Documentation** | 4 hours | README, user guides, API docs |
| **Refactoring** | 24 hours | Code cleanup, no behavior change |
| **Tests** | 12 hours | Test additions, no production code change |

### PR Approval Rules

**Minimum Approvals**: 1 from code owner (Engineering Lead or designated maintainer)

**When Multiple Approvals Required**:
- Breaking changes: 2 approvals
- Security-related: 1 approval from Security Lead
- Performance-critical: 1 approval from Engineering Lead
- Infrastructure/CI: 1 approval from Release Manager

**Auto-Merge Conditions** (Optional):
- All CI checks pass
- Required approvals received
- No requested changes
- Branch up-to-date with main

---

## Release Tagging

### Semantic Versioning

**Format**: `v<MAJOR>.<MINOR>.<PATCH>[-<LABEL>]`

**Components**:
- **MAJOR**: Breaking changes (incompatible API changes)
- **MINOR**: New features (backward-compatible)
- **PATCH**: Bug fixes (backward-compatible)
- **LABEL**: Pre-release identifier (alpha, beta, rc, hotfix)

**Examples**:
```
v1.0.0        # First stable release
v1.1.0-beta   # First beta of v1.1.0
v1.1.0        # Stable v1.1.0 release
v1.1.1        # Patch release (bug fixes)
v1.2.0-alpha  # Alpha release of v1.2.0
v1.2.0-rc.1   # Release candidate 1
v2.0.0        # Major version (breaking changes)
```

### When to Bump Version Numbers

**MAJOR (v1.x.x → v2.0.0)**: Breaking changes
- Remove public API functions
- Change CLI flags (incompatible)
- Change output format (breaks scripts)
- Remove backends or features
- Require newer Rust version

**MINOR (v1.1.x → v1.2.0)**: New features
- Add new backends
- Add new CLI flags (backward-compatible)
- Add new features
- Improve performance significantly
- Expand static matcher patterns

**PATCH (v1.1.0 → v1.1.1)**: Bug fixes
- Fix crashes
- Fix incorrect commands
- Fix platform compatibility
- Fix security vulnerabilities
- Fix documentation errors

### Tagging Process

**Step 1: Update Version Numbers**
```bash
# Update Cargo.toml
sed -i 's/^version = .*/version = "1.1.0"/' Cargo.toml

# Update CHANGELOG.md
# Add new version section with changes

git add Cargo.toml CHANGELOG.md
git commit -m "chore: Bump version to v1.1.0"
git push origin main
```

**Step 2: Create Annotated Tag**
```bash
# Create tag with message
git tag -a v1.1.0 -m "Release v1.1.0-beta

First public beta release of caro.

Features:
- Natural language to shell command conversion
- 3 inference backends (static, embedded, ollama)
- Safety validation with 6 critical rules
- Cross-platform support (macOS, Linux)
- 86.8% command success rate

Changes since v1.0.0:
- Added embedded backend with SmolLM and Qwen
- Expanded static matcher to 50+ patterns
- Improved safety validation coverage
- Added beta testing framework

Release Notes: https://github.com/anthropics/caro/releases/v1.1.0"

# Verify tag
git tag -n -l v1.1.0
```

**Step 3: Push Tag to Remote**
```bash
# Push tag (triggers CI/CD release workflow)
git push origin v1.1.0

# CI/CD automatically:
# 1. Builds all platform binaries
# 2. Generates checksums
# 3. Creates GitHub release
# 4. Publishes to crates.io
# 5. Notifies team
```

**Step 4: Verify Release**
```bash
# Check GitHub release page
gh release view v1.1.0

# Verify binaries are available
curl -I https://github.com/anthropics/caro/releases/download/v1.1.0/caro-x86_64-apple-darwin

# Verify crates.io (may take 5-10 min to appear)
cargo search caro
```

### Tag Naming Conventions

**Production Releases**:
```
v1.0.0, v1.1.0, v1.2.0, v2.0.0
```

**Pre-Releases**:
```
v1.1.0-alpha     # Alpha version (very unstable)
v1.1.0-beta      # Beta version (mostly stable, testing)
v1.1.0-rc.1      # Release candidate 1 (stable, final testing)
v1.1.0-rc.2      # Release candidate 2
```

**Hotfixes**:
```
v1.1.0-hotfix.1  # First hotfix for v1.1.0
v1.1.0-hotfix.2  # Second hotfix
```

**Development Snapshots** (optional, for testing):
```
v1.1.0-dev.20260108  # Development snapshot from Jan 8, 2026
```

---

## Merge Policies

### Merge Methods

**Squash and Merge** (default, recommended):
```
feat/my-feature (5 commits) → main (1 commit)

Advantages:
- Clean, linear history on main
- One commit per feature/fix
- Easy to revert entire feature
- Commit messages can be cleaned up

Use for: Most PRs (features, fixes, docs)
```

**Rebase and Merge** (when commit history matters):
```
feat/my-feature (5 commits) → main (5 commits, rebased)

Advantages:
- Preserves individual commits
- Good for large features with logical progression
- Linear history (no merge commits)

Use for: Large refactorings, complex features with meaningful commit history
```

**Merge Commit** (discouraged):
```
feat/my-feature → main (merge commit created)

Disadvantages:
- Creates merge commits (clutters history)
- Harder to understand history
- Makes bisect more difficult

Use for: Never (disabled in our repo)
```

### Protected Branch Rules (main)

**Enforcement** (via GitHub settings):
- ✅ Require pull request before merging
- ✅ Require approvals: 1
- ✅ Dismiss stale approvals when new commits pushed
- ✅ Require review from code owners
- ✅ Require status checks to pass before merging:
  - `test` (cargo test --all-features)
  - `clippy` (cargo clippy --all-features)
  - `fmt` (cargo fmt --check)
  - `audit` (cargo audit)
  - `build-macos-x86_64`
  - `build-macos-aarch64`
  - `build-linux-x86_64`
  - `build-linux-aarch64`
- ✅ Require branches to be up to date before merging
- ✅ Require linear history (squash or rebase only)
- ✅ Require signed commits (optional, recommended for maintainers)
- ❌ Allow force pushes (forbidden on main)
- ❌ Allow deletions (forbidden on main)

**Code Owners** (`.github/CODEOWNERS`):
```
# Global owners (Engineering Lead)
* @engineering-lead

# Safety module (requires Security Lead approval)
src/safety/** @security-lead @engineering-lead

# CI/CD (requires Release Manager approval)
.github/workflows/** @release-manager @engineering-lead

# Documentation (Community Lead can approve)
docs/** @community-lead
README.md @community-lead
```

---

## Appendix: Common Scenarios

### Scenario 1: Fixing a Typo in README

```bash
# 1. Create branch
git checkout -b docs/fix-readme-typo

# 2. Fix typo
vim README.md

# 3. Commit
git add README.md
git commit -m "docs: Fix typo in installation section"

# 4. Push
git push origin docs/fix-readme-typo

# 5. Create PR (fast-track, < 4h review)
gh pr create --title "docs: Fix typo in README" --body "Fixed typo."

# 6. After approval, merge & delete branch
```

### Scenario 2: Large Feature Taking Multiple Days

```bash
# Day 1
git checkout -b feat/command-history
# Work, commit, push
git add . && git commit -m "feat(history): Add storage module"
git push origin feat/command-history

# Day 2
# Rebase on main to stay updated
git fetch origin
git rebase origin/main
git push origin feat/command-history --force-with-lease

# Work, commit, push
git add . && git commit -m "feat(history): Add retrieval functions"
git push origin feat/command-history

# Day 3
# Rebase again, finish feature
git fetch origin && git rebase origin/main
git push origin feat/command-history --force-with-lease

git add . && git commit -m "feat(history): Integrate with CLI"
git push origin feat/command-history

# Create PR for review
gh pr create --title "feat(history): Add command history"
```

### Scenario 3: Hotfix for Production

```bash
# Immediately create hotfix branch
git checkout main && git pull origin main
git checkout -b hotfix/p0-crash-on-startup

# Fix, test locally, commit
git add src/main.rs
git commit -m "fix(critical): Prevent crash on startup with missing config"
cargo test --all-features  # Must pass

# Push and create fast-track PR
git push origin hotfix/p0-crash-on-startup
gh pr create --title "[HOTFIX P0] Fix crash on startup" --label "priority:P0"

# Engineering Lead reviews within 30 min, merges
# CI/CD auto-deploys hotfix
```

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2026-01-08 | Engineering Lead + Release Manager | Initial version control & branching strategy |

---

**End of Document**
