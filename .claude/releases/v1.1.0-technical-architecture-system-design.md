# v1.1.0 Technical Architecture & System Design

**Version**: 1.0
**Last Updated**: 2026-01-08
**Owner**: Engineering Lead + Technical Architect
**Status**: Active

---

## Executive Summary

This document provides a comprehensive technical architecture overview of caro v1.1.0-beta, including system components, data flows, design decisions, and architectural patterns. It serves as the definitive technical reference for contributors, maintainers, and technical stakeholders.

**Architecture Philosophy**: **Simple, Modular, Extensible** - Clean separation of concerns with minimal coupling between components.

**Core Principles**:
- Local-first (no cloud dependencies)
- Fast path optimization (static matcher first)
- Safety by design (validation at every step)
- Privacy-first (opt-in telemetry only)
- Platform-aware (macOS/Linux/Windows)

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Component Architecture](#component-architecture)
3. [Data Flow](#data-flow)
4. [Backend Architecture](#backend-architecture)
5. [Agent Loop Architecture](#agent-loop-architecture)
6. [Storage Architecture](#storage-architecture)
7. [Design Decisions](#design-decisions)
8. [Extension Points](#extension-points)

---

## System Overview

### High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         User Interface (CLI)                     â”‚
â”‚                         clap + tokio runtime                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Agent Loop                               â”‚
â”‚              Orchestration + Validation + Repair                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                                             â”‚
        â–¼                                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Static Matcher   â”‚                       â”‚  Command Validator   â”‚
â”‚  (Fast Path)      â”‚                       â”‚  (Safety Gatekeeper) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ (miss)
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Embedded Backend  â”‚
â”‚  (Fallback Path)  â”‚
â”‚  SmolLM / Qwen    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Component Responsibilities

| Component | Responsibility | Technology |
|-----------|---------------|------------|
| **CLI** | Argument parsing, user interaction | `clap` |
| **Agent Loop** | Orchestration, retry logic, refinement | `tokio` (async) |
| **Static Matcher** | Pattern-based command generation | Pure Rust |
| **Embedded Backend** | LLM-based command generation | `candle` + models |
| **Validator** | Safety and platform validation | Pure Rust |
| **Storage** | Config, history, telemetry | SQLite, TOML |

---

## Component Architecture

### 1. CLI Layer (`src/main.rs`)

**Purpose**: Entry point, argument parsing, command routing

**Structure**:
```rust
pub struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,

    /// The query to generate a command for
    query: Option<String>,

    /// Force unsafe commands (use with caution)
    #[arg(long)]
    force: bool,

    /// Backend to use (static, embedded, auto)
    #[arg(long, default_value = "auto")]
    backend: BackendType,
}

pub enum Commands {
    /// Generate a command from natural language
    Generate { query: String },

    /// Show configuration
    Config,

    /// Show command history
    History,

    /// Show statistics (if telemetry enabled)
    Stats,

    /// Send feedback
    Feedback { message: String },
}
```

**Key Decisions**:
- Default: Direct query (`caro "list files"`)
- Subcommands: Explicit actions (`caro config`, `caro history`)
- Global flags: `--force`, `--backend`
- Async main: `#[tokio::main]` for async backend support

---

### 2. Agent Loop (`src/agent/mod.rs`)

**Purpose**: Core orchestration logic with retry, repair, and refinement

**Structure**:
```rust
pub struct AgentLoop {
    /// Primary backend (static or embedded)
    backend: Arc<dyn CommandGenerator>,

    /// Optional static matcher for fast path
    static_matcher: Option<StaticMatcher>,

    /// Command validator (safety gatekeeper)
    validator: CommandValidator,

    /// Execution context (OS, platform, shell)
    context: ExecutionContext,

    /// Maximum iterations for refinement
    _max_iterations: usize,

    /// Timeout for generation
    timeout: Duration,

    /// Confidence threshold for refinement
    confidence_threshold: f64,
}

impl AgentLoop {
    /// Generate command with validation, retry, and refinement
    pub async fn generate_command(&self, prompt: &str) -> Result<GeneratedCommand> {
        // 1. Try static matcher first (fast path)
        if let Some(static_result) = self.try_static_matcher(prompt)? {
            return Ok(static_result);
        }

        // 2. Generate with backend
        let initial = self.backend.generate(prompt, &self.context).await?;

        // 3. Validate
        let validation = self.validator.validate(&initial.command);
        if !validation.is_valid() {
            // 4. Repair if validation fails
            return self.repair_command(prompt, &initial, &validation).await;
        }

        // 5. Refine if low confidence
        if initial.confidence_score < self.confidence_threshold {
            return self.refine_command(prompt, &initial).await;
        }

        Ok(initial)
    }
}
```

**Key Features**:
- **Fast Path**: Static matcher bypass for common queries
- **Validation Integration**: Every command validated
- **Automatic Repair**: 70-80% of validation failures fixed
- **Confidence-Based Refinement**: Quality over speed
- **Timeout Protection**: Prevents hanging

---

### 3. Static Matcher (`src/backends/static_matcher.rs`)

**Purpose**: Deterministic pattern matching for common queries

**Architecture**:
```rust
pub struct StaticMatcher {
    /// Compiled patterns (category â†’ patterns)
    patterns: HashMap<QueryCategory, Vec<Pattern>>,

    /// Keyword index for fast lookup
    keyword_index: KeywordIndex,
}

pub struct Pattern {
    /// Pattern identifier
    id: PatternId,

    /// Keywords that trigger this pattern
    keywords: Vec<String>,

    /// Template for command generation
    template: CommandTemplate,

    /// Platform constraints (Some = specific, None = all)
    platform: Option<Platform>,

    /// Priority (higher = preferred)
    priority: u8,
}

impl StaticMatcher {
    pub fn generate(&self, query: &str, context: &ExecutionContext) -> Option<GeneratedCommand> {
        // 1. Extract keywords from query
        let keywords = extract_keywords(query);

        // 2. Lookup candidate patterns
        let candidates = self.keyword_index.lookup(&keywords);

        // 3. Score each candidate
        let mut scored: Vec<(f64, &Pattern)> = candidates
            .iter()
            .filter_map(|p| {
                if p.matches(query, context) {
                    Some((p.score(query, context), p))
                } else {
                    None
                }
            })
            .collect();

        // 4. Sort by score (descending)
        scored.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap());

        // 5. Generate from top match
        scored.first().map(|(score, pattern)| {
            pattern.generate(query, context, *score)
        })
    }
}
```

**Performance Optimizations**:
- Keyword index (O(1) lookup instead of O(n))
- Lazy regex compilation (`lazy_static!`)
- Short-circuit evaluation (priority ordering)

---

### 4. Embedded Backend (`src/backends/embedded/mod.rs`)

**Purpose**: Local LLM inference for novel queries

**Architecture**:
```rust
pub struct EmbeddedBackend {
    /// Model instance (SmolLM or Qwen)
    model: Arc<Mutex<Model>>,

    /// Tokenizer
    tokenizer: Tokenizer,

    /// Model configuration
    config: ModelConfig,

    /// Prompt builder
    prompt_builder: SmolLMPromptBuilder,
}

pub struct ModelConfig {
    /// Model ID (SmolLM-135M, Qwen-1.5B)
    model_id: String,

    /// Temperature (0.1 for accuracy)
    temperature: f64,

    /// Max tokens to generate
    max_tokens: usize,

    /// Top-p sampling
    top_p: f64,
}

impl CommandGenerator for EmbeddedBackend {
    async fn generate(&self, prompt: &str, context: &ExecutionContext) -> Result<GeneratedCommand> {
        // 1. Build system prompt
        let system_prompt = self.prompt_builder.build(context);

        // 2. Format user prompt
        let user_prompt = format_user_prompt(prompt);

        // 3. Combine prompts
        let full_prompt = format!("{}\n\n{}", system_prompt, user_prompt);

        // 4. Tokenize
        let tokens = self.tokenizer.encode(&full_prompt)?;

        // 5. Generate
        let model = self.model.lock().await;
        let output = model.generate(tokens, &self.config)?;

        // 6. Decode
        let text = self.tokenizer.decode(output)?;

        // 7. Parse JSON response
        self.parse_response(&text)
    }
}
```

**Model Loading**:
```rust
pub fn load_model(model_id: &str) -> Result<Model> {
    // 1. Download from HuggingFace Hub (if not cached)
    let model_path = download_model(model_id)?;

    // 2. Load weights
    let weights = load_safetensors(&model_path)?;

    // 3. Initialize model
    let config = ModelConfig::from_file(&model_path)?;
    let model = Model::new(config, weights)?;

    Ok(model)
}
```

**Caching Strategy**:
- First run: Download model (~500MB, 5-10 min)
- Subsequent runs: Load from cache (~5-10 sec)
- Location: `~/.cache/caro/models/`

---

### 5. Command Validator (`src/prompts/validation.rs`)

**Purpose**: Safety and platform validation

**Architecture**:
```rust
pub struct CommandValidator {
    /// Dangerous patterns (rm -rf /, fork bombs, etc.)
    dangerous_patterns: Vec<Regex>,

    /// Sensitive paths (/etc, /usr, etc.)
    sensitive_paths: Vec<PathBuf>,

    /// Platform-specific rules
    platform_rules: PlatformRules,
}

pub struct ValidationResult {
    /// Is the command valid?
    valid: bool,

    /// Validation errors (if any)
    errors: Vec<ValidationError>,

    /// Warnings (non-blocking)
    warnings: Vec<ValidationWarning>,
}

impl CommandValidator {
    pub fn validate(&self, command: &str) -> ValidationResult {
        let mut result = ValidationResult::ok();

        // 1. Check for dangerous patterns
        for pattern in &self.dangerous_patterns {
            if pattern.is_match(command) {
                result.add_error(ValidationError::DangerousPattern {
                    pattern: pattern.as_str().to_string(),
                    command: command.to_string(),
                });
            }
        }

        // 2. Check for sensitive paths
        if let Some(paths) = extract_paths(command) {
            for path in paths {
                if self.is_sensitive_path(&path) {
                    result.add_warning(ValidationWarning::SensitivePath(path));
                }
            }
        }

        // 3. Platform-specific checks
        if let Some(issue) = self.platform_rules.check(command) {
            result.add_error(ValidationError::PlatformIssue(issue));
        }

        result
    }
}
```

**Safety Rules**:
- Blocked: `rm -rf /`, `:(){ :|:& };:`, `curl ... | sh`
- Warnings: Operations on `/etc`, `/usr`, network operations
- Platform: GNU flags on BSD (auto-translatable)

---

## Data Flow

### Successful Generation Flow

```
User Query: "files modified today"
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. CLI Argument Parsing  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Agent Loop Entry      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Try Static Matcher    â”‚ â† Fast Path (45ms)
â”‚    âœ… Match Found        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Command Validator     â”‚
â”‚    âœ… Valid (no errors)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. Return to User        â”‚
â”‚    find . -mtime 0       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Total Latency**: ~50ms (static matcher + validation)

---

### Validation Failure Flow (with Repair)

```
User Query: "show processes by cpu"
       â†“
Agent Loop
       â†“
Embedded Backend generates: "ps aux --sort=-%cpu"
       â†“
Validation: âŒ FAIL (GNU flag on macOS)
       â†“
Repair Triggered
       â†“
Repair Prompt: "Fix GNU flag for BSD"
       â†“
Backend generates: "ps aux | sort -k3 -rn | head -10"
       â†“
Validation: âœ… PASS
       â†“
Return to User
```

**Total Latency**: ~3000ms (2x LLM generation)

---

### Low Confidence Flow (with Refinement)

```
User Query: "find large old files"
       â†“
Backend generates: "ls -lS" (confidence: 0.65)
       â†“
Confidence Check: 0.65 < 0.8 â†’ Refine
       â†“
Refinement Prompt: "Clarify 'large' and 'old'"
       â†“
Backend generates: "find . -type f -size +100M -mtime +30" (confidence: 0.92)
       â†“
Return to User
```

**Total Latency**: ~3500ms (2x LLM generation)

---

## Backend Architecture

### Backend Trait

**Purpose**: Abstract command generation interface

```rust
#[async_trait]
pub trait CommandGenerator: Send + Sync {
    /// Generate a command from natural language
    async fn generate(
        &self,
        prompt: &str,
        context: &ExecutionContext,
    ) -> Result<GeneratedCommand>;

    /// Get backend name (for telemetry)
    fn name(&self) -> &str;

    /// Check if backend supports refinement
    fn supports_refinement(&self) -> bool {
        true
    }
}
```

**Implementations**:
1. `StaticMatcher` (pattern-based, fast)
2. `EmbeddedBackend` (LLM-based, smart)
3. `OllamaBackend` (future: external LLM)
4. `OpenAIBackend` (future: cloud LLM)

---

### Backend Selection Strategy

```rust
pub fn select_backend(
    query: &str,
    config: &Config,
    context: &ExecutionContext,
) -> Arc<dyn CommandGenerator> {
    match config.backend {
        BackendType::Auto => {
            // Try static matcher first
            if can_static_handle(query) {
                Arc::new(StaticMatcher::new())
            } else {
                Arc::new(EmbeddedBackend::new())
            }
        }
        BackendType::Static => Arc::new(StaticMatcher::new()),
        BackendType::Embedded => Arc::new(EmbeddedBackend::new()),
        BackendType::Ollama => Arc::new(OllamaBackend::new(config.ollama_url)),
    }
}
```

**Future Enhancement**: Complexity scoring
```rust
pub fn query_complexity(query: &str) -> f64 {
    // Simple heuristics:
    // - Word count
    // - Logical operators (AND, OR, NOT)
    // - Numeric constraints
    // - Nested conditions

    let score = 0.0;
    // ... scoring logic
    score
}

// Use complexity to select backend:
if query_complexity(query) < 0.3 {
    // Simple query â†’ Static Matcher
} else {
    // Complex query â†’ Embedded LLM
}
```

---

## Agent Loop Architecture

### State Machine

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Initial   â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Generate   â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Validate   â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
       â”‚               â”‚
    Valid?          Invalid?
       â”‚               â”‚
       â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Confidence   â”‚ â”‚   Repair    â”‚
â”‚   Check     â”‚ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â”‚
       â”‚               â”‚
   High/Low?           â–¼
       â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚         â”‚  Re-Validateâ”‚
       â”‚         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                â”‚
       â–¼                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Refine or Return   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Iteration Budget

**Problem**: Infinite loops (e.g., repair always fails)

**Solution**: Maximum iteration budget

```rust
pub struct AgentLoop {
    max_iterations: usize,  // Default: 3
    timeout: Duration,      // Default: 30s
}

impl AgentLoop {
    pub async fn generate_command(&self, prompt: &str) -> Result<GeneratedCommand> {
        let start = Instant::now();

        for iteration in 0..self.max_iterations {
            // Check timeout
            if start.elapsed() > self.timeout {
                return Err(GeneratorError::Timeout);
            }

            // Try generation...
            match self.try_generate(prompt, iteration).await {
                Ok(cmd) => return Ok(cmd),
                Err(e) if iteration < self.max_iterations - 1 => {
                    // Retry
                    continue;
                }
                Err(e) => return Err(e),
            }
        }

        Err(GeneratorError::MaxIterationsExceeded)
    }
}
```

---

## Storage Architecture

### Configuration (`~/.config/caro/config.toml`)

```toml
[general]
default_backend = "auto"  # auto, static, embedded, ollama
confidence_threshold = 0.8

[telemetry]
enabled = false  # Opt-in

[backends.embedded]
model = "SmolLM-135M"  # or Qwen-1.5B
temperature = 0.1

[backends.ollama]
url = "http://localhost:11434"
model = "llama2"

[safety]
allow_dangerous = false
validate_before_execute = true
```

**Loading**:
```rust
pub fn load_config() -> Result<Config> {
    let path = config_path()?;
    if !path.exists() {
        return Ok(Config::default());
    }

    let content = fs::read_to_string(path)?;
    let config: Config = toml::from_str(&content)?;
    Ok(config)
}
```

---

### Command History (`~/.cache/caro/history.db`)

**Schema**:
```sql
CREATE TABLE commands (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    query TEXT NOT NULL,
    command TEXT NOT NULL,
    backend TEXT NOT NULL,
    success BOOLEAN NOT NULL,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_timestamp ON commands(timestamp);
CREATE INDEX idx_success ON commands(success);
```

**Usage**:
```rust
pub struct HistoryStore {
    conn: Connection,
}

impl HistoryStore {
    pub fn record(&self, entry: HistoryEntry) -> Result<()> {
        self.conn.execute(
            "INSERT INTO commands (query, command, backend, success) VALUES (?1, ?2, ?3, ?4)",
            params![entry.query, entry.command, entry.backend, entry.success],
        )?;
        Ok(())
    }

    pub fn recent(&self, limit: usize) -> Result<Vec<HistoryEntry>> {
        let mut stmt = self.conn.prepare(
            "SELECT query, command, backend, success, timestamp FROM commands ORDER BY timestamp DESC LIMIT ?1"
        )?;

        let entries = stmt.query_map([limit], |row| {
            Ok(HistoryEntry {
                query: row.get(0)?,
                command: row.get(1)?,
                backend: row.get(2)?,
                success: row.get(3)?,
                timestamp: row.get(4)?,
            })
        })?;

        entries.collect()
    }
}
```

---

### Telemetry (`~/.cache/caro/metrics.db`)

**Schema** (only if opted-in):
```sql
CREATE TABLE telemetry_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_type TEXT NOT NULL,  -- "generation", "validation_repair", "refinement"
    backend TEXT NOT NULL,
    success BOOLEAN NOT NULL,
    latency_ms INTEGER NOT NULL,
    platform TEXT NOT NULL,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- No PII stored (no queries, no commands, no paths)
```

---

## Design Decisions

### Decision 1: Local-First Architecture

**Context**: Cloud vs. local LLM inference

**Decision**: Local-first with optional cloud backends

**Rationale**:
- **Privacy**: No data sent to cloud by default
- **Offline**: Works without internet
- **Latency**: No network round-trip for embedded backend
- **Cost**: No API costs

**Trade-offs**:
- âŒ Model download size (~500MB)
- âŒ First-run latency (model loading)
- âœ… Privacy, offline, low latency thereafter

---

### Decision 2: Static Matcher as Fast Path

**Context**: Should we always use LLM?

**Decision**: Pattern matching first, LLM fallback

**Rationale**:
- **Performance**: 50ms vs 2000ms
- **Accuracy**: 86%+ for common queries
- **Determinism**: Predictable output
- **Cost**: No model inference

**Trade-offs**:
- âŒ Limited to predefined patterns
- âŒ Maintenance overhead (adding patterns)
- âœ… 10x-40x faster for common queries

---

### Decision 3: Validation After Generation

**Context**: Validate before or after showing to user?

**Decision**: Validate immediately after generation

**Rationale**:
- **Safety**: Never show dangerous commands
- **Trust**: Users expect validated output
- **Repair**: Can fix automatically

**Trade-offs**:
- âŒ Extra latency (5-10ms)
- âœ… Safety guaranteed

---

### Decision 4: Confidence-Based Refinement

**Context**: How to improve uncertain commands?

**Decision**: Refine if confidence <0.8

**Rationale**:
- **Quality**: Better commands for complex queries
- **Adaptive**: Only refine when needed (30% of queries)
- **Transparent**: Users don't see low-confidence output

**Trade-offs**:
- âŒ 2x latency for refined queries
- âœ… Higher quality output

---

### Decision 5: SQLite for Storage

**Context**: Plain files vs. database?

**Decision**: SQLite for history and telemetry

**Rationale**:
- **Querying**: Easy aggregation (stats, filtering)
- **Atomicity**: ACID transactions
- **Performance**: Fast for small datasets
- **Zero-config**: No server needed

**Trade-offs**:
- âŒ Slightly more complex than JSON
- âœ… Much better for queries and analytics

---

## Extension Points

### 1. Adding New Backend

**Interface**:
```rust
pub struct MyCustomBackend {
    // Your fields
}

#[async_trait]
impl CommandGenerator for MyCustomBackend {
    async fn generate(&self, prompt: &str, context: &ExecutionContext) -> Result<GeneratedCommand> {
        // Your implementation
        todo!()
    }

    fn name(&self) -> &str {
        "my_custom_backend"
    }
}
```

**Registration**:
```rust
// In src/backends/mod.rs
pub fn create_backend(backend_type: BackendType) -> Arc<dyn CommandGenerator> {
    match backend_type {
        BackendType::Static => Arc::new(StaticMatcher::new()),
        BackendType::Embedded => Arc::new(EmbeddedBackend::new()),
        BackendType::Custom => Arc::new(MyCustomBackend::new()),  // â† Add here
    }
}
```

---

### 2. Adding New Static Patterns

**File**: `src/backends/static_matcher/patterns.rs`

```rust
pub fn file_management_patterns() -> Vec<Pattern> {
    vec![
        Pattern::new("files_modified_today")
            .keywords(&["files", "modified", "today"])
            .template("find . -type f -mtime 0")
            .priority(10),

        // Your new pattern:
        Pattern::new("files_by_size")
            .keywords(&["files", "larger", "bigger", "size"])
            .template("find . -type f -size +{size}{unit}")
            .priority(8)
            .extract_params(&["size", "unit"]),
    ]
}
```

---

### 3. Adding New Validation Rule

**File**: `src/prompts/validation.rs`

```rust
impl CommandValidator {
    pub fn new() -> Self {
        let dangerous_patterns = vec![
            Regex::new(r"rm\s+-rf\s+/").unwrap(),
            // Your new rule:
            Regex::new(r"dd\s+if=/dev/zero\s+of=/dev/sd").unwrap(),  // Disk wipe
        ];

        Self {
            dangerous_patterns,
            // ...
        }
    }
}
```

---

## Performance Characteristics

### Latency Breakdown

**Static Matcher** (best case):
```
Keyword extraction:     5ms
Pattern matching:      10ms
Template rendering:     5ms
Validation:            5ms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total:                25ms
```

**Embedded Backend** (typical):
```
Prompt building:       10ms
Model inference:     1500ms
JSON parsing:         10ms
Validation:            5ms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total:              1525ms
```

**With Repair** (worst case):
```
Initial generation:  1525ms
Validation (fail):      5ms
Repair generation:   1525ms
Validation (pass):      5ms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total:              3060ms
```

---

### Memory Usage

**Base Binary**: 42MB (release build)

**Runtime** (no model loaded):
```
Heap:     15MB
Stack:     2MB
Mapped:   10MB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total:    ~85MB RSS
```

**With Model Loaded** (SmolLM):
```
Base:      85MB
Model:    480MB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total:   ~565MB RSS
```

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2026-01-08 | Engineering Lead + Technical Architect | Initial technical architecture & system design |

---

**End of Document**

ğŸ—ï¸ **Technical Architecture Complete**

Comprehensive system design covering components, data flows, backend architecture, agent loop, storage, and key design decisions for v1.1.0-beta.
