# Applying the Ralph Playbook to Caro

This guide describes how to implement Geoffrey Huntley's Ralph methodology for autonomous AI-driven development in the caro project.

## Executive Summary

**Ralph** is a methodology for running autonomous AI coding loops. The core insight: "When 200K+ tokens = ~176K usable, tight tasks + one per loop = 100% efficient context utilization."

**Good news**: Caro already has ~70% of the Ralph infrastructure in place through Spec-Kitty, beta test cycles, and the skills architecture. This guide bridges the gap to full Ralph-style autonomous loops.

## What Caro Already Has

| Ralph Component | Caro Equivalent | Status |
|-----------------|-----------------|--------|
| `specs/` directory | `specs/`, `.specify/` | ✅ Complete |
| `AGENTS.md` | `.claude/AGENTS.md` | ✅ Complete |
| Implementation Plan | Spec-Kitty `tasks.md` | ✅ Complete |
| Build/test backpressure | `make check`, CI pipeline | ✅ Complete |
| Iterative test cycles | Beta test cycles 0-12 | ✅ Complete |
| Task decomposition | Spec-Kitty planning | ✅ Complete |
| Git automation | Pre-commit hooks | ✅ Complete |
| **Outer loop script** | Missing | ❌ Needed |
| **Mode-specific prompts** | Missing | ❌ Needed |

## The Gap: Autonomous Loop Infrastructure

### What We Need to Add

1. **`loop.sh`** - Outer loop orchestrator
2. **`PROMPT_plan.md`** - Planning mode instructions
3. **`PROMPT_build.md`** - Building mode instructions
4. **`IMPLEMENTATION_PLAN.md`** - Self-updating task list (distinct from Spec-Kitty tasks)

## Implementation Plan

### Phase 1: Create Loop Infrastructure

#### 1.1 Create the Outer Loop Script

```bash
#!/usr/bin/env bash
# loop.sh - Ralph outer loop for caro
#
# Usage:
#   ./loop.sh plan    # Planning mode - generate/update implementation plan
#   ./loop.sh build   # Building mode - implement tasks iteratively
#   ./loop.sh         # Default: building mode

set -euo pipefail

MODE="${1:-build}"
PROMPT_FILE="PROMPT_${MODE}.md"

if [[ ! -f "$PROMPT_FILE" ]]; then
    echo "Error: $PROMPT_FILE not found"
    exit 1
fi

echo "Starting Ralph loop in $MODE mode..."
echo "Press Ctrl+C to stop"
echo ""

# Infinite loop with fresh context each iteration
while true; do
    echo "=== Starting iteration $(date '+%Y-%m-%d %H:%M:%S') ==="

    # Feed prompt to Claude, let it run autonomously
    # Claude will:
    #   1. Study the codebase, specs, and plan
    #   2. Select the most important task
    #   3. Implement it with tests
    #   4. Update IMPLEMENTATION_PLAN.md
    #   5. Commit and exit

    claude --print "$PROMPT_FILE" || {
        echo "Claude exited with error, waiting 5s before retry..."
        sleep 5
    }

    echo "=== Iteration complete ==="
    echo ""

    # Brief pause to allow interrupt
    sleep 2
done
```

#### 1.2 Create Planning Mode Prompt

```markdown
# PROMPT_plan.md - Ralph Planning Mode for Caro

## 0a. Study the Project

Study these files to understand caro's architecture:
- `src/lib.rs` - Library entry point and module structure
- `Cargo.toml` - Dependencies and features
- `.specify/memory/constitution.md` - Project principles
- `ROADMAP.md` - Current priorities

## 0b. Study Specifications

Study all files in `specs/` and `.specify/specs/` to understand requirements.

## 0c. Study Current Implementation

Using parallel subagents, analyze the codebase to understand what is already implemented.
Don't assume features are not implemented - study the code first.

## 0d. Study Current Plan

Read `IMPLEMENTATION_PLAN.md` if it exists to understand current state.

## 1. Perform Gap Analysis

Compare specifications against implementation:
- What is fully implemented?
- What is partially implemented?
- What is missing entirely?
- What needs refactoring or improvement?

## 2. Generate Implementation Plan

Create/update `IMPLEMENTATION_PLAN.md` with prioritized tasks:

### Format

```markdown
# Caro Implementation Plan

Last updated: [timestamp]
Generated by: Ralph planning mode

## Priority 1: Critical (blocking other work)

- [ ] Task description
  - Spec: [reference to spec file]
  - Files: [files to modify]
  - Tests: [test requirements]

## Priority 2: High (feature completeness)

- [ ] ...

## Priority 3: Medium (improvements)

- [ ] ...

## Priority 4: Low (nice to have)

- [ ] ...

## Completed

- [x] Task (completed [date])
```

### Prioritization Criteria

1. **Critical**: Security issues, blocking bugs, failing tests
2. **High**: Core features from roadmap, user-facing improvements
3. **Medium**: Performance, code quality, documentation
4. **Low**: Nice-to-have, future considerations

## 3. Commit and Exit

After updating the plan:
1. Stage `IMPLEMENTATION_PLAN.md`
2. Commit with message: "chore: update implementation plan [planning mode]"
3. Exit cleanly

## 999. Guardrails

- Do NOT implement any tasks - only analyze and plan
- Do NOT modify source code
- Do NOT assume features are not implemented
- Keep plan entries actionable and specific
- Include test requirements for each task
- Reference relevant spec files
```

#### 1.3 Create Building Mode Prompt

```markdown
# PROMPT_build.md - Ralph Building Mode for Caro

## 0a. Study the Project

Study these files:
- `.claude/AGENTS.md` - Build/test commands, patterns, learnings
- `.specify/memory/constitution.md` - Project principles (TDD is NON-NEGOTIABLE)
- `Makefile` - Available commands

## 0b. Study Current Plan

Read `IMPLEMENTATION_PLAN.md` to understand available tasks.

## 0c. Study Relevant Code

Before selecting a task, study the files it will affect.
Don't assume features are not implemented - study first.

## 1. Select Most Important Task

From `IMPLEMENTATION_PLAN.md`, select ONE task:
- Prioritize Critical > High > Medium > Low
- Within same priority, select by impact
- Skip tasks with unmet dependencies

## 2. Implement with TDD

Follow caro's constitution - TDD is non-negotiable:

### 2a. Write Failing Test First (RED)
```bash
# Write test, verify it fails
make test-verbose
```

### 2b. Implement Minimum Code (GREEN)
```bash
# Write just enough code to pass
make test-verbose
```

### 2c. Refactor (REFACTOR)
```bash
# Clean up while keeping tests green
make check  # lint + fmt + test + audit
```

## 3. Validate Changes

Run full validation before committing:

```bash
make check
```

If any check fails, fix before proceeding.

## 4. Update Plan

Mark the completed task in `IMPLEMENTATION_PLAN.md`:
- Change `- [ ]` to `- [x]`
- Add completion date
- Move to Completed section if appropriate

## 5. Commit Changes

Create atomic commit:
```bash
git add -A
git commit -m "feat/fix/refactor: <description>

- Implemented: <what>
- Tests: <test file(s)>
- Plan task: <task reference>
"
```

## 6. Exit

Exit cleanly so the loop can restart with fresh context.

## 999. Guardrails (Higher = More Critical)

### 9990. Never Skip Tests
TDD is NON-NEGOTIABLE per constitution. Write tests FIRST.

### 9991. One Task Per Iteration
Complete ONE task fully, then exit. Don't batch.

### 9992. Don't Assume Not Implemented
Always study code before assuming something is missing.

### 9993. Validate Before Commit
`make check` must pass before any commit.

### 9994. Keep Plan Updated
Always update `IMPLEMENTATION_PLAN.md` after completing a task.

### 9995. Preserve Safety Patterns
Never modify safety patterns without running full regression:
```bash
cargo test --test safety_validator_contract
```
```

### Phase 2: Integration with Existing Infrastructure

#### 2.1 Update AGENTS.md

Add Ralph-specific guidance:

```markdown
## Ralph Loop Integration

### Running Ralph

# Planning mode - regenerate implementation plan
./loop.sh plan

# Building mode - implement tasks iteratively
./loop.sh build

### When to Regenerate Plan

- After major spec changes
- When plan becomes stale (>1 week without progress)
- When Ralph is spinning (same failures repeatedly)

### Backpressure Commands

# Full validation suite
make check

# Quick feedback
make test-verbose

# Contract tests only
make test-contract

# Safety regression check
cargo test --test safety_validator_contract
```

#### 2.2 Integrate with Spec-Kitty

Ralph can coexist with Spec-Kitty:

| Workflow | Use Case |
|----------|----------|
| Spec-Kitty | New features requiring detailed spec → plan → tasks flow |
| Ralph | Continuous improvement, bug fixes, backlog processing |

**Routing Logic**:
- New major feature? → Spec-Kitty `/specify` → `/plan` → `/tasks`
- Existing backlog? → Ralph `./loop.sh build`
- Architectural decisions? → Spec-Kitty planning
- Iterative improvements? → Ralph building

#### 2.3 Integrate with Beta Test Cycles

Ralph loops can incorporate beta test feedback:

```markdown
## Priority 1: Critical (Beta Feedback)

- [ ] Fix pattern matching for `find -name` with spaces
  - Source: Beta cycle 12, failure #3
  - Files: `src/safety/patterns/file_operations.rs`
  - Tests: `tests/beta_regression.rs`
```

### Phase 3: Advanced Enhancements

#### 3.1 Acceptance-Driven Backpressure

Enhance planning mode to generate acceptance tests:

```markdown
## Task: Implement --version flag

### Acceptance Criteria (generate tests for these)
- [ ] `caro --version` outputs version number
- [ ] `caro -V` outputs version number
- [ ] Version matches Cargo.toml

### Backpressure Tests
```rust
#[test]
fn test_version_flag_long() {
    let output = Command::new("caro").arg("--version").output();
    assert!(output.stdout.contains(env!("CARGO_PKG_VERSION")));
}
```
```

#### 3.2 LLM-as-Judge Backpressure

For subjective criteria (command quality, safety messaging):

```markdown
## Task: Improve error message clarity

### LLM Judge Criteria
- Message explains WHY command was blocked
- Message suggests safe alternative
- Tone is helpful, not condescending

### Judge Prompt
"Evaluate this error message for clarity and helpfulness.
Return PASS or FAIL with one-sentence reason."
```

#### 3.3 Work Branch Strategy

Create focused plans per feature branch:

```bash
# Create feature branch with scoped plan
git checkout -b feature/improved-safety-patterns
./loop.sh plan  # Generates IMPLEMENTATION_PLAN.md scoped to this feature

# Run building loop
./loop.sh build
```

## Operational Philosophy for Caro

### 1. Context is Everything

Caro's 52+ safety patterns and multi-backend architecture benefit from tight context:
- One pattern improvement per loop
- One backend enhancement per loop
- One test coverage gap per loop

### 2. Steering Through Backpressure

Caro's existing infrastructure provides strong backpressure:

| Layer | Mechanism |
|-------|-----------|
| Static | `make lint` (clippy with warnings = errors) |
| Dynamic | `make test` (contract tests, integration tests) |
| Safety | `cargo test --test safety_validator_contract` |
| Quality | Beta test harness (94.8% baseline) |

### 3. Let Ralph Ralph

Trust the loop to:
- Self-correct when tests fail
- Find optimal pattern ordering through iteration
- Improve test coverage organically
- Maintain code quality through backpressure

### 4. Move Outside the Loop

Your job as engineer:
- Observe early iterations for failure patterns
- Tune prompts reactively (add guardrails when needed)
- Update specs when requirements change
- Review commits periodically for quality

## Quick Start

```bash
# 1. Create initial implementation plan
./loop.sh plan

# 2. Review the generated plan
cat IMPLEMENTATION_PLAN.md

# 3. Start building loop
./loop.sh build

# 4. Monitor progress
tail -f ralph.log  # (if logging enabled)

# 5. Stop when satisfied
Ctrl+C
```

## Metrics & Monitoring

Track these metrics across Ralph sessions:

| Metric | Target | Measurement |
|--------|--------|-------------|
| Tasks completed per hour | 2-4 | Count commits |
| Test coverage | >80% | `cargo tarpaulin` |
| Beta pass rate | >95% | `/beta-test-cycles` |
| Build failures per session | <10% | Monitor loop |

## Troubleshooting

### Ralph Spinning (Same Failure Repeatedly)

1. Stop the loop
2. Regenerate plan: `./loop.sh plan`
3. Review and manually adjust `IMPLEMENTATION_PLAN.md`
4. Resume: `./loop.sh build`

### Tests Keep Failing

1. Run `make check` manually to see full output
2. Check if tests are flaky
3. Add more specific guardrails to `PROMPT_build.md`

### Plan Becomes Stale

1. Run planning mode: `./loop.sh plan`
2. Review against current roadmap
3. Remove completed/obsolete tasks

## Conclusion

The Ralph Playbook provides a framework for autonomous, iterative development that complements caro's existing Spec-Kitty infrastructure. By adding the outer loop script and mode-specific prompts, caro can benefit from:

- Continuous backlog processing
- Automated quality improvements
- Iterative pattern refinement
- Reduced context-switching overhead

Start with Phase 1, observe results, and iterate on the prompts based on what you learn. Remember: the plan is disposable, regeneration is cheap, and the goal is eventual consistency through iteration.
