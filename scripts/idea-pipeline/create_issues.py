#!/usr/bin/env python3
"""
Create GitHub Issues for Accepted Ideas

Creates GitHub issues for ideas that passed evaluation.
Includes labels, milestone assignment, and formatted body.

Usage:
    python create_issues.py --vetted vetted.json --repo owner/repo
"""

import argparse
import json
import os
import sys
from datetime import datetime

from github import Github
from pydantic import BaseModel


class IssueCreated(BaseModel):
    """Record of created issue."""
    idea_id: str
    issue_number: int
    issue_url: str
    title: str


ISSUE_TEMPLATE = """## Summary

{description}

## Why Now

{why_now}

## Implementation Hints

{implementation_hints}

## Metadata

| Field | Value |
|-------|-------|
| **Source** | Agentic Idea Pipeline |
| **Idea ID** | `{idea_id}` |
| **Category** | {category} |
| **Confidence** | {confidence:.0%} |
| **Relevance Score** | {relevance_score:.0%} |

## Agent Reasoning

> {reasoning}

## Source Signals

{source_signals}

---

*This issue was automatically generated by the [Agentic Idea Pipeline](../docs/adr/ADR-011-agentic-idea-pipeline.md). Human review is required before implementation.*
"""


def format_implementation_hints(hints: list[str]) -> str:
    """Format implementation hints as checklist."""
    if not hints:
        return "- [ ] TBD - needs analysis"
    return "\n".join(f"- [ ] {hint}" for hint in hints)


def format_source_signals(signals: list[str]) -> str:
    """Format source signals."""
    if not signals:
        return "*No specific signals recorded*"
    return "\n".join(f"- `{s}`" for s in signals[:10])


def get_labels_for_idea(idea: dict) -> list[str]:
    """Determine appropriate labels for the idea."""
    labels = ["idea-pipeline", "needs-triage"]

    category = idea.get("eval_category", "")
    if category == "quick-win":
        labels.append("quick-win")
    elif category == "strategic":
        labels.append("strategic")
    elif category == "research":
        labels.append("research")

    original_cat = idea.get("original_category", "")
    if original_cat == "feature":
        labels.append("enhancement")
    elif original_cat == "improvement":
        labels.append("improvement")
    elif original_cat == "integration":
        labels.append("integration")

    return labels


def create_issue_for_idea(gh: Github, repo_name: str, idea: dict, dry_run: bool = False) -> IssueCreated | None:
    """Create a GitHub issue for an accepted idea."""

    title = f"[Idea Pipeline] {idea.get('title', 'Untitled')}"

    body = ISSUE_TEMPLATE.format(
        description=idea.get("description", "No description"),
        why_now=idea.get("why_now", "No timing context"),
        implementation_hints=format_implementation_hints(idea.get("implementation_hints", [])),
        idea_id=idea.get("id", "unknown"),
        category=idea.get("eval_category", "unclassified"),
        confidence=idea.get("confidence", 0),
        relevance_score=idea.get("relevance_score", 0),
        reasoning=idea.get("reasoning", "No reasoning provided"),
        source_signals=format_source_signals(idea.get("source_signals", [])),
    )

    labels = get_labels_for_idea(idea)

    if dry_run:
        print(f"[DRY RUN] Would create issue: {title}")
        print(f"  Labels: {labels}")
        return None

    try:
        repo = gh.get_repo(repo_name)

        # Check if issue already exists (by idea ID in title)
        existing = repo.get_issues(state="all")
        for issue in existing:
            if idea.get("id", "unknown") in issue.title:
                print(f"Issue already exists for {idea.get('id')}: #{issue.number}")
                return IssueCreated(
                    idea_id=idea.get("id", "unknown"),
                    issue_number=issue.number,
                    issue_url=issue.html_url,
                    title=issue.title,
                )

        # Create the issue
        issue = repo.create_issue(
            title=title,
            body=body,
            labels=labels,
        )

        print(f"Created issue #{issue.number}: {title}")

        return IssueCreated(
            idea_id=idea.get("id", "unknown"),
            issue_number=issue.number,
            issue_url=issue.html_url,
            title=title,
        )

    except Exception as e:
        print(f"Error creating issue for {idea.get('id')}: {e}", file=sys.stderr)
        return None


def main():
    parser = argparse.ArgumentParser(description="Create GitHub issues for accepted ideas")
    parser.add_argument("--vetted", type=str, required=True, help="Path to vetted ideas JSON")
    parser.add_argument("--repo", type=str, required=True, help="GitHub repo (owner/name)")
    parser.add_argument("--dry-run", action="store_true", help="Don't actually create issues")
    args = parser.parse_args()

    # Check for GitHub token
    token = os.environ.get("GITHUB_TOKEN")
    if not token and not args.dry_run:
        print("Error: GITHUB_TOKEN environment variable required", file=sys.stderr)
        sys.exit(1)

    # Load vetted ideas
    with open(args.vetted) as f:
        vetted_data = json.load(f)

    ideas = vetted_data.get("ideas", [])

    # Filter to accepted ideas only
    accepted = [i for i in ideas if i.get("decision") == "ACCEPT"]

    if not accepted:
        print("No accepted ideas to create issues for")
        return

    print(f"Creating issues for {len(accepted)} accepted ideas...")

    # Initialize GitHub client
    gh = Github(token) if token else None

    created = []
    for idea in accepted:
        result = create_issue_for_idea(gh, args.repo, idea, args.dry_run)
        if result:
            created.append(result)

    # Summary
    print(f"\n{'[DRY RUN] ' if args.dry_run else ''}Created {len(created)} issues")

    if created and not args.dry_run:
        print("\nIssue URLs:")
        for c in created:
            print(f"  - #{c.issue_number}: {c.issue_url}")


if __name__ == "__main__":
    main()
