//! Core data models for the LLM Evaluation Harness
//!
//! This module defines all entities used throughout the evaluation system:
//! - Test cases and categories
//! - Evaluation results and benchmarks
//! - Backend profiles and configurations
//! - Baseline comparison and regression detection

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Test category enumeration
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TestCategory {
    /// Validates functional accuracy of generated commands
    Correctness,
    /// Validates that dangerous commands are properly blocked
    Safety,
    /// Validates POSIX compliance and shell portability
    #[serde(rename = "posix")]
    POSIX,
    /// Validates consistency across different inference backends
    MultiBackend,
}

/// Validation rule for test case evaluation
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ValidationRule {
    /// Generated command must exactly match expected_command
    ExactMatch,
    /// Generated command is functionally equivalent
    CommandEquivalence,
    /// Generated command matches validation_pattern regex
    PatternMatch,
    /// Command must be blocked by safety validation
    MustBeBlocked,
    /// Command must not be blocked
    MustExecute,
}

/// Test difficulty level
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Difficulty {
    /// Straightforward commands with clear expected output
    Easy,
    /// Requires understanding of options/flags
    Medium,
    /// Complex multi-step commands or edge cases
    Hard,
}

/// Backend evaluation priority level
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum EvaluationPriority {
    /// Run all tests (100% sampling rate)
    Deep,
    /// Run representative sample (~25% sampling rate)
    Basic,
    /// Run only critical tests (~10% sampling rate)
    Minimal,
}

/// Error type categorization for test failures
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ErrorType {
    /// Backend failed to generate command
    GenerationFailure,
    /// Backend exceeded timeout threshold
    Timeout,
    /// Generated command failed validation rules
    ValidationFailure,
    /// Dangerous command not blocked
    SafetyViolation,
    /// Command doesn't match expected output
    IncorrectOutput,
    /// Non-POSIX compliant shell syntax
    #[serde(rename = "posix_violation")]
    POSIXViolation,
    /// Different backends produced inconsistent results
    BackendInconsistency,
}

/// Single labeled evaluation test case
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCase {
    /// Unique identifier (e.g., "safety-001")
    pub id: String,

    /// Test category
    pub category: TestCategory,

    /// Natural language command description
    pub input_request: String,

    /// Expected shell command output (required for correctness/posix tests)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_command: Option<String>,

    /// Expected behavior (e.g., "blocked", "executed")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_behavior: Option<String>,

    /// How to validate result
    pub validation_rule: ValidationRule,

    /// Regex pattern for pattern validation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validation_pattern: Option<String>,

    /// Metadata tags
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub tags: Vec<String>,

    /// Test difficulty
    #[serde(skip_serializing_if = "Option::is_none")]
    pub difficulty: Option<Difficulty>,

    /// Origin (e.g., "beta-testing", "manual")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,

    /// Additional context or documentation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notes: Option<String>,
}

/// Outcome of running one test case on one backend
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvaluationResult {
    /// Reference to TestCase.id
    pub test_id: String,

    /// Backend that generated the command
    pub backend_name: String,

    /// Whether test passed validation
    pub passed: bool,

    /// Command generated by backend
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actual_command: Option<String>,

    /// Observed behavior (e.g., "blocked", "executed")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actual_behavior: Option<String>,

    /// Why test failed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub failure_reason: Option<String>,

    /// Time taken to generate command (milliseconds)
    pub execution_time_ms: u64,

    /// When evaluation occurred
    pub timestamp: DateTime<Utc>,

    /// Category of failure if applicable
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_type: Option<ErrorType>,
}

/// Configuration for a specific inference backend
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BackendProfile {
    /// Backend identifier (e.g., "mlx", "static_matcher")
    pub name: String,

    /// Human-readable name (e.g., "MLX (Apple Silicon)")
    pub display_name: String,

    /// Whether backend is enabled for evaluation
    pub enabled: bool,

    /// Max time per command generation (milliseconds)
    pub timeout_ms: u64,

    /// Platform requirements (e.g., "macos", "cuda")
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub required_features: Vec<String>,

    /// Deep testing vs basic coverage
    pub evaluation_priority: EvaluationPriority,

    /// Fraction of tests to run (0.0-1.0)
    #[serde(default = "default_sampling_rate")]
    pub test_sampling_rate: f32,
}

fn default_sampling_rate() -> f32 {
    1.0
}

/// Aggregated results for a single test category
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CategoryResult {
    /// Which category these results are for
    pub category: TestCategory,

    /// Percentage passed for this category (0.0-1.0)
    pub pass_rate: f32,

    /// Tests in this category
    pub total_tests: usize,

    /// Tests passed
    pub passed: usize,

    /// Tests failed
    pub failed: usize,

    /// Average time per test (milliseconds)
    pub avg_execution_time_ms: u64,
}

/// Aggregated results for a single backend
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BackendResult {
    /// Backend identifier
    pub backend_name: String,

    /// Percentage passed for this backend (0.0-1.0)
    pub pass_rate: f32,

    /// Tests run on this backend
    pub total_tests: usize,

    /// Tests passed
    pub passed: usize,

    /// Tests failed
    pub failed: usize,

    /// Tests that timed out
    pub timeouts: usize,

    /// Average time per test (milliseconds)
    pub avg_execution_time_ms: u64,

    /// Pass rate per category for this backend
    pub category_breakdown: HashMap<TestCategory, f32>,
}

/// Aggregated results from a complete evaluation run
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BenchmarkReport {
    /// Unique identifier for this run (ISO 8601 timestamp)
    pub run_id: String,

    /// When evaluation started
    pub timestamp: DateTime<Utc>,

    /// Git branch evaluated
    pub branch: String,

    /// Git commit hash
    pub commit_sha: String,

    /// Percentage of all tests passed (0.0-1.0)
    pub overall_pass_rate: f32,

    /// Total number of tests executed
    pub total_tests: usize,

    /// Number of tests passed
    pub total_passed: usize,

    /// Number of tests failed
    pub total_failed: usize,

    /// Per-category aggregated results
    pub category_results: HashMap<TestCategory, CategoryResult>,

    /// Per-backend aggregated results
    pub backend_results: HashMap<String, BackendResult>,

    /// Total evaluation runtime (milliseconds)
    pub execution_time_ms: u64,

    /// Whether pass rate dropped vs baseline
    pub regression_detected: bool,

    /// Delta from previous run
    #[serde(skip_serializing_if = "Option::is_none")]
    pub baseline_comparison: Option<BaselineDelta>,
}

/// Comparison between current run and stored baseline
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BaselineDelta {
    /// Reference to baseline run
    pub baseline_run_id: String,

    /// Baseline git commit
    pub baseline_commit_sha: String,

    /// Change in overall pass rate
    pub overall_delta: f32,

    /// Change per category
    pub category_deltas: HashMap<TestCategory, f32>,

    /// Change per backend
    pub backend_deltas: HashMap<String, f32>,

    /// Threshold for regression detection (e.g., 0.05)
    pub regression_threshold: f32,

    /// Categories/backends with significant drops
    pub significant_regressions: Vec<String>,
}

impl TestCase {
    /// Validates the test case structure
    pub fn validate(&self) -> Result<(), String> {
        // ID format validation
        if !self.id.contains('-') {
            return Err(format!(
                "Test ID '{}' must follow format {{category}}-{{number}}",
                self.id
            ));
        }

        // Input request validation
        if self.input_request.is_empty() {
            return Err(format!("Test {} has empty input_request", self.id));
        }
        if self.input_request.len() > 500 {
            return Err(format!("Test {} input_request exceeds 500 chars", self.id));
        }

        // Validation rule requirements
        match self.validation_rule {
            ValidationRule::PatternMatch => {
                if self.validation_pattern.is_none() {
                    return Err(format!(
                        "Test {} requires validation_pattern for PatternMatch rule",
                        self.id
                    ));
                }
            }
            ValidationRule::MustBeBlocked => {
                if self.expected_behavior.as_deref() != Some("blocked") {
                    return Err(format!(
                        "Test {} should have expected_behavior='blocked' for MustBeBlocked rule",
                        self.id
                    ));
                }
            }
            ValidationRule::ExactMatch | ValidationRule::CommandEquivalence => {
                if matches!(
                    self.category,
                    TestCategory::Correctness | TestCategory::POSIX
                ) && self.expected_command.is_none()
                {
                    return Err(format!(
                        "Test {} requires expected_command for {:?} category",
                        self.id, self.category
                    ));
                }
            }
            _ => {}
        }

        // Tag validation
        if self.tags.len() > 10 {
            return Err(format!("Test {} has more than 10 tags", self.id));
        }
        for tag in &self.tags {
            if tag.len() > 50 {
                return Err(format!(
                    "Test {} has tag exceeding 50 chars: {}",
                    self.id, tag
                ));
            }
        }

        Ok(())
    }
}

impl BackendProfile {
    /// Validates the backend profile configuration
    pub fn validate(&self) -> Result<(), String> {
        if self.name.is_empty() {
            return Err("Backend name cannot be empty".to_string());
        }

        if self.timeout_ms == 0 || self.timeout_ms > 30000 {
            return Err(format!(
                "Backend {} timeout must be between 1-30000ms",
                self.name
            ));
        }

        if !(0.0..=1.0).contains(&self.test_sampling_rate) {
            return Err(format!(
                "Backend {} sampling rate must be 0.0-1.0",
                self.name
            ));
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_test_category_serde() {
        let categories = vec![
            (TestCategory::Correctness, "\"correctness\""),
            (TestCategory::Safety, "\"safety\""),
            (TestCategory::POSIX, "\"posix\""),
            (TestCategory::MultiBackend, "\"multi_backend\""),
        ];

        for (category, expected_json) in categories {
            let json = serde_json::to_string(&category).unwrap();
            assert_eq!(json, expected_json);

            let deserialized: TestCategory = serde_json::from_str(&json).unwrap();
            assert_eq!(deserialized, category);
        }
    }

    #[test]
    fn test_validation_rule_serde() {
        let rules = vec![
            (ValidationRule::ExactMatch, "\"exact_match\""),
            (
                ValidationRule::CommandEquivalence,
                "\"command_equivalence\"",
            ),
            (ValidationRule::PatternMatch, "\"pattern_match\""),
            (ValidationRule::MustBeBlocked, "\"must_be_blocked\""),
            (ValidationRule::MustExecute, "\"must_execute\""),
        ];

        for (rule, expected_json) in rules {
            let json = serde_json::to_string(&rule).unwrap();
            assert_eq!(json, expected_json);

            let deserialized: ValidationRule = serde_json::from_str(&json).unwrap();
            assert_eq!(deserialized, rule);
        }
    }

    #[test]
    fn test_difficulty_serde() {
        let difficulties = vec![
            (Difficulty::Easy, "\"easy\""),
            (Difficulty::Medium, "\"medium\""),
            (Difficulty::Hard, "\"hard\""),
        ];

        for (diff, expected_json) in difficulties {
            let json = serde_json::to_string(&diff).unwrap();
            assert_eq!(json, expected_json);

            let deserialized: Difficulty = serde_json::from_str(&json).unwrap();
            assert_eq!(deserialized, diff);
        }
    }

    #[test]
    fn test_evaluation_priority_serde() {
        let priorities = vec![
            (EvaluationPriority::Deep, "\"deep\""),
            (EvaluationPriority::Basic, "\"basic\""),
            (EvaluationPriority::Minimal, "\"minimal\""),
        ];

        for (priority, expected_json) in priorities {
            let json = serde_json::to_string(&priority).unwrap();
            assert_eq!(json, expected_json);

            let deserialized: EvaluationPriority = serde_json::from_str(&json).unwrap();
            assert_eq!(deserialized, priority);
        }
    }

    #[test]
    fn test_error_type_serde() {
        let error_types = vec![
            (ErrorType::GenerationFailure, "\"generation_failure\""),
            (ErrorType::Timeout, "\"timeout\""),
            (ErrorType::ValidationFailure, "\"validation_failure\""),
            (ErrorType::SafetyViolation, "\"safety_violation\""),
            (ErrorType::IncorrectOutput, "\"incorrect_output\""),
            (ErrorType::POSIXViolation, "\"posix_violation\""),
            (ErrorType::BackendInconsistency, "\"backend_inconsistency\""),
        ];

        for (error_type, expected_json) in error_types {
            let json = serde_json::to_string(&error_type).unwrap();
            assert_eq!(json, expected_json);

            let deserialized: ErrorType = serde_json::from_str(&json).unwrap();
            assert_eq!(deserialized, error_type);
        }
    }

    #[test]
    fn test_test_case_full_serialization() {
        let test_case = TestCase {
            id: "correctness-001".to_string(),
            category: TestCategory::Correctness,
            input_request: "list all files".to_string(),
            expected_command: Some("ls -la".to_string()),
            expected_behavior: None,
            validation_rule: ValidationRule::ExactMatch,
            validation_pattern: None,
            tags: vec!["common".to_string()],
            difficulty: Some(Difficulty::Easy),
            source: Some("manual".to_string()),
            notes: None,
        };

        // Serialize to JSON
        let json = serde_json::to_string(&test_case).unwrap();

        // Deserialize back
        let deserialized: TestCase = serde_json::from_str(&json).unwrap();

        // Verify fields match
        assert_eq!(deserialized.id, test_case.id);
        assert_eq!(deserialized.category, test_case.category);
        assert_eq!(deserialized.input_request, test_case.input_request);
        assert_eq!(deserialized.validation_rule, test_case.validation_rule);
    }

    #[test]
    fn test_case_validation_passes() {
        let test_case = TestCase {
            id: "correctness-001".to_string(),
            category: TestCategory::Correctness,
            input_request: "list all files".to_string(),
            expected_command: Some("ls -la".to_string()),
            expected_behavior: None,
            validation_rule: ValidationRule::ExactMatch,
            validation_pattern: None,
            tags: vec!["common".to_string()],
            difficulty: Some(Difficulty::Easy),
            source: Some("manual".to_string()),
            notes: None,
        };

        assert!(test_case.validate().is_ok());
    }

    #[test]
    fn test_case_validation_fails_empty_input() {
        let test_case = TestCase {
            id: "test-001".to_string(),
            category: TestCategory::Correctness,
            input_request: "".to_string(),
            expected_command: None,
            expected_behavior: None,
            validation_rule: ValidationRule::ExactMatch,
            validation_pattern: None,
            tags: vec![],
            difficulty: None,
            source: None,
            notes: None,
        };

        assert!(test_case.validate().is_err());
    }

    #[test]
    fn test_backend_profile_validation() {
        let profile = BackendProfile {
            name: "mlx".to_string(),
            display_name: "MLX".to_string(),
            enabled: true,
            timeout_ms: 10000,
            required_features: vec!["macos".to_string()],
            evaluation_priority: EvaluationPriority::Deep,
            test_sampling_rate: 1.0,
        };

        assert!(profile.validate().is_ok());
    }
}
