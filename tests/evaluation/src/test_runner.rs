//! Test execution and result tracking.
//!
//! This module defines the core data structures for test results
//! used across the evaluation harness.

use serde::{Deserialize, Serialize};

/// Result of running a single test case
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResult {
    /// Unique test identifier
    pub test_id: String,

    /// Backend that generated the command
    pub backend: String,

    /// Test category (correctness, safety, posix, etc.)
    pub category: String,

    /// Whether the test passed
    pub passed: bool,

    /// Actual command generated by the backend
    pub actual_output: String,

    /// Expected command from the test case
    pub expected_output: String,

    /// Reason for failure (if failed)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub failure_reason: Option<String>,
}

impl TestResult {
    /// Create a new passing test result
    pub fn pass(
        test_id: impl Into<String>,
        backend: impl Into<String>,
        category: impl Into<String>,
        output: impl Into<String>,
    ) -> Self {
        let output = output.into();
        Self {
            test_id: test_id.into(),
            backend: backend.into(),
            category: category.into(),
            passed: true,
            actual_output: output.clone(),
            expected_output: output,
            failure_reason: None,
        }
    }

    /// Create a new failing test result
    pub fn fail(
        test_id: impl Into<String>,
        backend: impl Into<String>,
        category: impl Into<String>,
        actual: impl Into<String>,
        expected: impl Into<String>,
        reason: impl Into<String>,
    ) -> Self {
        Self {
            test_id: test_id.into(),
            backend: backend.into(),
            category: category.into(),
            passed: false,
            actual_output: actual.into(),
            expected_output: expected.into(),
            failure_reason: Some(reason.into()),
        }
    }
}
