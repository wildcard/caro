{
  "version": "2.0.0",
  "generated": "2026-01-01T09:24:20.296Z",
  "totalPages": 26,
  "pages": [
    {
      "title": "Ai Agent Safety",
      "path": "/ai-agent-safety",
      "description": "",
      "category": "main",
      "keywords": [
        "agent",
        "safety",
        "caro",
        "hallucination",
        "resistant",
        "command",
        "validation"
      ],
      "icon": "üõ°Ô∏è",
      "content": {
        "headings": [],
        "paragraphs": [],
        "listItems": []
      },
      "fullText": "",
      "_searchText": "ai agent safety  /ai-agent-safety agent safety caro hallucination resistant command validation ",
      "_words": [
        "agent",
        "safety",
        "caro",
        "hallucination",
        "resistant",
        "command",
        "validation"
      ]
    },
    {
      "title": "Ai Command Safety",
      "path": "/ai-command-safety",
      "description": "",
      "category": "main",
      "keywords": [
        "command",
        "safety",
        "caro",
        "hallucination",
        "resistant",
        "shell",
        "validation"
      ],
      "icon": "üõ°Ô∏è",
      "content": {
        "headings": [],
        "paragraphs": [],
        "listItems": []
      },
      "fullText": "",
      "_searchText": "ai command safety  /ai-command-safety command safety caro hallucination resistant shell validation ",
      "_words": [
        "command",
        "safety",
        "caro",
        "hallucination",
        "resistant",
        "shell",
        "validation"
      ]
    },
    {
      "title": "Announcing Caro",
      "path": "/blog/announcing-caro",
      "description": "We're excited to announce that cmdai has been renamed to caro ! üéâ",
      "category": "blog",
      "keywords": [
        "caro",
        "command",
        "name",
        "github",
        "shell",
        "safety",
        "first",
        "your",
        "aeplay",
        "our",
        "project",
        "mlx",
        "platform",
        "crates",
        "terminal",
        "migration",
        "better",
        "single",
        "binary",
        "rust",
        "commands",
        "apple",
        "silicon",
        "multiple",
        "cpu",
        "history",
        "issues",
        "discussions",
        "new",
        "quick",
        "cmdai",
        "community",
        "generosity",
        "graciously",
        "crate",
        "friendly",
        "approachable",
        "cli",
        "tool",
        "natural",
        "local",
        "built",
        "optimized",
        "complex",
        "experience",
        "execution",
        "see",
        "memorable",
        "future",
        "open"
      ],
      "icon": "üìù",
      "content": {
        "headings": [
          "A New Name, The Same Mission",
          "What is Caro?",
          "Why \"Caro\"?",
          "Key Features",
          "Getting Started",
          "Quick Installation",
          "First Command",
          "What's New in v0.1.0",
          "Migration from cmdai",
          "Thank You, @aeplay",
          "What's Next",
          "Join the Community",
          "Try It Today"
        ],
        "paragraphs": [
          "We're excited to announce that cmdai has been renamed to caro ! üéâ",
          "Thanks to the incredible generosity of @aeplay , who graciously transferred the crate name to our project, we now have a name that better reflects our vision: a friendly, approachable AI companion for your terminal.",
          "caro is a single-binary Rust CLI tool that converts natural language descriptions into safe POSIX shell commands using local LLMs. Built with safety-first design and optimized for Apple Silicon via the MLX framework, caro makes complex command-line operations accessible to everyone.",
          "Why \"Caro\"? The name caro offers several advantages:",
          "In Latin, caro means \"dear\" or \"beloved\"‚Äîfitting for a tool designed to make your terminal experience more friendly and approachable. And for those who know Kyaro's story , the connection runs even deeper.",
          "First Command caro will generate the appropriate command for your platform, validate it for safety, and ask for confirmation before execution.",
          "If you previously installed , migration is simple:",
          "For detailed migration instructions, see our Naming History documentation.",
          "We want to extend our heartfelt gratitude to @aeplay for:",
          "This generosity has enabled us to have a better, more memorable name that will serve the project well as it grows.",
          "We have exciting plans for caro's future:",
          "Ready to supercharge your terminal experience?",
          "We can't wait to see what you build with caro!",
          "Built with Rust | Safety First | Open Source"
        ],
        "listItems": [
          "Brevity : Shorter and easier to type (4 characters)",
          "Memorability : More distinctive and memorable as a brand",
          "Pronounceability : Natural pronunciation in multiple languages",
          "Brandability : Better suited for a product name",
          "üöÄ Fast startup - Single binary with quick initialization",
          "üß† Local LLM inference - Embedded models optimized for Apple Silicon (MLX) and CPU",
          "ü§ñ Intelligent refinement - 2-iteration agentic loop for platform-specific commands",
          "üåç Platform-aware - Automatically detects OS, architecture, shell, and available commands",
          "üõ°Ô∏è Safety-first - Comprehensive validation with 52+ dangerous command patterns",
          "üì¶ Self-contained - Single binary distribution",
          "üéØ Multiple backends - Extensible system supporting MLX, CPU, vLLM, and Ollama",
          "‚úÖ Core CLI with comprehensive argument parsing",
          "‚úÖ Embedded model backend with MLX (Apple Silicon) and CPU variants",
          "‚úÖ Agentic context loop with iterative refinement",
          "‚úÖ Platform-aware command generation",
          "‚úÖ Safety validation with 52+ dangerous command patterns",
          "‚úÖ Remote backend support (Ollama, vLLM)",
          "‚úÖ Interactive execution with shell detection",
          "‚úÖ Multiple output formats (JSON, YAML, Plain)",
          "Graciously transferring the crate name to this project",
          "Believing in the project's future and potential",
          "Supporting the open-source Rust community",
          "üìä Enhanced analytics - Command history and usage insights",
          "üîÑ Multi-step workflows - Complex task automation",
          "üéì Learning from feedback - Adaptive command generation",
          "üîå Plugin system - Custom backends and validators",
          "üì± Shell integration - Direct shell plugins for zsh, bash, fish",
          "üåê Website : caro.sh",
          "üíª GitHub : github.com/wildcard/caro",
          "üì¶ Crates.io : crates.io/crates/caro"
        ]
      },
      "fullText": "We're excited to announce that cmdai has been renamed to caro ! üéâ A New Name, The Same Mission Thanks to the incredible generosity of @aeplay , who graciously transferred the crate name to our project, we now have a name that better reflects our vision: a friendly, approachable AI companion for your terminal. What is Caro? caro is a single-binary Rust CLI tool that converts natural language descriptions into safe POSIX shell commands using local LLMs. Built with safety-first design and optimized for Apple Silicon via the MLX framework, caro makes complex command-line operations accessible to everyone. Why \"Caro\"? The name caro offers several advantages: Brevity : Shorter and easier to type (4 characters) Memorability : More distinctive and memorable as a brand Pronounceability : Natural pronunciation in multiple languages Brandability : Better suited for a product name In Latin, caro means \"dear\" or \"beloved\"‚Äîfitting for a tool designed to make your terminal experience more friendly and approachable. And for those who know Kyaro's story , the connection runs even deeper. Key Features üöÄ Fast startup - Single binary with quick initialization üß† Local LLM inference - Embedded models optimized for Apple Silicon (MLX) and CPU ü§ñ Intelligent refinement - 2-iteration agentic loop for platform-specific commands üåç Platform-aware - Automatically detects OS, architecture, shell, and available commands üõ°Ô∏è Safety-first - Comprehensive validation with 52+ dangerous command patterns üì¶ Self-contained - Single binary distribution üéØ Multiple backends - Extensible system supporting MLX, CPU, vLLM, and Ollama Getting Started Quick Installation First Command caro will generate the appropriate command for your platform, validate it for safety, and ask for confirmation before execution. What's New in v0.1.0 ‚úÖ Core CLI with comprehensive argument parsing ‚úÖ Embedded model backend with MLX (Apple Silicon) and CPU variants ‚úÖ Agentic context loop with iterative refinement ‚úÖ Platform-aware command generation ‚úÖ Safety validation with 52+ dangerous command patterns ‚úÖ Remote backend support (Ollama, vLLM) ‚úÖ Interactive execution with shell detection ‚úÖ Multiple output formats (JSON, YAML, Plain) Migration from cmdai If you previously installed , migration is simple: For detailed migration instructions, see our Naming History documentation. Thank You, @aeplay We want to extend our heartfelt gratitude to @aeplay for: Graciously transferring the crate name to this project Believing in the project's future and potential Supporting the open-source Rust community This generosity has enabled us to have a better, more memorable name that will serve the project well as it grows. What's Next We have exciting plans for caro's future: üìä Enhanced analytics - Command history and usage insights üîÑ Multi-step workflows - Complex task automation üéì Learning from feedback - Adaptive command generation üîå Plugin system - Custom backends and validators üì± Shell integration - Direct shell plugins for zsh, bash, fish Join the Community üåê Website : caro.sh üíª GitHub : github.com/wildcard/caro üì¶ Crates.io : crates.io/crates/caro üêõ Issues : GitHub Issues üí¨ Discussions : GitHub Discussions Try It Today Ready to supercharge your terminal experience? We can't wait to see what you build with caro! Built with Rust | Safety First | Open Source",
      "_searchText": "announcing caro we're excited to announce that cmdai has been renamed to caro ! üéâ /blog/announcing-caro caro command name github shell safety first your aeplay our project mlx platform crates terminal migration better single binary rust commands apple silicon multiple cpu history issues discussions new quick cmdai community generosity graciously crate friendly approachable cli tool natural local built optimized complex experience execution see memorable future open a new name, the same mission what is caro? why \"caro\"? key features getting started quick installation first command what's new in v0.1.0 migration from cmdai thank you, @aeplay what's next join the community try it today we're excited to announce that cmdai has been renamed to caro ! üéâ thanks to the incredible generosity of @aeplay , who graciously transferred the crate name to our project, we now have a name that better reflects our vision: a friendly, approachable ai companion for your terminal. caro is a single-binary rust cli tool that converts natural language descriptions into safe posix shell commands using local llms. built with safety-first design and optimized for apple silicon via the mlx framework, caro makes complex command-line operations accessible to everyone. why \"caro\"? the name caro offers several advantages: in latin, caro means \"dear\" or \"beloved\"‚Äîfitting for a tool designed to make your terminal experience more friendly and approachable. and for those who know kyaro's story , the connection runs even deeper. first command caro will generate the appropriate command for your platform, validate it for safety, and ask for confirmation before execution. if you previously installed , migration is simple: for detailed migration instructions, see our naming history documentation. we want to extend our heartfelt gratitude to @aeplay for: this generosity has enabled us to have a better, more memorable name that will serve the project well as it grows. we have exciting plans for caro's future: ready to supercharge your terminal experience? we can't wait to see what you build with caro! built with rust | safety first | open source brevity : shorter and easier to type (4 characters) memorability : more distinctive and memorable as a brand pronounceability : natural pronunciation in multiple languages brandability : better suited for a product name üöÄ fast startup - single binary with quick initialization üß† local llm inference - embedded models optimized for apple silicon (mlx) and cpu ü§ñ intelligent refinement - 2-iteration agentic loop for platform-specific commands üåç platform-aware - automatically detects os, architecture, shell, and available commands üõ°Ô∏è safety-first - comprehensive validation with 52+ dangerous command patterns üì¶ self-contained - single binary distribution üéØ multiple backends - extensible system supporting mlx, cpu, vllm, and ollama ‚úÖ core cli with comprehensive argument parsing ‚úÖ embedded model backend with mlx (apple silicon) and cpu variants ‚úÖ agentic context loop with iterative refinement ‚úÖ platform-aware command generation ‚úÖ safety validation with 52+ dangerous command patterns ‚úÖ remote backend support (ollama, vllm) ‚úÖ interactive execution with shell detection ‚úÖ multiple output formats (json, yaml, plain) graciously transferring the crate name to this project believing in the project's future and potential supporting the open-source rust community üìä enhanced analytics - command history and usage insights üîÑ multi-step workflows - complex task automation üéì learning from feedback - adaptive command generation üîå plugin system - custom backends and validators üì± shell integration - direct shell plugins for zsh, bash, fish üåê website : caro.sh üíª github : github.com/wildcard/caro üì¶ crates.io : crates.io/crates/caro we're excited to announce that cmdai has been renamed to caro ! üéâ a new name, the same mission thanks to the incredible generosity of @aeplay , who graciously transferred the crate name to our project, we now have a name that better reflects our vision: a friendly, approachable ai companion for your terminal. what is caro? caro is a single-binary rust cli tool that converts natural language descriptions into safe posix shell commands using local llms. built with safety-first design and optimized for apple silicon via the mlx framework, caro makes complex command-line operations accessible to everyone. why \"caro\"? the name caro offers several advantages: brevity : shorter and easier to type (4 characters) memorability : more distinctive and memorable as a brand pronounceability : natural pronunciation in multiple languages brandability : better suited for a product name in latin, caro means \"dear\" or \"beloved\"‚Äîfitting for a tool designed to make your terminal experience more friendly and approachable. and for those who know kyaro's story , the connection runs even deeper. key features üöÄ fast startup - single binary with quick initialization üß† local llm inference - embedded models optimized for apple silicon (mlx) and cpu ü§ñ intelligent refinement - 2-iteration agentic loop for platform-specific commands üåç platform-aware - automatically detects os, architecture, shell, and available commands üõ°Ô∏è safety-first - comprehensive validation with 52+ dangerous command patterns üì¶ self-contained - single binary distribution üéØ multiple backends - extensible system supporting mlx, cpu, vllm, and ollama getting started quick installation first command caro will generate the appropriate command for your platform, validate it for safety, and ask for confirmation before execution. what's new in v0.1.0 ‚úÖ core cli with comprehensive argument parsing ‚úÖ embedded model backend with mlx (apple silicon) and cpu variants ‚úÖ agentic context loop with iterative refinement ‚úÖ platform-aware command generation ‚úÖ safety validation with 52+ dangerous command patterns ‚úÖ remote backend support (ollama, vllm) ‚úÖ interactive execution with shell detection ‚úÖ multiple output formats (json, yaml, plain) migration from cmdai if you previously installed , migration is simple: for detailed migration instructions, see our naming history documentation. thank you, @aeplay we want to extend our heartfelt gratitude to @aeplay for: graciously transferring the crate name to this project believing in the project's future and potential supporting the open-source rust community this generosity has enabled us to have a better, more memorable name that will serve the project well as it grows. what's next we have exciting plans for caro's future: üìä enhanced analytics - command history and usage insights üîÑ multi-step workflows - complex task automation üéì learning from feedback - adaptive command generation üîå plugin system - custom backends and validators üì± shell integration - direct shell plugins for zsh, bash, fish join the community üåê website : caro.sh üíª github : github.com/wildcard/caro üì¶ crates.io : crates.io/crates/caro üêõ issues : github issues üí¨ discussions : github discussions try it today ready to supercharge your terminal experience? we can't wait to see what you build with caro! built with rust | safety first | open source",
      "_words": [
        "caro",
        "command",
        "name",
        "shell",
        "safety",
        "first",
        "cmdai",
        "github",
        "your",
        "aeplay",
        "our",
        "project",
        "mlx",
        "platform",
        "migration",
        "new",
        "crates",
        "terminal",
        "better",
        "single",
        "binary",
        "rust",
        "commands",
        "apple",
        "silicon",
        "multiple",
        "cpu",
        "quick",
        "community",
        "history",
        "issues",
        "discussions",
        "generosity",
        "graciously",
        "crate",
        "friendly",
        "approachable",
        "cli",
        "tool",
        "natural",
        "local",
        "built",
        "optimized",
        "complex",
        "experience",
        "execution",
        "see",
        "memorable",
        "future",
        "open",
        "excited",
        "announce",
        "renamed",
        "mission",
        "key",
        "features",
        "getting",
        "started",
        "installation",
        "thank",
        "next",
        "join",
        "try",
        "today",
        "embedded",
        "refinement",
        "agentic",
        "loop",
        "aware",
        "comprehensive",
        "validation",
        "dangerous",
        "patterns",
        "backends",
        "system",
        "supporting",
        "vllm",
        "ollama",
        "backend",
        "generation",
        "source",
        "announcing",
        "thanks",
        "incredible",
        "transferred",
        "reflects",
        "vision",
        "companion",
        "converts",
        "language",
        "descriptions",
        "into",
        "safe",
        "posix",
        "using",
        "llms",
        "design",
        "via",
        "framework",
        "makes"
      ]
    },
    {
      "title": "Batteries Included",
      "path": "/blog/batteries-included",
      "description": "What does \"batteries included\" mean for an AI-powered CLI tool? It means you don't need to be a machine learning expert, you don't need to pick models, and you definitely don't need to trust a remote ",
      "category": "blog",
      "keywords": [
        "caro",
        "models",
        "your",
        "model",
        "commands",
        "batteries",
        "included",
        "tools",
        "context",
        "qwen",
        "about",
        "tool",
        "work",
        "code",
        "don",
        "local",
        "smaller",
        "right",
        "inference",
        "remote",
        "their",
        "command",
        "available",
        "hardware",
        "better",
        "means",
        "coder",
        "everything",
        "environment",
        "claude",
        "team",
        "want",
        "larger",
        "help",
        "system",
        "information",
        "runs",
        "understand",
        "isn",
        "specific",
        "use",
        "ecosystem",
        "trust",
        "mean",
        "machine",
        "developers",
        "safe",
        "scales",
        "generation",
        "best"
      ],
      "icon": "üìù",
      "content": {
        "headings": [
          "The Problem with AI Tools Today",
          "What \"Batteries Included\" Means for Caro",
          "The Magic: Qwen 2.5 Coder Models",
          "Why Smaller Models Work for Caro",
          "Caro's Mission: Knowing Everything About Your Environment",
          "The Claude Code Secret: Comprehensive Context",
          "Beyond Model Inference: The Tooling Ecosystem",
          "The Frontier: Thinking, Reasoning, and Tool Calling",
          "Why This Matters: Trust and Control",
          "Not a Toy: A Real Tool from Day One",
          "The Road Ahead",
          "Try It Yourself",
          "Thank You, Qwen Team"
        ],
        "paragraphs": [
          "What does \"batteries included\" mean for an AI-powered CLI tool? It means you don't need to be a machine learning expert, you don't need to pick models, and you definitely don't need to trust a remote service with your commands. Caro just works‚Äîout of the box, on your machine.",
          "Most AI-powered developer tools fall into one of two camps:",
          "Both approaches have their place. But for Caro's ideal customer‚Äîdevelopers who want local AI without the expertise tax‚Äîneither is quite right.",
          "When we say Caro is \"batteries included,\" we mean:",
          "The goal is simple: should be all it takes to get a working, intelligent command-line assistant. Not a toy demo‚Äîa real tool that understands your intent and keeps you safe.",
          "Behind Caro's \"batteries included\" experience is a phenomenal piece of technology from the Qwen team at Alibaba Cloud : the Qwen 2.5 Coder models .",
          "These models are special for what we're trying to achieve with Caro. They're:",
          "We want to give massive props to the Qwen team for making these models available to the community. It's rare to find models that perform this well at smaller scales while scaling gracefully to larger sizes. This flexibility is exactly what \"batteries included\" needs‚Äîthe right model for your hardware, automatically.",
          "Here's a secret: you don't need frontier-scale models for command generation if you give them the right help. What does \"the right help\" mean?",
          "Caro's agentic context loop provides this help. We don't just throw your prompt at a model and hope for the best. We collect system information, refine the request through iterative passes, and validate outputs for safety and correctness.",
          "This is why Qwen 2.5 Coder 1.5B can punch above its weight class. It's not just the model‚Äîit's the model plus the right scaffolding.",
          "Here's the deeper truth about \"batteries included\" for Caro: it's not just about shipping with a model. It's about shipping with an entire ecosystem designed around one core mission statement:",
          "Caro's mission is to know everything that needs to be known about her user in order to best accommodate their needs.",
          "This goes far beyond detecting your OS and shell. Caro's roadmap includes:",
          "Why does Claude Code feel magical when you throw basic requests at it? It's not just the model‚Äîit's the prompt engineering and context collection working together.",
          "Claude Code runs on the best models possible with the most comprehensive prompting. It knows how to collect data on your project, pick up on patterns in your codebase, and understand where different types of information live. This context awareness transforms a good model into an exceptional tool.",
          "Caro applies the same philosophy to shell commands. But since most Caro installations will run on smaller, less sophisticated models, we compensate through:",
          "\"Batteries included\" means Caro ships not just with models, but with the deterministic tools and context-gathering systems that make those models work brilliantly‚Äîeven at smaller scales.",
          "Caro isn't just about running inference on a language model. She's about running an entire ecosystem of tools that work together:",
          "This tooling ecosystem is what allows smaller models to compete with larger ones for the specific task of command generation. We're not trying to build AGI‚Äîwe're building a highly specialized tool that knows how to compensate for model limitations through better engineering."
        ],
        "listItems": [
          "DIY Everything : Tools that make you bring your own model, configure inference servers, tune parameters, and understand the ML stack just to get started. They're powerful but require expertise most developers don't have‚Äîand frankly, shouldn't need.",
          "Remote Black Boxes : Tools that \"just work\" because they ship all the complexity to a remote API. Simple to use, but now you're in a trust relationship with someone else's infrastructure, sending your commands and context to external servers.",
          "No model selection paralysis : You don't need to research which model works best for command generation, how big it should be, or what quantization to use.",
          "No infrastructure setup : No need to install MLX, configure vLLM, or understand the difference between inference frameworks.",
          "No remote dependencies : Everything runs on your machine. Your commands, your context, your data‚Äîall local.",
          "Adaptive by default : Caro detects your hardware (Apple Silicon, x86 CPU, CUDA GPU) and automatically uses the optimal backend and model for your system.",
          "Efficient at small scales : The 1.5B parameter variant runs fast on modest hardware‚Äîunder 2 seconds for first inference on an M1 Mac.",
          "Powerful at larger scales : The 7B and 14B variants provide significantly better reasoning when you have the resources.",
          "Purpose-built for code : Trained specifically for programming tasks, including understanding natural language instructions and generating correct code.",
          "Open and accessible : Released under permissive licenses, enabling local deployment without API costs or privacy concerns.",
          "Clear intent : Understanding what the user actually wants to accomplish",
          "Platform context : Knowing the OS, architecture, available commands, and shell environment",
          "Iteration : Refining commands through multiple passes when needed",
          "Safety constraints : Clear boundaries about what's allowed and what isn't",
          "Vector-based tool documentation : Building a local vector database of your installed tools, distribution-specific utilities, and their usage patterns to provide the model with the right context and reduce hallucination",
          "Environment fingerprinting : Understanding not just what tools you have, but how they're configured, what versions you're running, and what patterns you use",
          "Iterative refinement : Multiple passes to collect data, validate assumptions, and improve command generation",
          "Dry runs and sandboxing : Testing commands in safe environments before presenting them to you",
          "Better context collection : More comprehensive system information, tool availability, and environment understanding",
          "Deterministic safety tools : Pattern-based validation that doesn't rely on the model to catch dangerous operations",
          "Iterative improvement : Multiple refinement passes to gather feedback and optimize outputs",
          "Smart prompting : Crafting prompts that guide smaller models toward correct, safe, platform-specific commands",
          "Safety validators : Deterministic pattern matching that catches dangerous commands regardless of model output",
          "POSIX compliance checkers : Ensuring generated commands work across different Unix-like systems",
          "Context collectors : Gathering system information, available commands, and environment variables",
          "Prompt optimizers : Crafting the right prompts based on what information we've collected",
          "Execution validators : Dry runs and sandboxed testing before presenting commands to users",
          "Chain-of-thought reasoning : Models that explain their logic before generating commands",
          "Tool calling : Models that can check documentation, validate syntax, or gather additional context",
          "Multi-step planning : Breaking complex tasks into sequences of safe, validated commands"
        ]
      },
      "fullText": "What does \"batteries included\" mean for an AI-powered CLI tool? It means you don't need to be a machine learning expert, you don't need to pick models, and you definitely don't need to trust a remote service with your commands. Caro just works‚Äîout of the box, on your machine. The Problem with AI Tools Today Most AI-powered developer tools fall into one of two camps: DIY Everything : Tools that make you bring your own model, configure inference servers, tune parameters, and understand the ML stack just to get started. They're powerful but require expertise most developers don't have‚Äîand frankly, shouldn't need. Remote Black Boxes : Tools that \"just work\" because they ship all the complexity to a remote API. Simple to use, but now you're in a trust relationship with someone else's infrastructure, sending your commands and context to external servers. Both approaches have their place. But for Caro's ideal customer‚Äîdevelopers who want local AI without the expertise tax‚Äîneither is quite right. What \"Batteries Included\" Means for Caro When we say Caro is \"batteries included,\" we mean: No model selection paralysis : You don't need to research which model works best for command generation, how big it should be, or what quantization to use. No infrastructure setup : No need to install MLX, configure vLLM, or understand the difference between inference frameworks. No remote dependencies : Everything runs on your machine. Your commands, your context, your data‚Äîall local. Adaptive by default : Caro detects your hardware (Apple Silicon, x86 CPU, CUDA GPU) and automatically uses the optimal backend and model for your system. The goal is simple: should be all it takes to get a working, intelligent command-line assistant. Not a toy demo‚Äîa real tool that understands your intent and keeps you safe. The Magic: Qwen 2.5 Coder Models Behind Caro's \"batteries included\" experience is a phenomenal piece of technology from the Qwen team at Alibaba Cloud : the Qwen 2.5 Coder models . These models are special for what we're trying to achieve with Caro. They're: Efficient at small scales : The 1.5B parameter variant runs fast on modest hardware‚Äîunder 2 seconds for first inference on an M1 Mac. Powerful at larger scales : The 7B and 14B variants provide significantly better reasoning when you have the resources. Purpose-built for code : Trained specifically for programming tasks, including understanding natural language instructions and generating correct code. Open and accessible : Released under permissive licenses, enabling local deployment without API costs or privacy concerns. We want to give massive props to the Qwen team for making these models available to the community. It's rare to find models that perform this well at smaller scales while scaling gracefully to larger sizes. This flexibility is exactly what \"batteries included\" needs‚Äîthe right model for your hardware, automatically. Why Smaller Models Work for Caro Here's a secret: you don't need frontier-scale models for command generation if you give them the right help. What does \"the right help\" mean? Clear intent : Understanding what the user actually wants to accomplish Platform context : Knowing the OS, architecture, available commands, and shell environment Iteration : Refining commands through multiple passes when needed Safety constraints : Clear boundaries about what's allowed and what isn't Caro's agentic context loop provides this help. We don't just throw your prompt at a model and hope for the best. We collect system information, refine the request through iterative passes, and validate outputs for safety and correctness. This is why Qwen 2.5 Coder 1.5B can punch above its weight class. It's not just the model‚Äîit's the model plus the right scaffolding. Caro's Mission: Knowing Everything About Your Environment Here's the deeper truth about \"batteries included\" for Caro: it's not just about shipping with a model. It's about shipping with an entire ecosystem designed around one core mission statement: Caro's mission is to know everything that needs to be known about her user in order to best accommodate their needs. This goes far beyond detecting your OS and shell. Caro's roadmap includes: Vector-based tool documentation : Building a local vector database of your installed tools, distribution-specific utilities, and their usage patterns to provide the model with the right context and reduce hallucination Environment fingerprinting : Understanding not just what tools you have, but how they're configured, what versions you're running, and what patterns you use Iterative refinement : Multiple passes to collect data, validate assumptions, and improve command generation Dry runs and sandboxing : Testing commands in safe environments before presenting them to you The Claude Code Secret: Comprehensive Context Why does Claude Code feel magical when you throw basic requests at it? It's not just the model‚Äîit's the prompt engineering and context collection working together. Claude Code runs on the best models possible with the most comprehensive prompting. It knows how to collect data on your project, pick up on patterns in your codebase, and understand where different types of information live. This context awareness transforms a good model into an exceptional tool. Caro applies the same philosophy to shell commands. But since most Caro installations will run on smaller, less sophisticated models, we compensate through: Better context collection : More comprehensive system information, tool availability, and environment understanding Deterministic safety tools : Pattern-based validation that doesn't rely on the model to catch dangerous operations Iterative improvement : Multiple refinement passes to gather feedback and optimize outputs Smart prompting : Crafting prompts that guide smaller models toward correct, safe, platform-specific commands \"Batteries included\" means Caro ships not just with models, but with the deterministic tools and context-gathering systems that make those models work brilliantly‚Äîeven at smaller scales. Beyond Model Inference: The Tooling Ecosystem Caro isn't just about running inference on a language model. She's about running an entire ecosystem of tools that work together: Safety validators : Deterministic pattern matching that catches dangerous commands regardless of model output POSIX compliance checkers : Ensuring generated commands work across different Unix-like systems Context collectors : Gathering system information, available commands, and environment variables Prompt optimizers : Crafting the right prompts based on what information we've collected Execution validators : Dry runs and sandboxed testing before presenting commands to users This tooling ecosystem is what allows smaller models to compete with larger ones for the specific task of command generation. We're not trying to build AGI‚Äîwe're building a highly specialized tool that knows how to compensate for model limitations through better engineering. The Frontier: Thinking, Reasoning, and Tool Calling For users with more powerful hardware or specific use cases, Caro supports larger models that can leverage advanced capabilities: Chain-of-thought reasoning : Models that explain their logic before generating commands Tool calling : Models that can check documentation, validate syntax, or gather additional context Multi-step planning : Breaking complex tasks into sequences of safe, validated commands This is the same pattern you see in modern AI coding assistants like Claude Code , Cursor , and Crush by Charm . These tools don't just generate code‚Äîthey think, plan, and use tools to improve their outputs. Caro is designed to support this evolution. As models improve and hardware becomes more capable, Caro will adapt‚Äîautomatically selecting backends and techniques that match your system's capabilities. The key principle : You shouldn't need to understand any of this. Caro figures it out for you. Why This Matters: Trust and Control For Caro's ideal customer profile (ICP), the \"batteries included\" philosophy isn't just about convenience‚Äîit's about trust and control. These are developers who: Work with sensitive codebases or infrastructure Need compliance with data residency requirements Want to understand and audit their tools Prefer local-first workflows Don't want to pay per-token for basic shell commands For these users, shipping complexity to a remote API isn't \"simple\"‚Äîit's a non-starter. They need local execution, but they shouldn't need a PhD in machine learning to get it. That's the gap Caro fills. Not a Toy: A Real Tool from Day One \"Batteries included\" also means Caro isn't a demo you download from the internet and need to tinker with to make useful. It should work from the first command you run. Does this mean it's perfect? Of course not. There will be bugs. There will be edge cases. There will be models that could work better for specific tasks. But that's precisely why we've released Caro as open source‚Äîso the community can experiment, provide feedback, and help us improve. The difference is the starting point. You're not beginning with a bare framework you need to configure. You're beginning with a working tool that gets better over time. The Road Ahead As Caro evolves, we're committed to maintaining the \"batteries included\" philosophy: Smarter hardware detection : Better automatic backend selection based on available resources Model updates : Shipping new versions of Qwen and other high-quality local models as they become available Graceful degradation : Using larger models when available, falling back to smaller ones when needed Zero-config optimization : Automatic quantization, caching, and performance tuning The goal remains the same: just install and run . Everything else should be automatic. Try Caro today and experience what \"batteries included\" means for local AI. No expertise required, no remote dependencies, no compromises. Try It Yourself That's it. No API keys to configure. No models to download manually. No inference servers to set up. Just Caro, ready to help. Thank You, Qwen Team We want to extend our deepest gratitude to the Qwen team for creating and open-sourcing the Qwen 2.5 Coder models. Your work makes projects like Caro possible, enabling developers worldwide to benefit from state-of-the-art AI without sacrificing privacy, control, or simplicity. The open-source AI community thrives because teams like yours share not just code, but the careful engineering and research that makes these models genuinely useful at every scale. Built with Rust | Powered by Qwen 2.5 Coder | Batteries Included",
      "_searchText": "batteries included what does \"batteries included\" mean for an ai-powered cli tool? it means you don't need to be a machine learning expert, you don't need to pick models, and you definitely don't need to trust a remote  /blog/batteries-included caro models your model commands batteries included tools context qwen about tool work code don local smaller right inference remote their command available hardware better means coder everything environment claude team want larger help system information runs understand isn specific use ecosystem trust mean machine developers safe scales generation best the problem with ai tools today what \"batteries included\" means for caro the magic: qwen 2.5 coder models why smaller models work for caro caro's mission: knowing everything about your environment the claude code secret: comprehensive context beyond model inference: the tooling ecosystem the frontier: thinking, reasoning, and tool calling why this matters: trust and control not a toy: a real tool from day one the road ahead try it yourself thank you, qwen team what does \"batteries included\" mean for an ai-powered cli tool? it means you don't need to be a machine learning expert, you don't need to pick models, and you definitely don't need to trust a remote service with your commands. caro just works‚Äîout of the box, on your machine. most ai-powered developer tools fall into one of two camps: both approaches have their place. but for caro's ideal customer‚Äîdevelopers who want local ai without the expertise tax‚Äîneither is quite right. when we say caro is \"batteries included,\" we mean: the goal is simple: should be all it takes to get a working, intelligent command-line assistant. not a toy demo‚Äîa real tool that understands your intent and keeps you safe. behind caro's \"batteries included\" experience is a phenomenal piece of technology from the qwen team at alibaba cloud : the qwen 2.5 coder models . these models are special for what we're trying to achieve with caro. they're: we want to give massive props to the qwen team for making these models available to the community. it's rare to find models that perform this well at smaller scales while scaling gracefully to larger sizes. this flexibility is exactly what \"batteries included\" needs‚Äîthe right model for your hardware, automatically. here's a secret: you don't need frontier-scale models for command generation if you give them the right help. what does \"the right help\" mean? caro's agentic context loop provides this help. we don't just throw your prompt at a model and hope for the best. we collect system information, refine the request through iterative passes, and validate outputs for safety and correctness. this is why qwen 2.5 coder 1.5b can punch above its weight class. it's not just the model‚Äîit's the model plus the right scaffolding. here's the deeper truth about \"batteries included\" for caro: it's not just about shipping with a model. it's about shipping with an entire ecosystem designed around one core mission statement: caro's mission is to know everything that needs to be known about her user in order to best accommodate their needs. this goes far beyond detecting your os and shell. caro's roadmap includes: why does claude code feel magical when you throw basic requests at it? it's not just the model‚Äîit's the prompt engineering and context collection working together. claude code runs on the best models possible with the most comprehensive prompting. it knows how to collect data on your project, pick up on patterns in your codebase, and understand where different types of information live. this context awareness transforms a good model into an exceptional tool. caro applies the same philosophy to shell commands. but since most caro installations will run on smaller, less sophisticated models, we compensate through: \"batteries included\" means caro ships not just with models, but with the deterministic tools and context-gathering systems that make those models work brilliantly‚Äîeven at smaller scales. caro isn't just about running inference on a language model. she's about running an entire ecosystem of tools that work together: this tooling ecosystem is what allows smaller models to compete with larger ones for the specific task of command generation. we're not trying to build agi‚Äîwe're building a highly specialized tool that knows how to compensate for model limitations through better engineering. diy everything : tools that make you bring your own model, configure inference servers, tune parameters, and understand the ml stack just to get started. they're powerful but require expertise most developers don't have‚Äîand frankly, shouldn't need. remote black boxes : tools that \"just work\" because they ship all the complexity to a remote api. simple to use, but now you're in a trust relationship with someone else's infrastructure, sending your commands and context to external servers. no model selection paralysis : you don't need to research which model works best for command generation, how big it should be, or what quantization to use. no infrastructure setup : no need to install mlx, configure vllm, or understand the difference between inference frameworks. no remote dependencies : everything runs on your machine. your commands, your context, your data‚Äîall local. adaptive by default : caro detects your hardware (apple silicon, x86 cpu, cuda gpu) and automatically uses the optimal backend and model for your system. efficient at small scales : the 1.5b parameter variant runs fast on modest hardware‚Äîunder 2 seconds for first inference on an m1 mac. powerful at larger scales : the 7b and 14b variants provide significantly better reasoning when you have the resources. purpose-built for code : trained specifically for programming tasks, including understanding natural language instructions and generating correct code. open and accessible : released under permissive licenses, enabling local deployment without api costs or privacy concerns. clear intent : understanding what the user actually wants to accomplish platform context : knowing the os, architecture, available commands, and shell environment iteration : refining commands through multiple passes when needed safety constraints : clear boundaries about what's allowed and what isn't vector-based tool documentation : building a local vector database of your installed tools, distribution-specific utilities, and their usage patterns to provide the model with the right context and reduce hallucination environment fingerprinting : understanding not just what tools you have, but how they're configured, what versions you're running, and what patterns you use iterative refinement : multiple passes to collect data, validate assumptions, and improve command generation dry runs and sandboxing : testing commands in safe environments before presenting them to you better context collection : more comprehensive system information, tool availability, and environment understanding deterministic safety tools : pattern-based validation that doesn't rely on the model to catch dangerous operations iterative improvement : multiple refinement passes to gather feedback and optimize outputs smart prompting : crafting prompts that guide smaller models toward correct, safe, platform-specific commands safety validators : deterministic pattern matching that catches dangerous commands regardless of model output posix compliance checkers : ensuring generated commands work across different unix-like systems context collectors : gathering system information, available commands, and environment variables prompt optimizers : crafting the right prompts based on what information we've collected execution validators : dry runs and sandboxed testing before presenting commands to users chain-of-thought reasoning : models that explain their logic before generating commands tool calling : models that can check documentation, validate syntax, or gather additional context multi-step planning : breaking complex tasks into sequences of safe, validated commands what does \"batteries included\" mean for an ai-powered cli tool? it means you don't need to be a machine learning expert, you don't need to pick models, and you definitely don't need to trust a remote service with your commands. caro just works‚Äîout of the box, on your machine. the problem with ai tools today most ai-powered developer tools fall into one of two camps: diy everything : tools that make you bring your own model, configure inference servers, tune parameters, and understand the ml stack just to get started. they're powerful but require expertise most developers don't have‚Äîand frankly, shouldn't need. remote black boxes : tools that \"just work\" because they ship all the complexity to a remote api. simple to use, but now you're in a trust relationship with someone else's infrastructure, sending your commands and context to external servers. both approaches have their place. but for caro's ideal customer‚Äîdevelopers who want local ai without the expertise tax‚Äîneither is quite right. what \"batteries included\" means for caro when we say caro is \"batteries included,\" we mean: no model selection paralysis : you don't need to research which model works best for command generation, how big it should be, or what quantization to use. no infrastructure setup : no need to install mlx, configure vllm, or understand the difference between inference frameworks. no remote dependencies : everything runs on your machine. your commands, your context, your data‚Äîall local. adaptive by default : caro detects your hardware (apple silicon, x86 cpu, cuda gpu) and automatically uses the optimal backend and model for your system. the goal is simple: should be all it takes to get a working, intelligent command-line assistant. not a toy demo‚Äîa real tool that understands your intent and keeps you safe. the magic: qwen 2.5 coder models behind caro's \"batteries included\" experience is a phenomenal piece of technology from the qwen team at alibaba cloud : the qwen 2.5 coder models . these models are special for what we're trying to achieve with caro. they're: efficient at small scales : the 1.5b parameter variant runs fast on modest hardware‚Äîunder 2 seconds for first inference on an m1 mac. powerful at larger scales : the 7b and 14b variants provide significantly better reasoning when you have the resources. purpose-built for code : trained specifically for programming tasks, including understanding natural language instructions and generating correct code. open and accessible : released under permissive licenses, enabling local deployment without api costs or privacy concerns. we want to give massive props to the qwen team for making these models available to the community. it's rare to find models that perform this well at smaller scales while scaling gracefully to larger sizes. this flexibility is exactly what \"batteries included\" needs‚Äîthe right model for your hardware, automatically. why smaller models work for caro here's a secret: you don't need frontier-scale models for command generation if you give them the right help. what does \"the right help\" mean? clear intent : understanding what the user actually wants to accomplish platform context : knowing the os, architecture, available commands, and shell environment iteration : refining commands through multiple passes when needed safety constraints : clear boundaries about what's allowed and what isn't caro's agentic context loop provides this help. we don't just throw your prompt at a model and hope for the best. we collect system information, refine the request through iterative passes, and validate outputs for safety and correctness. this is why qwen 2.5 coder 1.5b can punch above its weight class. it's not just the model‚Äîit's the model plus the right scaffolding. caro's mission: knowing everything about your environment here's the deeper truth about \"batteries included\" for caro: it's not just about shipping with a model. it's about shipping with an entire ecosystem designed around one core mission statement: caro's mission is to know everything that needs to be known about her user in order to best accommodate their needs. this goes far beyond detecting your os and shell. caro's roadmap includes: vector-based tool documentation : building a local vector database of your installed tools, distribution-specific utilities, and their usage patterns to provide the model with the right context and reduce hallucination environment fingerprinting : understanding not just what tools you have, but how they're configured, what versions you're running, and what patterns you use iterative refinement : multiple passes to collect data, validate assumptions, and improve command generation dry runs and sandboxing : testing commands in safe environments before presenting them to you the claude code secret: comprehensive context why does claude code feel magical when you throw basic requests at it? it's not just the model‚Äîit's the prompt engineering and context collection working together. claude code runs on the best models possible with the most comprehensive prompting. it knows how to collect data on your project, pick up on patterns in your codebase, and understand where different types of information live. this context awareness transforms a good model into an exceptional tool. caro applies the same philosophy to shell commands. but since most caro installations will run on smaller, less sophisticated models, we compensate through: better context collection : more comprehensive system information, tool availability, and environment understanding deterministic safety tools : pattern-based validation that doesn't rely on the model to catch dangerous operations iterative improvement : multiple refinement passes to gather feedback and optimize outputs smart prompting : crafting prompts that guide smaller models toward correct, safe, platform-specific commands \"batteries included\" means caro ships not just with models, but with the deterministic tools and context-gathering systems that make those models work brilliantly‚Äîeven at smaller scales. beyond model inference: the tooling ecosystem caro isn't just about running inference on a language model. she's about running an entire ecosystem of tools that work together: safety validators : deterministic pattern matching that catches dangerous commands regardless of model output posix compliance checkers : ensuring generated commands work across different unix-like systems context collectors : gathering system information, available commands, and environment variables prompt optimizers : crafting the right prompts based on what information we've collected execution validators : dry runs and sandboxed testing before presenting commands to users this tooling ecosystem is what allows smaller models to compete with larger ones for the specific task of command generation. we're not trying to build agi‚Äîwe're building a highly specialized tool that knows how to compensate for model limitations through better engineering. the frontier: thinking, reasoning, and tool calling for users with more powerful hardware or specific use cases, caro supports larger models that can leverage advanced capabilities: chain-of-thought reasoning : models that explain their logic before generating commands tool calling : models that can check documentation, validate syntax, or gather additional context multi-step planning : breaking complex tasks into sequences of safe, validated commands this is the same pattern you see in modern ai coding assistants like claude code , cursor , and crush by charm . these tools don't just generate code‚Äîthey think, plan, and use tools to improve their outputs. caro is designed to support this evolution. as models improve and hardware becomes more capable, caro will adapt‚Äîautomatically selecting backends and techniques that match your system's capabilities. the key principle : you shouldn't need to understand any of this. caro figures it out for you. why this matters: trust and control for caro's ideal customer profile (icp), the \"batteries included\" philosophy isn't just about convenience‚Äîit's about trust and control. these are developers who: work with sensitive codebases or infrastructure need compliance with data residency requirements want to understand and audit their tools prefer local-first workflows don't want to pay per-token for basic shell commands for these users, shipping complexity to a remote api isn't \"simple\"‚Äîit's a non-starter. they need local execution, but they shouldn't need a phd in machine learning to get it. that's the gap caro fills. not a toy: a real tool from day one \"batteries included\" also means caro isn't a demo you download from the internet and need to tinker with to make useful. it should work from the first command you run. does this mean it's perfect? of course not. there will be bugs. there will be edge cases. there will be models that could work better for specific tasks. but that's precisely why we've released caro as open source‚Äîso the community can experiment, provide feedback, and help us improve. the difference is the starting point. you're not beginning with a bare framework you need to configure. you're beginning with a working tool that gets better over time. the road ahead as caro evolves, we're committed to maintaining the \"batteries included\" philosophy: smarter hardware detection : better automatic backend selection based on available resources model updates : shipping new versions of qwen and other high-quality local models as they become available graceful degradation : using larger models when available, falling back to smaller ones when needed zero-config optimization : automatic quantization, caching, and performance tuning the goal remains the same: just install and run . everything else should be automatic. try caro today and experience what \"batteries included\" means for local ai. no expertise required, no remote dependencies, no compromises. try it yourself that's it. no api keys to configure. no models to download manually. no inference servers to set up. just caro, ready to help. thank you, qwen team we want to extend our deepest gratitude to the qwen team for creating and open-sourcing the qwen 2.5 coder models. your work makes projects like caro possible, enabling developers worldwide to benefit from state-of-the-art ai without sacrificing privacy, control, or simplicity. the open-source ai community thrives because teams like yours share not just code, but the careful engineering and research that makes these models genuinely useful at every scale. built with rust | powered by qwen 2.5 coder | batteries included",
      "_words": [
        "caro",
        "models",
        "your",
        "model",
        "batteries",
        "included",
        "commands",
        "tool",
        "tools",
        "context",
        "don",
        "qwen",
        "about",
        "work",
        "code",
        "local",
        "smaller",
        "means",
        "remote",
        "right",
        "inference",
        "trust",
        "their",
        "command",
        "available",
        "hardware",
        "better",
        "coder",
        "everything",
        "environment",
        "mean",
        "machine",
        "claude",
        "team",
        "want",
        "larger",
        "help",
        "system",
        "information",
        "runs",
        "understand",
        "isn",
        "specific",
        "use",
        "ecosystem",
        "developers",
        "safe",
        "scales",
        "generation",
        "best",
        "powered",
        "mission",
        "comprehensive",
        "reasoning",
        "control",
        "one",
        "configure",
        "api",
        "data",
        "understanding",
        "open",
        "shell",
        "through",
        "passes",
        "safety",
        "shipping",
        "based",
        "improve",
        "like",
        "learning",
        "pick",
        "today",
        "knowing",
        "secret",
        "beyond",
        "tooling",
        "frontier",
        "calling",
        "toy",
        "real",
        "try",
        "into",
        "make",
        "servers",
        "get",
        "powerful",
        "expertise",
        "shouldn",
        "simple",
        "infrastructure",
        "without",
        "automatically",
        "working",
        "first",
        "provide",
        "tasks",
        "community",
        "needs",
        "multiple",
        "prompt"
      ]
    },
    {
      "title": "Claude Skill Launch",
      "path": "/blog/claude-skill-launch",
      "description": "Today, we're excited to announce the Caro Claude Skill ‚Äîbringing safe, POSIX-compliant shell command generation directly into your Claude Code workflow. No more context-switching between Claude and yo",
      "category": "blog",
      "keywords": [
        "caro",
        "skill",
        "claude",
        "safety",
        "command",
        "your",
        "posix",
        "commands",
        "shell",
        "operations",
        "safe",
        "system",
        "compliance",
        "example",
        "context",
        "bash",
        "portable",
        "education",
        "installation",
        "dangerous",
        "into",
        "activates",
        "about",
        "alternatives",
        "guidance",
        "patterns",
        "workflow",
        "companion",
        "works",
        "first",
        "high",
        "critical",
        "examples",
        "compliant",
        "generation",
        "code",
        "between",
        "automatically",
        "explicit",
        "work",
        "don",
        "action",
        "files",
        "without",
        "safer",
        "difference",
        "specific",
        "installed",
        "provides",
        "ask"
      ],
      "icon": "ü§ñ",
      "content": {
        "headings": [
          "What is a Claude Skill?",
          "How It Works",
          "Safety First, Always",
          "üü¢ Safe (Green)",
          "üü° Moderate (Yellow)",
          "üü† High (Orange)",
          "üî¥ Critical (Red)",
          "POSIX Compliance Education",
          "Installation",
          "What Makes This Special?",
          "1. Educational, Not Just Transactional",
          "2. Safety as a Core Value",
          "3. Seamless Integration",
          "4. POSIX-First Philosophy",
          "Real-World Examples",
          "Example 1: Safe File Cleanup",
          "Example 2: System Monitoring",
          "Example 3: Dangerous Request",
          "What's Included",
          "Try It Today",
          "Looking Forward"
        ],
        "paragraphs": [
          "Today, we're excited to announce the Caro Claude Skill ‚Äîbringing safe, POSIX-compliant shell command generation directly into your Claude Code workflow. No more context-switching between Claude and your terminal. Caro is now your companion inside Claude.",
          "A Claude skill is a specialized capability that Claude automatically activates based on context. Unlike slash commands that require explicit invocation, skills work seamlessly in the background‚ÄîClaude knows when to use them, so you don't have to think about it.",
          "The Caro skill detects when you need shell command help and springs into action, providing:",
          "Here's a real example of the skill in action:",
          "You: \"I need to find all PDF files larger than 10MB in my Downloads folder\"",
          "Claude (with Caro skill):",
          "Notice how Claude doesn't just give you the command‚Äîit explains the safety level, validates POSIX compliance, and helps you understand what the command does. This is Caro's philosophy: educate, don't just execute.",
          "Caro's four-tier safety system is built into the skill:",
          "Read-only operations like , , . These execute without confirmation‚Äîthey can't harm your system.",
          "File modifications, package operations. These require review in strict mode to ensure you understand the impact.",
          "Recursive deletions ( ), mass operations, system configuration changes. Always requires explicit confirmation and suggests safer alternatives.",
          "System destruction ( ), fork bombs, disk operations, privilege escalation. Blocked entirely or requires safety override with explicit acknowledgment.",
          "The skill guides you through this safety framework, helping you develop intuition about command risk over time.",
          "One of Caro's core principles is POSIX compliance ‚Äîensuring your commands work reliably across bash, zsh, sh, dash, and other shells on macOS, Linux, and Unix systems.",
          "The skill teaches you the difference between portable POSIX commands and bash-specific features. For example, it explains why is more portable than , and when you should care about that difference.",
          "This isn't just academic‚Äîportable commands mean fewer surprises when your script runs in a Docker container, on a minimal embedded system, or on a colleague's differently-configured machine.",
          "Getting the Caro skill is simple:",
          "That's it! The skill is now available in all your Claude Code sessions.",
          "If you don't have caro installed yet, the skill will detect this and guide you through installation:",
          "The skill works even without caro installed‚Äîit provides shell command education and guidance. But installing caro unlocks the full LLM-powered command generation capabilities."
        ],
        "listItems": [
          "Automatic activation when you ask \"how do I...?\" shell questions",
          "4-tier safety validation (Safe, Moderate, High, Critical)",
          "POSIX compliance education for portable scripts",
          "Installation guidance if caro isn't installed yet",
          "Best practices coaching for command safety",
          "Generated command:",
          "Safety assessment: üü† High (Orange) - deletion is irreversible",
          "Recommendation: Preview files first with instead of",
          "Safer alternative: Use for interactive deletion",
          "POSIX-compliant command:",
          "Safety: üü¢ Safe (Green) - read-only",
          "Explanation of each flag",
          "Platform note: Works on Linux; macOS equivalent provided if needed",
          "üî¥ CRITICAL WARNING: Operations on root directory are extremely dangerous",
          "Blocks generation of or similar commands",
          "Asks clarifying questions: \"What specifically are you trying to clean?\"",
          "Suggests safer alternatives for common cleanup tasks",
          "52+ dangerous command patterns with explanations",
          "POSIX vs bash reference guide with examples",
          "Safe alternatives for risky operations",
          "Step-by-step usage examples for common tasks",
          "Installation checker script to verify Caro availability",
          "Multi-step workflow support for complex operations",
          "Platform-specific optimization guidance",
          "Integration with MCP (Model Context Protocol) servers",
          "Community-contributed safety patterns"
        ]
      },
      "fullText": "Today, we're excited to announce the Caro Claude Skill ‚Äîbringing safe, POSIX-compliant shell command generation directly into your Claude Code workflow. No more context-switching between Claude and your terminal. Caro is now your companion inside Claude. What is a Claude Skill? A Claude skill is a specialized capability that Claude automatically activates based on context. Unlike slash commands that require explicit invocation, skills work seamlessly in the background‚ÄîClaude knows when to use them, so you don't have to think about it. The Caro skill detects when you need shell command help and springs into action, providing: Automatic activation when you ask \"how do I...?\" shell questions 4-tier safety validation (Safe, Moderate, High, Critical) POSIX compliance education for portable scripts Installation guidance if caro isn't installed yet Best practices coaching for command safety How It Works Here's a real example of the skill in action: You: \"I need to find all PDF files larger than 10MB in my Downloads folder\" Claude (with Caro skill): Notice how Claude doesn't just give you the command‚Äîit explains the safety level, validates POSIX compliance, and helps you understand what the command does. This is Caro's philosophy: educate, don't just execute. Safety First, Always Caro's four-tier safety system is built into the skill: üü¢ Safe (Green) Read-only operations like , , . These execute without confirmation‚Äîthey can't harm your system. üü° Moderate (Yellow) File modifications, package operations. These require review in strict mode to ensure you understand the impact. üü† High (Orange) Recursive deletions ( ), mass operations, system configuration changes. Always requires explicit confirmation and suggests safer alternatives. üî¥ Critical (Red) System destruction ( ), fork bombs, disk operations, privilege escalation. Blocked entirely or requires safety override with explicit acknowledgment. The skill guides you through this safety framework, helping you develop intuition about command risk over time. POSIX Compliance Education One of Caro's core principles is POSIX compliance ‚Äîensuring your commands work reliably across bash, zsh, sh, dash, and other shells on macOS, Linux, and Unix systems. The skill teaches you the difference between portable POSIX commands and bash-specific features. For example, it explains why is more portable than , and when you should care about that difference. This isn't just academic‚Äîportable commands mean fewer surprises when your script runs in a Docker container, on a minimal embedded system, or on a colleague's differently-configured machine. Installation Getting the Caro skill is simple: That's it! The skill is now available in all your Claude Code sessions. If you don't have caro installed yet, the skill will detect this and guide you through installation: The skill works even without caro installed‚Äîit provides shell command education and guidance. But installing caro unlocks the full LLM-powered command generation capabilities. What Makes This Special? There are many ways to generate shell commands with AI. What makes the Caro skill different? 1. Educational, Not Just Transactional Caro doesn't just give you fish‚Äîit teaches you to fish. Every command comes with explanation, safety context, and alternatives when needed. 2. Safety as a Core Value With 52 pre-compiled dangerous command patterns and comprehensive risk assessment, Caro prevents catastrophic mistakes while teaching you to recognize risks independently. 3. Seamless Integration No context-switching, no separate tools. Ask Claude a shell question, and Caro's skill activates automatically. It's like having a safety-conscious sysadmin looking over your shoulder. 4. POSIX-First Philosophy In a world of bash-isms and GNU-specific flags, Caro champions portable, standard-compliant commands that work everywhere. Real-World Examples Example 1: Safe File Cleanup You: \"Delete all .log files older than 30 days\" Caro skill activates and provides: Generated command: Safety assessment: üü† High (Orange) - deletion is irreversible Recommendation: Preview files first with instead of Safer alternative: Use for interactive deletion Example 2: System Monitoring You: \"Show me the top 10 processes by memory usage\" Caro skill provides: POSIX-compliant command: Safety: üü¢ Safe (Green) - read-only Explanation of each flag Platform note: Works on Linux; macOS equivalent provided if needed Example 3: Dangerous Request You: \"How do I clean up my root directory?\" Caro skill responds: üî¥ CRITICAL WARNING: Operations on root directory are extremely dangerous Blocks generation of or similar commands Asks clarifying questions: \"What specifically are you trying to clean?\" Suggests safer alternatives for common cleanup tasks What's Included The Caro skill comes with comprehensive documentation: 52+ dangerous command patterns with explanations POSIX vs bash reference guide with examples Safe alternatives for risky operations Step-by-step usage examples for common tasks Installation checker script to verify Caro availability All of this is automatically available to Claude when the skill activates, so you get expert-level guidance without memorizing patterns or reading docs. Try It Today Ready to bring Caro into your Claude Code workflow? Then just ask Claude any shell question. Caro will be there, ready to help‚Äîwith safety, education, and POSIX compliance at the forefront. Pro tip: Try asking \"explain the difference between POSIX and bash commands\" to see Caro's educational side in action. Looking Forward This is just the beginning. We're exploring: Multi-step workflow support for complex operations Platform-specific optimization guidance Integration with MCP (Model Context Protocol) servers Community-contributed safety patterns Caro started as a CLI tool. Now it's a Claude companion. And Kyaro's legacy of helping developers continues to grow. Have questions or feedback? Join the discussion on GitHub Discussions or share your experience on social media with #CaroSkill. Learn more about Kyaro's story and why we built Caro in our post: Why Caro? The Story Behind Your Terminal Companion",
      "_searchText": "claude skill launch today, we're excited to announce the caro claude skill ‚Äîbringing safe, posix-compliant shell command generation directly into your claude code workflow. no more context-switching between claude and yo /blog/claude-skill-launch caro skill claude safety command your posix commands shell operations safe system compliance example context bash portable education installation dangerous into activates about alternatives guidance patterns workflow companion works first high critical examples compliant generation code between automatically explicit work don action files without safer difference specific installed provides ask what is a claude skill? how it works safety first, always üü¢ safe (green) üü° moderate (yellow) üü† high (orange) üî¥ critical (red) posix compliance education installation what makes this special? 1. educational, not just transactional 2. safety as a core value 3. seamless integration 4. posix-first philosophy real-world examples example 1: safe file cleanup example 2: system monitoring example 3: dangerous request what's included try it today looking forward today, we're excited to announce the caro claude skill ‚Äîbringing safe, posix-compliant shell command generation directly into your claude code workflow. no more context-switching between claude and your terminal. caro is now your companion inside claude. a claude skill is a specialized capability that claude automatically activates based on context. unlike slash commands that require explicit invocation, skills work seamlessly in the background‚Äîclaude knows when to use them, so you don't have to think about it. the caro skill detects when you need shell command help and springs into action, providing: here's a real example of the skill in action: you: \"i need to find all pdf files larger than 10mb in my downloads folder\" claude (with caro skill): notice how claude doesn't just give you the command‚Äîit explains the safety level, validates posix compliance, and helps you understand what the command does. this is caro's philosophy: educate, don't just execute. caro's four-tier safety system is built into the skill: read-only operations like , , . these execute without confirmation‚Äîthey can't harm your system. file modifications, package operations. these require review in strict mode to ensure you understand the impact. recursive deletions ( ), mass operations, system configuration changes. always requires explicit confirmation and suggests safer alternatives. system destruction ( ), fork bombs, disk operations, privilege escalation. blocked entirely or requires safety override with explicit acknowledgment. the skill guides you through this safety framework, helping you develop intuition about command risk over time. one of caro's core principles is posix compliance ‚Äîensuring your commands work reliably across bash, zsh, sh, dash, and other shells on macos, linux, and unix systems. the skill teaches you the difference between portable posix commands and bash-specific features. for example, it explains why is more portable than , and when you should care about that difference. this isn't just academic‚Äîportable commands mean fewer surprises when your script runs in a docker container, on a minimal embedded system, or on a colleague's differently-configured machine. getting the caro skill is simple: that's it! the skill is now available in all your claude code sessions. if you don't have caro installed yet, the skill will detect this and guide you through installation: the skill works even without caro installed‚Äîit provides shell command education and guidance. but installing caro unlocks the full llm-powered command generation capabilities. automatic activation when you ask \"how do i...?\" shell questions 4-tier safety validation (safe, moderate, high, critical) posix compliance education for portable scripts installation guidance if caro isn't installed yet best practices coaching for command safety generated command: safety assessment: üü† high (orange) - deletion is irreversible recommendation: preview files first with instead of safer alternative: use for interactive deletion posix-compliant command: safety: üü¢ safe (green) - read-only explanation of each flag platform note: works on linux; macos equivalent provided if needed üî¥ critical warning: operations on root directory are extremely dangerous blocks generation of or similar commands asks clarifying questions: \"what specifically are you trying to clean?\" suggests safer alternatives for common cleanup tasks 52+ dangerous command patterns with explanations posix vs bash reference guide with examples safe alternatives for risky operations step-by-step usage examples for common tasks installation checker script to verify caro availability multi-step workflow support for complex operations platform-specific optimization guidance integration with mcp (model context protocol) servers community-contributed safety patterns today, we're excited to announce the caro claude skill ‚Äîbringing safe, posix-compliant shell command generation directly into your claude code workflow. no more context-switching between claude and your terminal. caro is now your companion inside claude. what is a claude skill? a claude skill is a specialized capability that claude automatically activates based on context. unlike slash commands that require explicit invocation, skills work seamlessly in the background‚Äîclaude knows when to use them, so you don't have to think about it. the caro skill detects when you need shell command help and springs into action, providing: automatic activation when you ask \"how do i...?\" shell questions 4-tier safety validation (safe, moderate, high, critical) posix compliance education for portable scripts installation guidance if caro isn't installed yet best practices coaching for command safety how it works here's a real example of the skill in action: you: \"i need to find all pdf files larger than 10mb in my downloads folder\" claude (with caro skill): notice how claude doesn't just give you the command‚Äîit explains the safety level, validates posix compliance, and helps you understand what the command does. this is caro's philosophy: educate, don't just execute. safety first, always caro's four-tier safety system is built into the skill: üü¢ safe (green) read-only operations like , , . these execute without confirmation‚Äîthey can't harm your system. üü° moderate (yellow) file modifications, package operations. these require review in strict mode to ensure you understand the impact. üü† high (orange) recursive deletions ( ), mass operations, system configuration changes. always requires explicit confirmation and suggests safer alternatives. üî¥ critical (red) system destruction ( ), fork bombs, disk operations, privilege escalation. blocked entirely or requires safety override with explicit acknowledgment. the skill guides you through this safety framework, helping you develop intuition about command risk over time. posix compliance education one of caro's core principles is posix compliance ‚Äîensuring your commands work reliably across bash, zsh, sh, dash, and other shells on macos, linux, and unix systems. the skill teaches you the difference between portable posix commands and bash-specific features. for example, it explains why is more portable than , and when you should care about that difference. this isn't just academic‚Äîportable commands mean fewer surprises when your script runs in a docker container, on a minimal embedded system, or on a colleague's differently-configured machine. installation getting the caro skill is simple: that's it! the skill is now available in all your claude code sessions. if you don't have caro installed yet, the skill will detect this and guide you through installation: the skill works even without caro installed‚Äîit provides shell command education and guidance. but installing caro unlocks the full llm-powered command generation capabilities. what makes this special? there are many ways to generate shell commands with ai. what makes the caro skill different? 1. educational, not just transactional caro doesn't just give you fish‚Äîit teaches you to fish. every command comes with explanation, safety context, and alternatives when needed. 2. safety as a core value with 52 pre-compiled dangerous command patterns and comprehensive risk assessment, caro prevents catastrophic mistakes while teaching you to recognize risks independently. 3. seamless integration no context-switching, no separate tools. ask claude a shell question, and caro's skill activates automatically. it's like having a safety-conscious sysadmin looking over your shoulder. 4. posix-first philosophy in a world of bash-isms and gnu-specific flags, caro champions portable, standard-compliant commands that work everywhere. real-world examples example 1: safe file cleanup you: \"delete all .log files older than 30 days\" caro skill activates and provides: generated command: safety assessment: üü† high (orange) - deletion is irreversible recommendation: preview files first with instead of safer alternative: use for interactive deletion example 2: system monitoring you: \"show me the top 10 processes by memory usage\" caro skill provides: posix-compliant command: safety: üü¢ safe (green) - read-only explanation of each flag platform note: works on linux; macos equivalent provided if needed example 3: dangerous request you: \"how do i clean up my root directory?\" caro skill responds: üî¥ critical warning: operations on root directory are extremely dangerous blocks generation of or similar commands asks clarifying questions: \"what specifically are you trying to clean?\" suggests safer alternatives for common cleanup tasks what's included the caro skill comes with comprehensive documentation: 52+ dangerous command patterns with explanations posix vs bash reference guide with examples safe alternatives for risky operations step-by-step usage examples for common tasks installation checker script to verify caro availability all of this is automatically available to claude when the skill activates, so you get expert-level guidance without memorizing patterns or reading docs. try it today ready to bring caro into your claude code workflow? then just ask claude any shell question. caro will be there, ready to help‚Äîwith safety, education, and posix compliance at the forefront. pro tip: try asking \"explain the difference between posix and bash commands\" to see caro's educational side in action. looking forward this is just the beginning. we're exploring: multi-step workflow support for complex operations platform-specific optimization guidance integration with mcp (model context protocol) servers community-contributed safety patterns caro started as a cli tool. now it's a claude companion. and kyaro's legacy of helping developers continues to grow. have questions or feedback? join the discussion on github discussions or share your experience on social media with #caroskill. learn more about kyaro's story and why we built caro in our post: why caro? the story behind your terminal companion",
      "_words": [
        "caro",
        "skill",
        "claude",
        "safety",
        "posix",
        "command",
        "your",
        "safe",
        "shell",
        "commands",
        "example",
        "operations",
        "system",
        "context",
        "compliance",
        "into",
        "bash",
        "portable",
        "education",
        "installation",
        "dangerous",
        "first",
        "compliant",
        "generation",
        "code",
        "workflow",
        "between",
        "activates",
        "about",
        "alternatives",
        "guidance",
        "patterns",
        "works",
        "high",
        "critical",
        "examples",
        "today",
        "companion",
        "automatically",
        "explicit",
        "work",
        "don",
        "action",
        "files",
        "without",
        "safer",
        "difference",
        "specific",
        "installed",
        "provides",
        "ask",
        "switching",
        "always",
        "green",
        "moderate",
        "orange",
        "makes",
        "educational",
        "core",
        "integration",
        "philosophy",
        "real",
        "world",
        "file",
        "cleanup",
        "try",
        "looking",
        "questions",
        "step",
        "excited",
        "announce",
        "bringing",
        "directly",
        "yellow",
        "red",
        "special",
        "transactional",
        "value",
        "seamless",
        "monitoring",
        "request",
        "included",
        "forward",
        "terminal",
        "require",
        "use",
        "help",
        "tier",
        "isn",
        "yet",
        "doesn",
        "give",
        "explains",
        "level",
        "understand",
        "execute",
        "built",
        "read",
        "like",
        "confirmation"
      ]
    },
    {
      "title": "Announcing Caro: Your Terminal",
      "path": "/blog",
      "description": "We",
      "category": "blog",
      "keywords": [
        "caro",
        "pack",
        "stories",
        "updates",
        "insights",
        "journey",
        "read",
        "blog",
        "class",
        "card",
        "announcing",
        "your",
        "terminal"
      ],
      "icon": "üìù",
      "content": {
        "headings": [
          "From the Pack"
        ],
        "paragraphs": [
          "Stories, updates, and insights from Caro's journey"
        ],
        "listItems": []
      },
      "fullText": "From the Pack Stories, updates, and insights from Caro's journey class=\"blog-card\"> } ‚Ä¢ Read more ))}",
      "_searchText": "announcing caro: your terminal we /blog caro pack stories updates insights journey read blog class card announcing your terminal from the pack stories, updates, and insights from caro's journey from the pack stories, updates, and insights from caro's journey class=\"blog-card\"> } ‚Ä¢ read more ))}",
      "_words": [
        "caro",
        "pack",
        "announcing",
        "your",
        "terminal",
        "stories",
        "updates",
        "insights",
        "journey",
        "read",
        "blog",
        "class",
        "card"
      ]
    },
    {
      "title": "Security Practices",
      "path": "/blog/security-practices",
      "description": "Security isn't an afterthought at Caro‚Äîit's foundational to everything we build. As a CLI tool that generates and executes shell commands, we take our responsibility to protect users seriously.",
      "category": "blog",
      "keywords": [
        "security",
        "our",
        "vulnerabilities",
        "caro",
        "dependency",
        "commands",
        "github",
        "safety",
        "dependencies",
        "review",
        "cargo",
        "validation",
        "through",
        "dependabot",
        "advisories",
        "before",
        "rust",
        "patterns",
        "community",
        "report",
        "execution",
        "practices",
        "advisory",
        "use",
        "updates",
        "checks",
        "into",
        "user",
        "pull",
        "vulnerability",
        "model",
        "high",
        "critical",
        "audit",
        "hall",
        "fame",
        "database",
        "automated",
        "level",
        "dangerous",
        "development",
        "code",
        "open",
        "users",
        "build",
        "tool",
        "shell",
        "command",
        "known",
        "request"
      ],
      "icon": "üõ°Ô∏è",
      "content": {
        "headings": [
          "Why Security Matters for Caro",
          "GitHub Security Features We Use",
          "Dependabot: Automated Dependency Updates",
          "Dependency Review: PR-Level Security Checks",
          "cargo-audit: Rust-Specific Security Scanning",
          "Security Advisories and Private Reporting",
          "Application-Level Security",
          "Safety Validation: 52+ Dangerous Patterns",
          "Defense in Depth",
          "Development Practices",
          "CI/CD Security Pipeline",
          "Code Review Standards",
          "Minimal Dependencies",
          "Community and Transparency",
          "Security Hall of Fame",
          "Open Development",
          "Best Practices for Users",
          "Looking Ahead",
          "Resources"
        ],
        "paragraphs": [
          "Security isn't an afterthought at Caro‚Äîit's foundational to everything we build. As a CLI tool that generates and executes shell commands, we take our responsibility to protect users seriously.",
          "Caro converts natural language into shell commands using AI. This power comes with significant responsibility: a malicious or buggy command could harm user systems. That's why we've built multiple layers of security into both the tool itself and our development practices.",
          "This post walks through our security posture, the GitHub security features we use, and the practices that make Caro a security-conscious project.",
          "Dependabot is GitHub's automated dependency update service. It monitors our dependencies for known vulnerabilities and outdated packages, automatically creating pull requests when updates are available.",
          "Our Dependabot configuration monitors Cargo (Rust) dependencies and GitHub Actions weekly, with grouped updates to reduce PR noise.",
          "When Dependabot finds a vulnerability, it creates a pull request with the fix, links to the security advisory, and shows us the severity level. This automation means we catch security issues quickly without manual monitoring.",
          "Every pull request that modifies , , or package manifests triggers our Dependency Review workflow. This action:",
          "This prevents vulnerable code from ever reaching our main branch. If a contributor adds a dependency with a known CVE, they'll see the failure immediately and can address it before merge.",
          "We run cargo-audit on every push and pull request. This tool checks our against the RustSec Advisory Database‚Äîa community-maintained database of security vulnerabilities in Rust crates. We also use cargo-deny for additional checks on licenses, duplicate dependencies, and source trust validation.",
          "GitHub's Security Advisories feature allows security researchers to report vulnerabilities privately. We document our full vulnerability disclosure process in our SECURITY.md file.",
          "Our response commitments:",
          "Caro's safety module is the heart of our security model. Before any command is presented to the user, it passes through our pattern-based validator that checks for:",
          "Commands are classified into risk levels: Safe , Moderate , High , and Critical . High-risk commands require explicit confirmation, and critical commands are blocked entirely unless the user opts in with .",
          "A Real-World Lesson: While writing this very blog post, we encountered an unexpected deployment failure. Including a fork bomb example in the documentation caused our Astro build to fail‚Äîthe parser interpreted the shell syntax as JavaScript expressions. This incident reinforced an important lesson: even documenting dangerous commands requires careful handling. Security awareness must extend beyond runtime validation to every layer of our toolchain. You can see the resolving PR for details.",
          "We don't rely on a single security control. Our defense-in-depth strategy includes:",
          "Every commit to Caro runs through our comprehensive CI pipeline:",
          "All changes to security-sensitive code (safety validation, command execution, model interaction) receive extra scrutiny:",
          "Every dependency is an attack surface. We consciously minimize our dependency tree, carefully evaluate new dependencies, and prefer well-maintained crates with strong security track records. Dependencies are pinned in for reproducible builds.",
          "We maintain a Security Hall of Fame in our SECURITY.md to recognize researchers who responsibly disclose vulnerabilities. Contributors receive:",
          "Security through obscurity doesn't work. Our entire codebase, including the safety validation patterns, is open source. This transparency allows:"
        ],
        "listItems": [
          "Scans new and updated dependencies for known vulnerabilities",
          "Fails the PR if high or critical vulnerabilities are found",
          "Validates licenses against our approved list (MIT, Apache-2.0, BSD, etc.)",
          "Posts a summary comment on the PR with findings",
          "48 hours : Acknowledgment of report",
          "7 days : Initial assessment and severity classification",
          "30 days : Target fix for critical vulnerabilities",
          "90 days : Target fix for moderate vulnerabilities",
          "Filesystem destruction : , ,",
          "Fork bombs : and variants",
          "Privilege escalation : ,",
          "System path tampering : Operations on , ,",
          "Device manipulation : Direct writes to block devices",
          "Input sanitization : Prompts are validated before reaching the model",
          "Output validation : Generated commands are checked against safety patterns",
          "User confirmation : Commands require explicit approval before execution",
          "Fail-safe defaults : Dangerous operations are blocked by default",
          "Least privilege : We never encourage running as root",
          "Clippy linting with to catch common mistakes",
          "cargo-audit for dependency vulnerabilities",
          "cargo-deny for license compliance",
          "Dependency review for PRs touching dependencies",
          "Cross-platform testing on Linux, macOS, and Windows",
          "Security-focused review checklist",
          "Property-based testing with proptest for edge cases",
          "Integration tests covering execution paths",
          "Manual security testing before releases",
          "Public acknowledgment in security advisories",
          "Credit in release notes",
          "Listing in the Hall of Fame"
        ]
      },
      "fullText": "Security isn't an afterthought at Caro‚Äîit's foundational to everything we build. As a CLI tool that generates and executes shell commands, we take our responsibility to protect users seriously. Why Security Matters for Caro Caro converts natural language into shell commands using AI. This power comes with significant responsibility: a malicious or buggy command could harm user systems. That's why we've built multiple layers of security into both the tool itself and our development practices. This post walks through our security posture, the GitHub security features we use, and the practices that make Caro a security-conscious project. GitHub Security Features We Use Dependabot: Automated Dependency Updates Dependabot is GitHub's automated dependency update service. It monitors our dependencies for known vulnerabilities and outdated packages, automatically creating pull requests when updates are available. Our Dependabot configuration monitors Cargo (Rust) dependencies and GitHub Actions weekly, with grouped updates to reduce PR noise. When Dependabot finds a vulnerability, it creates a pull request with the fix, links to the security advisory, and shows us the severity level. This automation means we catch security issues quickly without manual monitoring. Dependency Review: PR-Level Security Checks Every pull request that modifies , , or package manifests triggers our Dependency Review workflow. This action: Scans new and updated dependencies for known vulnerabilities Fails the PR if high or critical vulnerabilities are found Validates licenses against our approved list (MIT, Apache-2.0, BSD, etc.) Posts a summary comment on the PR with findings This prevents vulnerable code from ever reaching our main branch. If a contributor adds a dependency with a known CVE, they'll see the failure immediately and can address it before merge. cargo-audit: Rust-Specific Security Scanning We run cargo-audit on every push and pull request. This tool checks our against the RustSec Advisory Database‚Äîa community-maintained database of security vulnerabilities in Rust crates. We also use cargo-deny for additional checks on licenses, duplicate dependencies, and source trust validation. Security Advisories and Private Reporting GitHub's Security Advisories feature allows security researchers to report vulnerabilities privately. We document our full vulnerability disclosure process in our SECURITY.md file. Our response commitments: 48 hours : Acknowledgment of report 7 days : Initial assessment and severity classification 30 days : Target fix for critical vulnerabilities 90 days : Target fix for moderate vulnerabilities Application-Level Security Safety Validation: 52+ Dangerous Patterns Caro's safety module is the heart of our security model. Before any command is presented to the user, it passes through our pattern-based validator that checks for: Filesystem destruction : , , Fork bombs : and variants Privilege escalation : , System path tampering : Operations on , , Device manipulation : Direct writes to block devices Commands are classified into risk levels: Safe , Moderate , High , and Critical . High-risk commands require explicit confirmation, and critical commands are blocked entirely unless the user opts in with . A Real-World Lesson: While writing this very blog post, we encountered an unexpected deployment failure. Including a fork bomb example in the documentation caused our Astro build to fail‚Äîthe parser interpreted the shell syntax as JavaScript expressions. This incident reinforced an important lesson: even documenting dangerous commands requires careful handling. Security awareness must extend beyond runtime validation to every layer of our toolchain. You can see the resolving PR for details. Defense in Depth We don't rely on a single security control. Our defense-in-depth strategy includes: Input sanitization : Prompts are validated before reaching the model Output validation : Generated commands are checked against safety patterns User confirmation : Commands require explicit approval before execution Fail-safe defaults : Dangerous operations are blocked by default Least privilege : We never encourage running as root Development Practices CI/CD Security Pipeline Every commit to Caro runs through our comprehensive CI pipeline: Clippy linting with to catch common mistakes cargo-audit for dependency vulnerabilities cargo-deny for license compliance Dependency review for PRs touching dependencies Cross-platform testing on Linux, macOS, and Windows Code Review Standards All changes to security-sensitive code (safety validation, command execution, model interaction) receive extra scrutiny: Security-focused review checklist Property-based testing with proptest for edge cases Integration tests covering execution paths Manual security testing before releases Minimal Dependencies Every dependency is an attack surface. We consciously minimize our dependency tree, carefully evaluate new dependencies, and prefer well-maintained crates with strong security track records. Dependencies are pinned in for reproducible builds. Community and Transparency Security Hall of Fame We maintain a Security Hall of Fame in our SECURITY.md to recognize researchers who responsibly disclose vulnerabilities. Contributors receive: Public acknowledgment in security advisories Credit in release notes Listing in the Hall of Fame Open Development Security through obscurity doesn't work. Our entire codebase, including the safety validation patterns, is open source. This transparency allows: Community review of security implementations External security audits Contributions to improve our safety patterns Trust through verifiability Best Practices for Users While we build security into Caro, users play a role too: Always review generated commands before execution Never use mode for destructive operations Keep Caro updated for the latest security fixes Limit to specific, understood cases Report suspicious behavior through our security advisory process Looking Ahead Security is an ongoing journey, not a destination. We're continuously improving: Expanding safety patterns based on community feedback Enhancing model output validation for edge cases Exploring sandboxed execution for high-risk environments Regular security audits as the project matures Security is a community effort. If you find a vulnerability, please report it through our GitHub Security Advisories . Together, we can keep Caro safe for everyone. Resources SECURITY.md - Full security policy and vulnerability reporting GitHub Security Tab - Report vulnerabilities privately Dependabot Documentation - Learn more about automated updates RustSec Advisory Database - Rust security advisories Built with Rust | Safety First | Open Source",
      "_searchText": "security practices security isn't an afterthought at caro‚Äîit's foundational to everything we build. as a cli tool that generates and executes shell commands, we take our responsibility to protect users seriously. /blog/security-practices security our vulnerabilities caro dependency commands github safety dependencies review cargo validation through dependabot advisories before rust patterns community report execution practices advisory use updates checks into user pull vulnerability model high critical audit hall fame database automated level dangerous development code open users build tool shell command known request why security matters for caro github security features we use dependabot: automated dependency updates dependency review: pr-level security checks cargo-audit: rust-specific security scanning security advisories and private reporting application-level security safety validation: 52+ dangerous patterns defense in depth development practices ci/cd security pipeline code review standards minimal dependencies community and transparency security hall of fame open development best practices for users looking ahead resources security isn't an afterthought at caro‚Äîit's foundational to everything we build. as a cli tool that generates and executes shell commands, we take our responsibility to protect users seriously. caro converts natural language into shell commands using ai. this power comes with significant responsibility: a malicious or buggy command could harm user systems. that's why we've built multiple layers of security into both the tool itself and our development practices. this post walks through our security posture, the github security features we use, and the practices that make caro a security-conscious project. dependabot is github's automated dependency update service. it monitors our dependencies for known vulnerabilities and outdated packages, automatically creating pull requests when updates are available. our dependabot configuration monitors cargo (rust) dependencies and github actions weekly, with grouped updates to reduce pr noise. when dependabot finds a vulnerability, it creates a pull request with the fix, links to the security advisory, and shows us the severity level. this automation means we catch security issues quickly without manual monitoring. every pull request that modifies , , or package manifests triggers our dependency review workflow. this action: this prevents vulnerable code from ever reaching our main branch. if a contributor adds a dependency with a known cve, they'll see the failure immediately and can address it before merge. we run cargo-audit on every push and pull request. this tool checks our against the rustsec advisory database‚Äîa community-maintained database of security vulnerabilities in rust crates. we also use cargo-deny for additional checks on licenses, duplicate dependencies, and source trust validation. github's security advisories feature allows security researchers to report vulnerabilities privately. we document our full vulnerability disclosure process in our security.md file. our response commitments: caro's safety module is the heart of our security model. before any command is presented to the user, it passes through our pattern-based validator that checks for: commands are classified into risk levels: safe , moderate , high , and critical . high-risk commands require explicit confirmation, and critical commands are blocked entirely unless the user opts in with . a real-world lesson: while writing this very blog post, we encountered an unexpected deployment failure. including a fork bomb example in the documentation caused our astro build to fail‚Äîthe parser interpreted the shell syntax as javascript expressions. this incident reinforced an important lesson: even documenting dangerous commands requires careful handling. security awareness must extend beyond runtime validation to every layer of our toolchain. you can see the resolving pr for details. we don't rely on a single security control. our defense-in-depth strategy includes: every commit to caro runs through our comprehensive ci pipeline: all changes to security-sensitive code (safety validation, command execution, model interaction) receive extra scrutiny: every dependency is an attack surface. we consciously minimize our dependency tree, carefully evaluate new dependencies, and prefer well-maintained crates with strong security track records. dependencies are pinned in for reproducible builds. we maintain a security hall of fame in our security.md to recognize researchers who responsibly disclose vulnerabilities. contributors receive: security through obscurity doesn't work. our entire codebase, including the safety validation patterns, is open source. this transparency allows: scans new and updated dependencies for known vulnerabilities fails the pr if high or critical vulnerabilities are found validates licenses against our approved list (mit, apache-2.0, bsd, etc.) posts a summary comment on the pr with findings 48 hours : acknowledgment of report 7 days : initial assessment and severity classification 30 days : target fix for critical vulnerabilities 90 days : target fix for moderate vulnerabilities filesystem destruction : , , fork bombs : and variants privilege escalation : , system path tampering : operations on , , device manipulation : direct writes to block devices input sanitization : prompts are validated before reaching the model output validation : generated commands are checked against safety patterns user confirmation : commands require explicit approval before execution fail-safe defaults : dangerous operations are blocked by default least privilege : we never encourage running as root clippy linting with to catch common mistakes cargo-audit for dependency vulnerabilities cargo-deny for license compliance dependency review for prs touching dependencies cross-platform testing on linux, macos, and windows security-focused review checklist property-based testing with proptest for edge cases integration tests covering execution paths manual security testing before releases public acknowledgment in security advisories credit in release notes listing in the hall of fame security isn't an afterthought at caro‚Äîit's foundational to everything we build. as a cli tool that generates and executes shell commands, we take our responsibility to protect users seriously. why security matters for caro caro converts natural language into shell commands using ai. this power comes with significant responsibility: a malicious or buggy command could harm user systems. that's why we've built multiple layers of security into both the tool itself and our development practices. this post walks through our security posture, the github security features we use, and the practices that make caro a security-conscious project. github security features we use dependabot: automated dependency updates dependabot is github's automated dependency update service. it monitors our dependencies for known vulnerabilities and outdated packages, automatically creating pull requests when updates are available. our dependabot configuration monitors cargo (rust) dependencies and github actions weekly, with grouped updates to reduce pr noise. when dependabot finds a vulnerability, it creates a pull request with the fix, links to the security advisory, and shows us the severity level. this automation means we catch security issues quickly without manual monitoring. dependency review: pr-level security checks every pull request that modifies , , or package manifests triggers our dependency review workflow. this action: scans new and updated dependencies for known vulnerabilities fails the pr if high or critical vulnerabilities are found validates licenses against our approved list (mit, apache-2.0, bsd, etc.) posts a summary comment on the pr with findings this prevents vulnerable code from ever reaching our main branch. if a contributor adds a dependency with a known cve, they'll see the failure immediately and can address it before merge. cargo-audit: rust-specific security scanning we run cargo-audit on every push and pull request. this tool checks our against the rustsec advisory database‚Äîa community-maintained database of security vulnerabilities in rust crates. we also use cargo-deny for additional checks on licenses, duplicate dependencies, and source trust validation. security advisories and private reporting github's security advisories feature allows security researchers to report vulnerabilities privately. we document our full vulnerability disclosure process in our security.md file. our response commitments: 48 hours : acknowledgment of report 7 days : initial assessment and severity classification 30 days : target fix for critical vulnerabilities 90 days : target fix for moderate vulnerabilities application-level security safety validation: 52+ dangerous patterns caro's safety module is the heart of our security model. before any command is presented to the user, it passes through our pattern-based validator that checks for: filesystem destruction : , , fork bombs : and variants privilege escalation : , system path tampering : operations on , , device manipulation : direct writes to block devices commands are classified into risk levels: safe , moderate , high , and critical . high-risk commands require explicit confirmation, and critical commands are blocked entirely unless the user opts in with . a real-world lesson: while writing this very blog post, we encountered an unexpected deployment failure. including a fork bomb example in the documentation caused our astro build to fail‚Äîthe parser interpreted the shell syntax as javascript expressions. this incident reinforced an important lesson: even documenting dangerous commands requires careful handling. security awareness must extend beyond runtime validation to every layer of our toolchain. you can see the resolving pr for details. defense in depth we don't rely on a single security control. our defense-in-depth strategy includes: input sanitization : prompts are validated before reaching the model output validation : generated commands are checked against safety patterns user confirmation : commands require explicit approval before execution fail-safe defaults : dangerous operations are blocked by default least privilege : we never encourage running as root development practices ci/cd security pipeline every commit to caro runs through our comprehensive ci pipeline: clippy linting with to catch common mistakes cargo-audit for dependency vulnerabilities cargo-deny for license compliance dependency review for prs touching dependencies cross-platform testing on linux, macos, and windows code review standards all changes to security-sensitive code (safety validation, command execution, model interaction) receive extra scrutiny: security-focused review checklist property-based testing with proptest for edge cases integration tests covering execution paths manual security testing before releases minimal dependencies every dependency is an attack surface. we consciously minimize our dependency tree, carefully evaluate new dependencies, and prefer well-maintained crates with strong security track records. dependencies are pinned in for reproducible builds. community and transparency security hall of fame we maintain a security hall of fame in our security.md to recognize researchers who responsibly disclose vulnerabilities. contributors receive: public acknowledgment in security advisories credit in release notes listing in the hall of fame open development security through obscurity doesn't work. our entire codebase, including the safety validation patterns, is open source. this transparency allows: community review of security implementations external security audits contributions to improve our safety patterns trust through verifiability best practices for users while we build security into caro, users play a role too: always review generated commands before execution never use mode for destructive operations keep caro updated for the latest security fixes limit to specific, understood cases report suspicious behavior through our security advisory process looking ahead security is an ongoing journey, not a destination. we're continuously improving: expanding safety patterns based on community feedback enhancing model output validation for edge cases exploring sandboxed execution for high-risk environments regular security audits as the project matures security is a community effort. if you find a vulnerability, please report it through our github security advisories . together, we can keep caro safe for everyone. resources security.md - full security policy and vulnerability reporting github security tab - report vulnerabilities privately dependabot documentation - learn more about automated updates rustsec advisory database - rust security advisories built with rust | safety first | open source",
      "_words": [
        "security",
        "our",
        "caro",
        "dependency",
        "commands",
        "vulnerabilities",
        "safety",
        "dependencies",
        "review",
        "github",
        "validation",
        "practices",
        "cargo",
        "through",
        "dependabot",
        "advisories",
        "before",
        "rust",
        "patterns",
        "community",
        "users",
        "report",
        "execution",
        "use",
        "updates",
        "checks",
        "level",
        "development",
        "build",
        "tool",
        "shell",
        "advisory",
        "into",
        "user",
        "pull",
        "vulnerability",
        "model",
        "high",
        "critical",
        "audit",
        "hall",
        "fame",
        "automated",
        "dangerous",
        "code",
        "open",
        "database",
        "command",
        "known",
        "request",
        "responsibility",
        "features",
        "specific",
        "reporting",
        "defense",
        "depth",
        "pipeline",
        "transparency",
        "fix",
        "against",
        "source",
        "days",
        "based",
        "operations",
        "risk",
        "safe",
        "testing",
        "cases",
        "isn",
        "afterthought",
        "foundational",
        "everything",
        "cli",
        "generates",
        "executes",
        "take",
        "protect",
        "seriously",
        "matters",
        "scanning",
        "private",
        "application",
        "standards",
        "minimal",
        "best",
        "looking",
        "ahead",
        "resources",
        "built",
        "post",
        "project",
        "monitors",
        "severity",
        "catch",
        "manual",
        "new",
        "updated",
        "licenses",
        "reaching",
        "see"
      ]
    },
    {
      "title": "Why Caro",
      "path": "/blog/why-caro",
      "description": "Why Caro? What makes Caro so special that she deserves to live forever in your terminal? Why should she be digitized for eternity as a command-line tool that runs alongside you every day? The answer l",
      "category": "blog",
      "keywords": [
        "kyaro",
        "caro",
        "your",
        "terminal",
        "her",
        "shiba",
        "work",
        "office",
        "people",
        "always",
        "side",
        "dog",
        "wix",
        "them",
        "companion",
        "story",
        "into",
        "about",
        "life",
        "day",
        "developers",
        "technical",
        "loved",
        "something",
        "back",
        "there",
        "working",
        "world",
        "tool",
        "love",
        "administrators",
        "everyone",
        "thing",
        "give",
        "keeping",
        "safe",
        "fetch",
        "like",
        "portal",
        "eternal",
        "special",
        "one",
        "liked",
        "behind",
        "born",
        "socially",
        "selective",
        "perfect",
        "command",
        "line"
      ],
      "icon": "üìù",
      "content": {
        "headings": [
          "Born into the World of Tech",
          "The Socially Selective Shiba",
          "A Life Lived Side-by-Side with Code",
          "The Perfect Terminal Companion",
          "From Kyaro to Caro",
          "Why She Belongs in Your Terminal"
        ],
        "paragraphs": [
          "Why Caro? What makes Caro so special that she deserves to live forever in your terminal? Why should she be digitized for eternity as a command-line tool that runs alongside you every day? The answer lies in the extraordinary story of Kyaro ‚Äîa very special dog.",
          "Caro is the digitalization of Kyaro (Kyarorain Kadosh), a Shiba Inu who has been living and breathing technology from day one. Born in 2020 during the midst of the COVID pandemic, Kyaro came into this world as a tiny puppy destined to become an office dog. She was brought home by what might be Israel's most workaholic software engineer‚Äîthough perhaps I'm giving myself too much credit.",
          "From her earliest days, Kyaro was a fixture in the office, visiting multiple days a week. She fell in love with Wix and its office spaces‚Äîfirst at Wix Academy, then at the Tel Aviv port location, later at Namaal, and finally at Wix HQ. But more importantly, she fell in love with the people: the geeks, the developers, the system administrators, and everyone in IT.",
          "Kyaro was always the most friendly dog when it came to technical people. She follows in her owner's pawprints‚ÄîI've always liked IT folks too, and my friendship with IT departments across every company I've worked for can attest to that. Same goes for Kyaro: she was universally adored by IT people.",
          "Here's the funny thing about Kyaro: most dogs are friendly, but she's socially selective. She doesn't warm up to every dog she meets, and she's certainly not interested in playing with just any pup. I always thought she was into every Shiba Inu, mirroring my own appreciation for the breed. But after moving to Canada, I learned the truth‚Äîshe's not into every dog, not even every Shiba.",
          "Yet when it comes to humans, especially technical people, programmers, and IT professionals‚Äîyou name it‚ÄîKyaro has always loved them. All of them. Every system department at Wix, all the developers, the DBAs especially‚Äînobody liked her more than the database administrators at Wix. She was their best friend, and they were hers.",
          "When Kyaro wasn't being an office dog, she was always by my side. And what do I do all day, every day? I'm on the computer‚Äîdeveloping something, troubleshooting something, building something. She had to cope with that reality, and she did so with grace.",
          "Some might say it's a good life, others might disagree. It's the only life I could give her, and I tried my best. But one thing is certain: Kyaro was universally loved by IT people, sysadmins, front-end engineers, back-end engineers, database administrators‚Äîeveryone doing software work.",
          "When my spouse was working in the office, we'd take Kyaro along, and she loved it. Everyone there loved her too. I can't speak to whether the IT people at my spouse's office were as smitten with her, but from my experience, she's always had a thing for geeks.",
          "So it's only fitting that she'll be there with developers when they're working side-by-side in their terminals‚Äîkeeping an eye on them, making sure they're not making mistakes, keeping them safe, giving them sound advice, and fetching those commands.",
          "Here's a fun fact about Shibas: they're not retrievers. You can play fetch with them, but they won't just give it back. You throw it, they might get it, but then you need to work for it. It's part of the logic behind Caro in the terminal‚Äîshe behaves like a Shiba. She'll put you to some work, and she has Easter eggs you'll discover along the way.",
          "Give her a try. She's definitely here to help you fetch those models and run inference in Rust, in the fastest way possible. You know she's got the zoomies and just can't wait for you to discover the zoomies in your terminal!",
          "This is the story of Kyaro (the IRL Shiba) becoming Caro (the terminal companion). Like Portal 2's Caroline , who was transformed into GLaDOS to become the eternal guardian of Aperture Science's testing chambers, Kyaro becomes Caro‚Äîyour eternal companion for the terminal. If you're not familiar with the Portal series by Valve , it's a story about loyalty, transformation, and eternal companionship that deeply resonates with Caro's journey.",
          "She's not just a tool. She's not just a CLI. She's a companion with a story, with personality, with a lifetime of love for the people who build technology. She's here to keep you safe, help you work faster, and remind you that even in the most technical of work, there's room for loyalty, warmth, and a little bit of that Shiba sass.",
          "Caro should be in your terminal because she represents something deeper than just another developer tool. She embodies the spirit of companionship in solitary work, the safety that comes from having someone watching your back, and the joy of working alongside someone who understands you.",
          "Every developer who's ever had a pet nearby while coding knows that feeling‚Äîthe comfort of a loyal presence, the occasional distraction that's actually welcome, the reminder that there's a world beyond the screen. Caro brings that same energy to your command line.",
          "She's been trained by her life among developers. She knows the patterns, the dangers, the workflows. She's watched countless hours of terminal work, witnessed the mistakes, celebrated the victories. Now, she's ready to be your companion too.",
          "Welcome to the pack. Caro is here to stay‚Äîin your terminal, by your side, keeping you safe and helping you fetch the perfect commands. Just like a good Shiba, she'll make you work for it, but she'll always have your back.",
          "If you enjoyed this story and want to read more about the journey behind Caro and other technical adventures, check out my personal blog .",
          "Follow Kyaro's adventures on Instagram: @kyaroblackheart üêï"
        ],
        "listItems": []
      },
      "fullText": "Why Caro? What makes Caro so special that she deserves to live forever in your terminal? Why should she be digitized for eternity as a command-line tool that runs alongside you every day? The answer lies in the extraordinary story of Kyaro ‚Äîa very special dog. Born into the World of Tech Caro is the digitalization of Kyaro (Kyarorain Kadosh), a Shiba Inu who has been living and breathing technology from day one. Born in 2020 during the midst of the COVID pandemic, Kyaro came into this world as a tiny puppy destined to become an office dog. She was brought home by what might be Israel's most workaholic software engineer‚Äîthough perhaps I'm giving myself too much credit. From her earliest days, Kyaro was a fixture in the office, visiting multiple days a week. She fell in love with Wix and its office spaces‚Äîfirst at Wix Academy, then at the Tel Aviv port location, later at Namaal, and finally at Wix HQ. But more importantly, she fell in love with the people: the geeks, the developers, the system administrators, and everyone in IT. Kyaro was always the most friendly dog when it came to technical people. She follows in her owner's pawprints‚ÄîI've always liked IT folks too, and my friendship with IT departments across every company I've worked for can attest to that. Same goes for Kyaro: she was universally adored by IT people. The Socially Selective Shiba Here's the funny thing about Kyaro: most dogs are friendly, but she's socially selective. She doesn't warm up to every dog she meets, and she's certainly not interested in playing with just any pup. I always thought she was into every Shiba Inu, mirroring my own appreciation for the breed. But after moving to Canada, I learned the truth‚Äîshe's not into every dog, not even every Shiba. Yet when it comes to humans, especially technical people, programmers, and IT professionals‚Äîyou name it‚ÄîKyaro has always loved them. All of them. Every system department at Wix, all the developers, the DBAs especially‚Äînobody liked her more than the database administrators at Wix. She was their best friend, and they were hers. A Life Lived Side-by-Side with Code When Kyaro wasn't being an office dog, she was always by my side. And what do I do all day, every day? I'm on the computer‚Äîdeveloping something, troubleshooting something, building something. She had to cope with that reality, and she did so with grace. Some might say it's a good life, others might disagree. It's the only life I could give her, and I tried my best. But one thing is certain: Kyaro was universally loved by IT people, sysadmins, front-end engineers, back-end engineers, database administrators‚Äîeveryone doing software work. The DBAs at Wix had a special bond with her. I don't know about other workplaces because she only worked with me in the office at Wix. Since 2023, I've been working remotely from Canada, so she hasn't been going to the office much. It's one of the things I'm a bit sad about‚Äîshe really liked going to the office. When my spouse was working in the office, we'd take Kyaro along, and she loved it. Everyone there loved her too. I can't speak to whether the IT people at my spouse's office were as smitten with her, but from my experience, she's always had a thing for geeks. The Perfect Terminal Companion So it's only fitting that she'll be there with developers when they're working side-by-side in their terminals‚Äîkeeping an eye on them, making sure they're not making mistakes, keeping them safe, giving them sound advice, and fetching those commands. Here's a fun fact about Shibas: they're not retrievers. You can play fetch with them, but they won't just give it back. You throw it, they might get it, but then you need to work for it. It's part of the logic behind Caro in the terminal‚Äîshe behaves like a Shiba. She'll put you to some work, and she has Easter eggs you'll discover along the way. Give her a try. She's definitely here to help you fetch those models and run inference in Rust, in the fastest way possible. You know she's got the zoomies and just can't wait for you to discover the zoomies in your terminal! From Kyaro to Caro This is the story of Kyaro (the IRL Shiba) becoming Caro (the terminal companion). Like Portal 2's Caroline , who was transformed into GLaDOS to become the eternal guardian of Aperture Science's testing chambers, Kyaro becomes Caro‚Äîyour eternal companion for the terminal. If you're not familiar with the Portal series by Valve , it's a story about loyalty, transformation, and eternal companionship that deeply resonates with Caro's journey. She's not just a tool. She's not just a CLI. She's a companion with a story, with personality, with a lifetime of love for the people who build technology. She's here to keep you safe, help you work faster, and remind you that even in the most technical of work, there's room for loyalty, warmth, and a little bit of that Shiba sass. Why She Belongs in Your Terminal Caro should be in your terminal because she represents something deeper than just another developer tool. She embodies the spirit of companionship in solitary work, the safety that comes from having someone watching your back, and the joy of working alongside someone who understands you. Every developer who's ever had a pet nearby while coding knows that feeling‚Äîthe comfort of a loyal presence, the occasional distraction that's actually welcome, the reminder that there's a world beyond the screen. Caro brings that same energy to your command line. She's been trained by her life among developers. She knows the patterns, the dangers, the workflows. She's watched countless hours of terminal work, witnessed the mistakes, celebrated the victories. Now, she's ready to be your companion too. Welcome to the pack. Caro is here to stay‚Äîin your terminal, by your side, keeping you safe and helping you fetch the perfect commands. Just like a good Shiba, she'll make you work for it, but she'll always have your back. If you enjoyed this story and want to read more about the journey behind Caro and other technical adventures, check out my personal blog . Follow Kyaro's adventures on Instagram: @kyaroblackheart üêï",
      "_searchText": "why caro why caro? what makes caro so special that she deserves to live forever in your terminal? why should she be digitized for eternity as a command-line tool that runs alongside you every day? the answer l /blog/why-caro kyaro caro your terminal her shiba work office people always side dog wix them companion story into about life day developers technical loved something back there working world tool love administrators everyone thing give keeping safe fetch like portal eternal special one liked behind born socially selective perfect command line born into the world of tech the socially selective shiba a life lived side-by-side with code the perfect terminal companion from kyaro to caro why she belongs in your terminal why caro? what makes caro so special that she deserves to live forever in your terminal? why should she be digitized for eternity as a command-line tool that runs alongside you every day? the answer lies in the extraordinary story of kyaro ‚Äîa very special dog. caro is the digitalization of kyaro (kyarorain kadosh), a shiba inu who has been living and breathing technology from day one. born in 2020 during the midst of the covid pandemic, kyaro came into this world as a tiny puppy destined to become an office dog. she was brought home by what might be israel's most workaholic software engineer‚Äîthough perhaps i'm giving myself too much credit. from her earliest days, kyaro was a fixture in the office, visiting multiple days a week. she fell in love with wix and its office spaces‚Äîfirst at wix academy, then at the tel aviv port location, later at namaal, and finally at wix hq. but more importantly, she fell in love with the people: the geeks, the developers, the system administrators, and everyone in it. kyaro was always the most friendly dog when it came to technical people. she follows in her owner's pawprints‚Äîi've always liked it folks too, and my friendship with it departments across every company i've worked for can attest to that. same goes for kyaro: she was universally adored by it people. here's the funny thing about kyaro: most dogs are friendly, but she's socially selective. she doesn't warm up to every dog she meets, and she's certainly not interested in playing with just any pup. i always thought she was into every shiba inu, mirroring my own appreciation for the breed. but after moving to canada, i learned the truth‚Äîshe's not into every dog, not even every shiba. yet when it comes to humans, especially technical people, programmers, and it professionals‚Äîyou name it‚Äîkyaro has always loved them. all of them. every system department at wix, all the developers, the dbas especially‚Äînobody liked her more than the database administrators at wix. she was their best friend, and they were hers. when kyaro wasn't being an office dog, she was always by my side. and what do i do all day, every day? i'm on the computer‚Äîdeveloping something, troubleshooting something, building something. she had to cope with that reality, and she did so with grace. some might say it's a good life, others might disagree. it's the only life i could give her, and i tried my best. but one thing is certain: kyaro was universally loved by it people, sysadmins, front-end engineers, back-end engineers, database administrators‚Äîeveryone doing software work. when my spouse was working in the office, we'd take kyaro along, and she loved it. everyone there loved her too. i can't speak to whether the it people at my spouse's office were as smitten with her, but from my experience, she's always had a thing for geeks. so it's only fitting that she'll be there with developers when they're working side-by-side in their terminals‚Äîkeeping an eye on them, making sure they're not making mistakes, keeping them safe, giving them sound advice, and fetching those commands. here's a fun fact about shibas: they're not retrievers. you can play fetch with them, but they won't just give it back. you throw it, they might get it, but then you need to work for it. it's part of the logic behind caro in the terminal‚Äîshe behaves like a shiba. she'll put you to some work, and she has easter eggs you'll discover along the way. give her a try. she's definitely here to help you fetch those models and run inference in rust, in the fastest way possible. you know she's got the zoomies and just can't wait for you to discover the zoomies in your terminal! this is the story of kyaro (the irl shiba) becoming caro (the terminal companion). like portal 2's caroline , who was transformed into glados to become the eternal guardian of aperture science's testing chambers, kyaro becomes caro‚Äîyour eternal companion for the terminal. if you're not familiar with the portal series by valve , it's a story about loyalty, transformation, and eternal companionship that deeply resonates with caro's journey. she's not just a tool. she's not just a cli. she's a companion with a story, with personality, with a lifetime of love for the people who build technology. she's here to keep you safe, help you work faster, and remind you that even in the most technical of work, there's room for loyalty, warmth, and a little bit of that shiba sass. caro should be in your terminal because she represents something deeper than just another developer tool. she embodies the spirit of companionship in solitary work, the safety that comes from having someone watching your back, and the joy of working alongside someone who understands you. every developer who's ever had a pet nearby while coding knows that feeling‚Äîthe comfort of a loyal presence, the occasional distraction that's actually welcome, the reminder that there's a world beyond the screen. caro brings that same energy to your command line. she's been trained by her life among developers. she knows the patterns, the dangers, the workflows. she's watched countless hours of terminal work, witnessed the mistakes, celebrated the victories. now, she's ready to be your companion too. welcome to the pack. caro is here to stay‚Äîin your terminal, by your side, keeping you safe and helping you fetch the perfect commands. just like a good shiba, she'll make you work for it, but she'll always have your back. if you enjoyed this story and want to read more about the journey behind caro and other technical adventures, check out my personal blog . follow kyaro's adventures on instagram: @kyaroblackheart üêï why caro? what makes caro so special that she deserves to live forever in your terminal? why should she be digitized for eternity as a command-line tool that runs alongside you every day? the answer lies in the extraordinary story of kyaro ‚Äîa very special dog. born into the world of tech caro is the digitalization of kyaro (kyarorain kadosh), a shiba inu who has been living and breathing technology from day one. born in 2020 during the midst of the covid pandemic, kyaro came into this world as a tiny puppy destined to become an office dog. she was brought home by what might be israel's most workaholic software engineer‚Äîthough perhaps i'm giving myself too much credit. from her earliest days, kyaro was a fixture in the office, visiting multiple days a week. she fell in love with wix and its office spaces‚Äîfirst at wix academy, then at the tel aviv port location, later at namaal, and finally at wix hq. but more importantly, she fell in love with the people: the geeks, the developers, the system administrators, and everyone in it. kyaro was always the most friendly dog when it came to technical people. she follows in her owner's pawprints‚Äîi've always liked it folks too, and my friendship with it departments across every company i've worked for can attest to that. same goes for kyaro: she was universally adored by it people. the socially selective shiba here's the funny thing about kyaro: most dogs are friendly, but she's socially selective. she doesn't warm up to every dog she meets, and she's certainly not interested in playing with just any pup. i always thought she was into every shiba inu, mirroring my own appreciation for the breed. but after moving to canada, i learned the truth‚Äîshe's not into every dog, not even every shiba. yet when it comes to humans, especially technical people, programmers, and it professionals‚Äîyou name it‚Äîkyaro has always loved them. all of them. every system department at wix, all the developers, the dbas especially‚Äînobody liked her more than the database administrators at wix. she was their best friend, and they were hers. a life lived side-by-side with code when kyaro wasn't being an office dog, she was always by my side. and what do i do all day, every day? i'm on the computer‚Äîdeveloping something, troubleshooting something, building something. she had to cope with that reality, and she did so with grace. some might say it's a good life, others might disagree. it's the only life i could give her, and i tried my best. but one thing is certain: kyaro was universally loved by it people, sysadmins, front-end engineers, back-end engineers, database administrators‚Äîeveryone doing software work. the dbas at wix had a special bond with her. i don't know about other workplaces because she only worked with me in the office at wix. since 2023, i've been working remotely from canada, so she hasn't been going to the office much. it's one of the things i'm a bit sad about‚Äîshe really liked going to the office. when my spouse was working in the office, we'd take kyaro along, and she loved it. everyone there loved her too. i can't speak to whether the it people at my spouse's office were as smitten with her, but from my experience, she's always had a thing for geeks. the perfect terminal companion so it's only fitting that she'll be there with developers when they're working side-by-side in their terminals‚Äîkeeping an eye on them, making sure they're not making mistakes, keeping them safe, giving them sound advice, and fetching those commands. here's a fun fact about shibas: they're not retrievers. you can play fetch with them, but they won't just give it back. you throw it, they might get it, but then you need to work for it. it's part of the logic behind caro in the terminal‚Äîshe behaves like a shiba. she'll put you to some work, and she has easter eggs you'll discover along the way. give her a try. she's definitely here to help you fetch those models and run inference in rust, in the fastest way possible. you know she's got the zoomies and just can't wait for you to discover the zoomies in your terminal! from kyaro to caro this is the story of kyaro (the irl shiba) becoming caro (the terminal companion). like portal 2's caroline , who was transformed into glados to become the eternal guardian of aperture science's testing chambers, kyaro becomes caro‚Äîyour eternal companion for the terminal. if you're not familiar with the portal series by valve , it's a story about loyalty, transformation, and eternal companionship that deeply resonates with caro's journey. she's not just a tool. she's not just a cli. she's a companion with a story, with personality, with a lifetime of love for the people who build technology. she's here to keep you safe, help you work faster, and remind you that even in the most technical of work, there's room for loyalty, warmth, and a little bit of that shiba sass. why she belongs in your terminal caro should be in your terminal because she represents something deeper than just another developer tool. she embodies the spirit of companionship in solitary work, the safety that comes from having someone watching your back, and the joy of working alongside someone who understands you. every developer who's ever had a pet nearby while coding knows that feeling‚Äîthe comfort of a loyal presence, the occasional distraction that's actually welcome, the reminder that there's a world beyond the screen. caro brings that same energy to your command line. she's been trained by her life among developers. she knows the patterns, the dangers, the workflows. she's watched countless hours of terminal work, witnessed the mistakes, celebrated the victories. now, she's ready to be your companion too. welcome to the pack. caro is here to stay‚Äîin your terminal, by your side, keeping you safe and helping you fetch the perfect commands. just like a good shiba, she'll make you work for it, but she'll always have your back. if you enjoyed this story and want to read more about the journey behind caro and other technical adventures, check out my personal blog . follow kyaro's adventures on instagram: @kyaroblackheart üêï",
      "_words": [
        "caro",
        "kyaro",
        "your",
        "terminal",
        "her",
        "shiba",
        "office",
        "work",
        "side",
        "people",
        "always",
        "wix",
        "dog",
        "them",
        "companion",
        "into",
        "about",
        "day",
        "story",
        "life",
        "special",
        "tool",
        "developers",
        "technical",
        "loved",
        "something",
        "back",
        "there",
        "working",
        "world",
        "command",
        "line",
        "love",
        "administrators",
        "everyone",
        "thing",
        "give",
        "keeping",
        "safe",
        "fetch",
        "like",
        "eternal",
        "one",
        "liked",
        "born",
        "socially",
        "selective",
        "perfect",
        "alongside",
        "portal",
        "behind",
        "makes",
        "deserves",
        "live",
        "forever",
        "digitized",
        "eternity",
        "runs",
        "answer",
        "tech",
        "lived",
        "code",
        "belongs",
        "inu",
        "technology",
        "came",
        "become",
        "software",
        "giving",
        "much",
        "days",
        "fell",
        "then",
        "geeks",
        "system",
        "friendly",
        "worked",
        "universally",
        "canada",
        "even",
        "comes",
        "especially",
        "dbas",
        "database",
        "their",
        "best",
        "good",
        "end",
        "engineers",
        "know",
        "because",
        "going",
        "bit",
        "spouse",
        "along",
        "making",
        "mistakes",
        "commands",
        "discover",
        "way"
      ]
    },
    {
      "title": "TL;DR",
      "path": "/compare/amazon-q-cli",
      "description": "Amazon Q CLI is built for AWS users and requires an AWS account. Your prompts and context are sent to AWS for processing, and the tool is optimized for AWS-specific workflows.",
      "category": "compare",
      "keywords": [
        "aws",
        "your",
        "amazon",
        "cli",
        "caro",
        "context",
        "commands",
        "cloud",
        "shell",
        "prompts",
        "processing",
        "tool",
        "specific",
        "machine",
        "local",
        "terminal",
        "policies",
        "their",
        "general",
        "tools",
        "agnostic",
        "model",
        "dangerous",
        "patterns",
        "built",
        "users",
        "requires",
        "account",
        "sent",
        "optimized",
        "workflows",
        "zero",
        "dependency",
        "runs",
        "entirely",
        "models",
        "accounts",
        "api",
        "keys",
        "internet",
        "required",
        "makes",
        "suitable",
        "any",
        "environment",
        "sends",
        "while",
        "enterprise",
        "security",
        "traverse"
      ],
      "icon": "üì¶",
      "content": {
        "headings": [],
        "paragraphs": [
          "Amazon Q CLI is built for AWS users and requires an AWS account. Your prompts and context are sent to AWS for processing, and the tool is optimized for AWS-specific workflows.",
          "Caro has zero cloud dependency. It runs entirely on your machine with local models. No accounts, no API keys, no internet required. This makes it suitable for any environment, not just AWS.",
          "Amazon Q CLI sends your terminal context to AWS for processing. While AWS has enterprise security policies, your shell commands traverse their infrastructure.",
          "Caro processes everything locally. Your commands, prompts, and terminal context never leave your machine. Perfect for organizations with strict data sovereignty requirements or developers who prefer to keep their workflow private.",
          "Amazon Q CLI shines with AWS-specific tasks: understanding IAM policies, CloudWatch logs, ECS deployments, and other AWS services. If you're deep in the AWS ecosystem, it has context that general tools lack.",
          "Caro specializes in general shell commands with POSIX compliance and cross-platform support. It's cloud-agnostic and works equally well whether you're on AWS, GCP, Azure, or bare metal.",
          "Amazon Q CLI relies on its model to generate safe commands. There's no systematic pre-execution validation layer for dangerous patterns.",
          "Caro validates every command against 52+ safety patterns before presenting it. Dangerous operations like , fork bombs, and privilege escalations are blocked independently of what the model suggests."
        ],
        "listItems": []
      },
      "fullText": "",
      "_searchText": "tl;dr amazon q cli is built for aws users and requires an aws account. your prompts and context are sent to aws for processing, and the tool is optimized for aws-specific workflows. /compare/amazon-q-cli aws your amazon cli caro context commands cloud shell prompts processing tool specific machine local terminal policies their general tools agnostic model dangerous patterns built users requires account sent optimized workflows zero dependency runs entirely models accounts api keys internet required makes suitable any environment sends while enterprise security traverse amazon q cli is built for aws users and requires an aws account. your prompts and context are sent to aws for processing, and the tool is optimized for aws-specific workflows. caro has zero cloud dependency. it runs entirely on your machine with local models. no accounts, no api keys, no internet required. this makes it suitable for any environment, not just aws. amazon q cli sends your terminal context to aws for processing. while aws has enterprise security policies, your shell commands traverse their infrastructure. caro processes everything locally. your commands, prompts, and terminal context never leave your machine. perfect for organizations with strict data sovereignty requirements or developers who prefer to keep their workflow private. amazon q cli shines with aws-specific tasks: understanding iam policies, cloudwatch logs, ecs deployments, and other aws services. if you're deep in the aws ecosystem, it has context that general tools lack. caro specializes in general shell commands with posix compliance and cross-platform support. it's cloud-agnostic and works equally well whether you're on aws, gcp, azure, or bare metal. amazon q cli relies on its model to generate safe commands. there's no systematic pre-execution validation layer for dangerous patterns. caro validates every command against 52+ safety patterns before presenting it. dangerous operations like , fork bombs, and privilege escalations are blocked independently of what the model suggests. ",
      "_words": [
        "aws",
        "amazon",
        "cli",
        "built",
        "users",
        "requires",
        "account",
        "your",
        "prompts",
        "context",
        "sent",
        "processing",
        "tool",
        "optimized",
        "specific",
        "workflows",
        "caro",
        "commands",
        "cloud",
        "shell",
        "machine",
        "local",
        "terminal",
        "policies",
        "their",
        "general",
        "tools",
        "agnostic",
        "model",
        "dangerous",
        "patterns",
        "zero",
        "dependency",
        "runs",
        "entirely",
        "models",
        "accounts",
        "api",
        "keys",
        "internet",
        "required",
        "makes",
        "suitable",
        "any",
        "environment",
        "sends",
        "while",
        "enterprise",
        "security",
        "traverse"
      ]
    },
    {
      "title": "TL;DR",
      "path": "/compare/github-copilot-cli",
      "description": "GitHub Copilot CLI extends the popular Copilot experience to the command line, powered by OpenAI\\",
      "category": "compare",
      "keywords": [
        "github",
        "copilot",
        "caro",
        "cli",
        "your",
        "models",
        "shell",
        "commands",
        "local",
        "model",
        "openai",
        "operations",
        "command",
        "powered",
        "prompts",
        "while",
        "privacy",
        "terminal",
        "suggestions",
        "validation",
        "layer",
        "dangerous",
        "patterns",
        "like",
        "system",
        "cloud",
        "already",
        "using",
        "still",
        "try",
        "offline",
        "scenarios",
        "extends",
        "popular",
        "experience",
        "line",
        "sends",
        "servers",
        "processed",
        "policies",
        "place",
        "including",
        "potentially",
        "sensitive",
        "paths",
        "server",
        "names",
        "traverse",
        "internet",
        "runs"
      ],
      "icon": "üêô",
      "content": {
        "headings": [],
        "paragraphs": [
          "GitHub Copilot CLI sends your prompts to GitHub's servers, where they're processed by OpenAI's models. While GitHub has privacy policies in place, your shell commands - including potentially sensitive paths, server names, and operations - traverse the internet.",
          "Caro runs entirely on your machine. With local model inference, your commands, prompts, and terminal context never leave your computer. This makes Caro suitable for air-gapped environments, compliance-restricted organizations, and developers who simply prefer to keep their terminal activity private.",
          "GitHub Copilot CLI relies on the underlying language model to generate \"safe\" suggestions. There's no systematic validation layer - the model might or might not catch dangerous patterns like .",
          "Caro has 52+ predefined safety patterns that validate every command before presenting it to you. Dangerous operations like recursive deletions, fork bombs, and system-breaking commands are blocked at the validation layer - independent of what the model suggests.",
          "GitHub Copilot CLI requires a GitHub Copilot subscription ($10-19/month for individuals, more for enterprises). You're also dependent on GitHub's service availability.",
          "Caro is completely free and open source. You run it on your hardware with your own models. No accounts, no subscriptions, no vendor lock-in.",
          "GitHub Copilot CLI has access to powerful OpenAI models (GPT-4 class) trained on massive datasets. For complex, novel commands, it may produce better suggestions.",
          "Caro uses local models which, while improving rapidly, may not match the raw capability of cloud giants. However, for common shell operations (finding files, text processing, system administration), local models are often sufficient - and you get the benefit of privacy and speed.",
          "Already using Copilot? You can still try Caro for offline scenarios."
        ],
        "listItems": []
      },
      "fullText": "Already using Copilot? You can still try Caro for offline scenarios.",
      "_searchText": "tl;dr github copilot cli extends the popular copilot experience to the command line, powered by openai\\ /compare/github-copilot-cli github copilot caro cli your models shell commands local model openai operations command powered prompts while privacy terminal suggestions validation layer dangerous patterns like system cloud already using still try offline scenarios extends popular experience line sends servers processed policies place including potentially sensitive paths server names traverse internet runs github copilot cli sends your prompts to github's servers, where they're processed by openai's models. while github has privacy policies in place, your shell commands - including potentially sensitive paths, server names, and operations - traverse the internet. caro runs entirely on your machine. with local model inference, your commands, prompts, and terminal context never leave your computer. this makes caro suitable for air-gapped environments, compliance-restricted organizations, and developers who simply prefer to keep their terminal activity private. github copilot cli relies on the underlying language model to generate \"safe\" suggestions. there's no systematic validation layer - the model might or might not catch dangerous patterns like . caro has 52+ predefined safety patterns that validate every command before presenting it to you. dangerous operations like recursive deletions, fork bombs, and system-breaking commands are blocked at the validation layer - independent of what the model suggests. github copilot cli requires a github copilot subscription ($10-19/month for individuals, more for enterprises). you're also dependent on github's service availability. caro is completely free and open source. you run it on your hardware with your own models. no accounts, no subscriptions, no vendor lock-in. github copilot cli has access to powerful openai models (gpt-4 class) trained on massive datasets. for complex, novel commands, it may produce better suggestions. caro uses local models which, while improving rapidly, may not match the raw capability of cloud giants. however, for common shell operations (finding files, text processing, system administration), local models are often sufficient - and you get the benefit of privacy and speed. already using copilot? you can still try caro for offline scenarios. already using copilot? you can still try caro for offline scenarios.",
      "_words": [
        "copilot",
        "github",
        "cli",
        "extends",
        "popular",
        "experience",
        "command",
        "line",
        "powered",
        "openai",
        "caro",
        "already",
        "using",
        "still",
        "try",
        "offline",
        "scenarios",
        "your",
        "models",
        "shell",
        "commands",
        "local",
        "model",
        "operations",
        "prompts",
        "while",
        "privacy",
        "terminal",
        "suggestions",
        "validation",
        "layer",
        "dangerous",
        "patterns",
        "like",
        "system",
        "cloud",
        "sends",
        "servers",
        "processed",
        "policies",
        "place",
        "including",
        "potentially",
        "sensitive",
        "paths",
        "server",
        "names",
        "traverse",
        "internet",
        "runs"
      ]
    },
    {
      "title": "Compare",
      "path": "/compare",
      "description": "Compare Caro\\",
      "category": "compare",
      "keywords": [
        "caro",
        "first",
        "privacy",
        "your",
        "commands",
        "compare",
        "comparison",
        "feature",
        "safety",
        "shell",
        "alternatives",
        "choose",
        "terminal",
        "developers",
        "work",
        "make",
        "decision",
        "local",
        "based",
        "compliance",
        "works",
        "100",
        "offline",
        "design",
        "patterns",
        "open",
        "source",
        "complete",
        "teams",
        "security",
        "conscious",
        "orgs",
        "sres",
        "afford",
        "mistakes",
        "devops",
        "live",
        "ready",
        "try",
        "informed",
        "see",
        "exactly",
        "focused",
        "approach",
        "compares",
        "cloud",
        "deep",
        "dive",
        "into",
        "stacks"
      ],
      "icon": "‚öñÔ∏è",
      "content": {
        "headings": [
          "Compare Caro to Alternatives",
          "Choose a Comparison",
          "Complete Feature Comparison",
          "Why Teams Choose Caro",
          "üè¢ For Security-Conscious Orgs",
          "üõ°Ô∏è For SREs Who Can't Afford Mistakes",
          "üîß For DevOps Who Live in the Terminal",
          "üåê For Developers Who Work Offline",
          "Ready to Try Caro?"
        ],
        "paragraphs": [
          "Make an informed decision. See exactly how Caro's local-first, safety-focused approach compares to cloud-based alternatives.",
          "Deep-dive into how Caro stacks up against specific tools",
          "Every feature, every tool. Make your own decision.",
          "Air-gapped environments, compliance requirements, or simply not wanting shell commands to leave your network? Caro runs 100% locally with privacy-first design .",
          "Rule-based safety checks catch dangerous commands before they execute. 52+ patterns block rm -rf /, fork bombs, and other destructive operations.",
          "Works in YOUR terminal. No new apps, no context switching. Just shell commands that work across macOS, Linux, and BSD with POSIX compliance.",
          "Airplanes, VPNs, restricted networks. When you can't phone home, Caro still works with local model inference.",
          "Join developers who refuse to sacrifice privacy for productivity.",
          "Open source. No account required. Privacy-first."
        ],
        "listItems": []
      },
      "fullText": "Compare Caro to Alternatives Make an informed decision. See exactly how Caro's local-first, safety-focused approach compares to cloud-based alternatives. üîí Privacy-First* üõ°Ô∏è 52+ Safety Patterns üì° 100% Offline ü¶Ä Open Source Choose a Comparison Deep-dive into how Caro stacks up against specific tools class=\"vs-card\"> vs ‚Üí ))} Complete Feature Comparison Every feature, every tool. Make your own decision. Feature Caro Copilot CLI Warp Amazon Q OpenCode ))} ))} ‚úì Full support ‚óê Partial/varies ‚úó Not supported ‚óé Planned Why Teams Choose Caro üè¢ For Security-Conscious Orgs Air-gapped environments, compliance requirements, or simply not wanting shell commands to leave your network? Caro runs 100% locally with privacy-first design . üõ°Ô∏è For SREs Who Can't Afford Mistakes Rule-based safety checks catch dangerous commands before they execute. 52+ patterns block rm -rf /, fork bombs, and other destructive operations. üîß For DevOps Who Live in the Terminal Works in YOUR terminal. No new apps, no context switching. Just shell commands that work across macOS, Linux, and BSD with POSIX compliance. üåê For Developers Who Work Offline Airplanes, VPNs, restricted networks. When you can't phone home, Caro still works with local model inference. Ready to Try Caro? Join developers who refuse to sacrifice privacy for productivity. Get Started Free View on GitHub Open source. No account required. Privacy-first.",
      "_searchText": "compare compare caro\\ /compare caro first privacy your commands compare comparison feature safety shell alternatives choose terminal developers work make decision local based compliance works 100 offline design patterns open source complete teams security conscious orgs sres afford mistakes devops live ready try informed see exactly focused approach compares cloud deep dive into stacks compare caro to alternatives choose a comparison complete feature comparison why teams choose caro üè¢ for security-conscious orgs üõ°Ô∏è for sres who can't afford mistakes üîß for devops who live in the terminal üåê for developers who work offline ready to try caro? make an informed decision. see exactly how caro's local-first, safety-focused approach compares to cloud-based alternatives. deep-dive into how caro stacks up against specific tools every feature, every tool. make your own decision. air-gapped environments, compliance requirements, or simply not wanting shell commands to leave your network? caro runs 100% locally with privacy-first design . rule-based safety checks catch dangerous commands before they execute. 52+ patterns block rm -rf /, fork bombs, and other destructive operations. works in your terminal. no new apps, no context switching. just shell commands that work across macos, linux, and bsd with posix compliance. airplanes, vpns, restricted networks. when you can't phone home, caro still works with local model inference. join developers who refuse to sacrifice privacy for productivity. open source. no account required. privacy-first. compare caro to alternatives make an informed decision. see exactly how caro's local-first, safety-focused approach compares to cloud-based alternatives. üîí privacy-first* üõ°Ô∏è 52+ safety patterns üì° 100% offline ü¶Ä open source choose a comparison deep-dive into how caro stacks up against specific tools class=\"vs-card\"> vs ‚Üí ))} complete feature comparison every feature, every tool. make your own decision. feature caro copilot cli warp amazon q opencode ))} ))} ‚úì full support ‚óê partial/varies ‚úó not supported ‚óé planned why teams choose caro üè¢ for security-conscious orgs air-gapped environments, compliance requirements, or simply not wanting shell commands to leave your network? caro runs 100% locally with privacy-first design . üõ°Ô∏è for sres who can't afford mistakes rule-based safety checks catch dangerous commands before they execute. 52+ patterns block rm -rf /, fork bombs, and other destructive operations. üîß for devops who live in the terminal works in your terminal. no new apps, no context switching. just shell commands that work across macos, linux, and bsd with posix compliance. üåê for developers who work offline airplanes, vpns, restricted networks. when you can't phone home, caro still works with local model inference. ready to try caro? join developers who refuse to sacrifice privacy for productivity. get started free view on github open source. no account required. privacy-first.",
      "_words": [
        "caro",
        "compare",
        "first",
        "privacy",
        "comparison",
        "feature",
        "choose",
        "your",
        "commands",
        "safety",
        "alternatives",
        "terminal",
        "developers",
        "work",
        "offline",
        "100",
        "shell",
        "make",
        "decision",
        "local",
        "based",
        "compliance",
        "works",
        "patterns",
        "open",
        "source",
        "complete",
        "teams",
        "security",
        "conscious",
        "orgs",
        "sres",
        "afford",
        "mistakes",
        "devops",
        "live",
        "ready",
        "try",
        "design",
        "informed",
        "see",
        "exactly",
        "focused",
        "approach",
        "compares",
        "cloud",
        "deep",
        "dive",
        "into",
        "stacks",
        "against",
        "specific",
        "tools",
        "class",
        "card",
        "tool",
        "copilot",
        "cli",
        "warp",
        "amazon",
        "opencode",
        "full",
        "support",
        "partial",
        "varies",
        "supported",
        "planned",
        "air",
        "gapped",
        "environments",
        "requirements",
        "simply",
        "wanting",
        "leave",
        "network",
        "runs",
        "locally",
        "rule",
        "checks",
        "catch",
        "dangerous",
        "before",
        "execute",
        "block",
        "fork",
        "bombs",
        "destructive",
        "operations",
        "new",
        "apps",
        "context",
        "switching",
        "across",
        "macos",
        "linux",
        "bsd",
        "posix",
        "airplanes",
        "vpns",
        "restricted"
      ]
    },
    {
      "title": "TL;DR",
      "path": "/compare/opencode",
      "description": "OpenCode is a general-purpose AI coding agent. It can edit files, refactor code, explain codebases, and run terminal commands. It's designed to be a comprehensive coding assistant.",
      "category": "compare",
      "keywords": [
        "caro",
        "opencode",
        "coding",
        "commands",
        "shell",
        "safety",
        "general",
        "agent",
        "designed",
        "specialized",
        "tools",
        "files",
        "code",
        "assistant",
        "well",
        "guarantees",
        "without",
        "before",
        "patterns",
        "command",
        "use",
        "companion",
        "local",
        "model",
        "internet",
        "purpose",
        "edit",
        "refactor",
        "explain",
        "codebases",
        "run",
        "terminal",
        "comprehensive",
        "intentionally",
        "one",
        "thing",
        "helping",
        "remember",
        "safely",
        "execute",
        "sub",
        "full",
        "focus",
        "allows",
        "deeper",
        "expertise",
        "workflows",
        "stronger",
        "generates",
        "systematic"
      ],
      "icon": "‚öñÔ∏è",
      "content": {
        "headings": [],
        "paragraphs": [
          "OpenCode is a general-purpose AI coding agent. It can edit files, refactor code, explain codebases, and run terminal commands. It's designed to be a comprehensive coding assistant.",
          "Caro intentionally does one thing well: helping you remember and safely execute shell commands. It's a specialized sub-agent, not a full coding assistant. This focus allows for deeper expertise in shell workflows and stronger safety guarantees.",
          "OpenCode generates commands without systematic pre-execution validation. While you can review commands before running them, there's no dedicated layer that catches dangerous patterns.",
          "Caro validates every command against 52+ predefined safety patterns. Commands like , fork bombs, and system-breaking operations are blocked before they're ever shown to you. Safety isn't optional‚Äîit's built into the core.",
          "These tools can work together! Use OpenCode for general coding tasks‚Äîediting files, explaining code, refactoring. When you need shell command help with safety guarantees, reach for Caro .",
          "Caro is designed to be a focused companion, not a replacement for broader tools. Its lightweight, specialized nature makes it easy to add to any workflow without overlap.",
          "OpenCode supports local operation with various model backends, though some configurations may require internet for model downloads or API calls.",
          "Caro is designed offline-first from the ground up. Once you have local models configured, it never needs internet. Perfect for air-gapped environments, flights, or restrictive networks."
        ],
        "listItems": []
      },
      "fullText": "",
      "_searchText": "tl;dr opencode is a general-purpose ai coding agent. it can edit files, refactor code, explain codebases, and run terminal commands. it's designed to be a comprehensive coding assistant. /compare/opencode caro opencode coding commands shell safety general agent designed specialized tools files code assistant well guarantees without before patterns command use companion local model internet purpose edit refactor explain codebases run terminal comprehensive intentionally one thing helping remember safely execute sub full focus allows deeper expertise workflows stronger generates systematic opencode is a general-purpose ai coding agent. it can edit files, refactor code, explain codebases, and run terminal commands. it's designed to be a comprehensive coding assistant. caro intentionally does one thing well: helping you remember and safely execute shell commands. it's a specialized sub-agent, not a full coding assistant. this focus allows for deeper expertise in shell workflows and stronger safety guarantees. opencode generates commands without systematic pre-execution validation. while you can review commands before running them, there's no dedicated layer that catches dangerous patterns. caro validates every command against 52+ predefined safety patterns. commands like , fork bombs, and system-breaking operations are blocked before they're ever shown to you. safety isn't optional‚Äîit's built into the core. these tools can work together! use opencode for general coding tasks‚Äîediting files, explaining code, refactoring. when you need shell command help with safety guarantees, reach for caro . caro is designed to be a focused companion, not a replacement for broader tools. its lightweight, specialized nature makes it easy to add to any workflow without overlap. opencode supports local operation with various model backends, though some configurations may require internet for model downloads or api calls. caro is designed offline-first from the ground up. once you have local models configured, it never needs internet. perfect for air-gapped environments, flights, or restrictive networks. ",
      "_words": [
        "coding",
        "opencode",
        "general",
        "purpose",
        "agent",
        "edit",
        "files",
        "refactor",
        "code",
        "explain",
        "codebases",
        "run",
        "terminal",
        "commands",
        "designed",
        "comprehensive",
        "assistant",
        "caro",
        "shell",
        "safety",
        "specialized",
        "tools",
        "well",
        "guarantees",
        "without",
        "before",
        "patterns",
        "command",
        "use",
        "companion",
        "local",
        "model",
        "internet",
        "intentionally",
        "one",
        "thing",
        "helping",
        "remember",
        "safely",
        "execute",
        "sub",
        "full",
        "focus",
        "allows",
        "deeper",
        "expertise",
        "workflows",
        "stronger",
        "generates",
        "systematic"
      ]
    },
    {
      "title": "TL;DR",
      "path": "/compare/warp",
      "description": "Warp is a completely new terminal emulator built from scratch with AI capabilities baked in. It requires you to switch from your current terminal (iTerm2, Terminal.app, Alacritty, etc.) to Warp.",
      "category": "compare",
      "keywords": [
        "terminal",
        "warp",
        "your",
        "caro",
        "commands",
        "new",
        "current",
        "command",
        "capabilities",
        "requires",
        "app",
        "existing",
        "shell",
        "telemetry",
        "privacy",
        "feature",
        "doesn",
        "without",
        "safety",
        "model",
        "completely",
        "emulator",
        "built",
        "scratch",
        "baked",
        "switch",
        "iterm2",
        "alacritty",
        "etc",
        "companion",
        "agent",
        "works",
        "switching",
        "learn",
        "config",
        "migration",
        "assistance",
        "integrates",
        "into",
        "workflow",
        "cloud",
        "connectivity",
        "features",
        "prompts",
        "sent",
        "servers",
        "processing",
        "collects",
        "data",
        "default"
      ],
      "icon": "üöÄ",
      "content": {
        "headings": [],
        "paragraphs": [
          "Warp is a completely new terminal emulator built from scratch with AI capabilities baked in. It requires you to switch from your current terminal (iTerm2, Terminal.app, Alacritty, etc.) to Warp.",
          "Caro is a companion agent that works with your existing terminal. No app switching, no new UI to learn, no config migration. Just shell command assistance that integrates into your current workflow.",
          "Warp requires cloud connectivity for its AI features. Your prompts are sent to Warp's servers for processing. Warp also collects telemetry data by default (though it can be disabled).",
          "Caro runs entirely locally. AI inference happens on your machine with local models. No internet required, privacy-first design with minimal anonymous telemetry. Perfect for air-gapped environments or privacy-conscious users.",
          "Warp offers a rich feature set: modern text editing in terminal, command blocks, notebook-style outputs, team workflows, and more. It's a full terminal replacement with many capabilities.",
          "Caro intentionally does one thing well: help you remember shell commands safely. It's lightweight, focused, and doesn't try to reinvent the terminal. If you love your current terminal, Caro enhances it without replacing it.",
          "Warp relies on AI to generate commands without systematic safety validation. Dangerous commands can still be suggested if the model doesn't catch them.",
          "Caro validates every command against 52+ safety patterns before presenting it. Commands like , fork bombs, and system-breaking operations are blocked regardless of what the model suggests."
        ],
        "listItems": []
      },
      "fullText": "",
      "_searchText": "tl;dr warp is a completely new terminal emulator built from scratch with ai capabilities baked in. it requires you to switch from your current terminal (iterm2, terminal.app, alacritty, etc.) to warp. /compare/warp terminal warp your caro commands new current command capabilities requires app existing shell telemetry privacy feature doesn without safety model completely emulator built scratch baked switch iterm2 alacritty etc companion agent works switching learn config migration assistance integrates into workflow cloud connectivity features prompts sent servers processing collects data default warp is a completely new terminal emulator built from scratch with ai capabilities baked in. it requires you to switch from your current terminal (iterm2, terminal.app, alacritty, etc.) to warp. caro is a companion agent that works with your existing terminal. no app switching, no new ui to learn, no config migration. just shell command assistance that integrates into your current workflow. warp requires cloud connectivity for its ai features. your prompts are sent to warp's servers for processing. warp also collects telemetry data by default (though it can be disabled). caro runs entirely locally. ai inference happens on your machine with local models. no internet required, privacy-first design with minimal anonymous telemetry. perfect for air-gapped environments or privacy-conscious users. warp offers a rich feature set: modern text editing in terminal, command blocks, notebook-style outputs, team workflows, and more. it's a full terminal replacement with many capabilities. caro intentionally does one thing well: help you remember shell commands safely. it's lightweight, focused, and doesn't try to reinvent the terminal. if you love your current terminal, caro enhances it without replacing it. warp relies on ai to generate commands without systematic safety validation. dangerous commands can still be suggested if the model doesn't catch them. caro validates every command against 52+ safety patterns before presenting it. commands like , fork bombs, and system-breaking operations are blocked regardless of what the model suggests. ",
      "_words": [
        "terminal",
        "warp",
        "completely",
        "new",
        "emulator",
        "built",
        "scratch",
        "capabilities",
        "baked",
        "requires",
        "switch",
        "your",
        "current",
        "iterm2",
        "app",
        "alacritty",
        "etc",
        "caro",
        "commands",
        "command",
        "existing",
        "shell",
        "telemetry",
        "privacy",
        "feature",
        "doesn",
        "without",
        "safety",
        "model",
        "companion",
        "agent",
        "works",
        "switching",
        "learn",
        "config",
        "migration",
        "assistance",
        "integrates",
        "into",
        "workflow",
        "cloud",
        "connectivity",
        "features",
        "prompts",
        "sent",
        "servers",
        "processing",
        "collects",
        "data",
        "default"
      ]
    },
    {
      "title": "Credits",
      "path": "/credits",
      "description": "A LONG TIME AGO IN AN OPEN SOURCE ECOSYSTEM FAR, FAR AWAY...",
      "category": "main",
      "keywords": [
        "caro",
        "github",
        "open",
        "rust",
        "source",
        "website",
        "ecosystem",
        "code",
        "tokio",
        "astro",
        "work",
        "models",
        "qwen",
        "serde",
        "inference",
        "makes",
        "team",
        "our",
        "async",
        "hugging",
        "face",
        "tracing",
        "framework",
        "downloads",
        "entire",
        "twitter",
        "claude",
        "apple",
        "thank",
        "name",
        "real",
        "without",
        "incredible",
        "possible",
        "machine",
        "friendly",
        "powers",
        "fast",
        "alice",
        "fred",
        "privacy",
        "llama",
        "cpp",
        "mlx",
        "clap",
        "reqwest",
        "confetti",
        "elevator",
        "community",
        "project"
      ],
      "icon": "üôè",
      "content": {
        "headings": [
          "CREDITS",
          "Special Thanks",
          "Anselm Eickhoff",
          "Anthropic & Claude Code",
          "AI & Machine Learning",
          "llama.cpp",
          "Apple MLX",
          "Qwen",
          "Hugging Face",
          "Candle",
          "Rust Ecosystem",
          "Tokio",
          "Serde",
          "Clap",
          "Reqwest",
          "Tracing",
          "Indicatif",
          "Also Powered By",
          "Web Technologies",
          "Astro",
          "Vercel Analytics",
          "canvas-confetti",
          "elevator.js",
          "Inspiration",
          "Portal's Caroline",
          "Kyaro (The Real One!)",
          "Open Source Community",
          "Open Source Licenses",
          "MIT License",
          "MIT OR Apache-2.0",
          "Apache-2.0",
          "MIT",
          "Thank You"
        ],
        "paragraphs": [
          "A LONG TIME AGO IN AN OPEN SOURCE ECOSYSTEM FAR, FAR AWAY...",
          "Standing on the Shoulders of Giants",
          "Caro is an open source project that would not exist without the incredible work of countless developers, maintainers, and communities who have built the foundations we rely on every day. This page is our way of saying thank you to everyone who has contributed to the tools, libraries, and resources that make Caro possible.",
          "For the gift of a name",
          "A heartfelt thank you to @aeplay for graciously transferring the crate name to this project. This act of generosity gave Caro its identity ‚Äî a memorable, friendly name that embodies our mission. \"Work sucks. Play works.\" ‚Äî We couldn't agree more.",
          "GitHub ü§ñ Anthropic & Claude Code The Maintainer's Co-Pilot",
          "Caro was built with the help of Claude Code , Anthropic's agentic coding tool. From architecture decisions to code reviews, debugging sessions to documentation ‚Äî Claude Code has been an indispensable collaborator in bringing Caro to life. A testament to how AI can augment human creativity in open source development.",
          "GitHub Website üß† AI & Machine Learning The brilliant minds and teams building the models and frameworks that power local AI inference.",
          "by Georgi Gerganov",
          "The project that brought LLM inference to the masses. llama.cpp's pure C/C++ implementation enables Caro to run language models efficiently on any hardware. With 91k+ GitHub stars, it's the backbone of local AI inference.",
          "by Apple Machine Learning Research",
          "The array framework that makes Apple Silicon sing. Built by Awni Hannun, Jagrit Digani, Angelos Katharopoulos, and Ronan Collobert ‚Äî MLX powers Caro's blazing-fast inference on M-series Macs.",
          "by Alibaba Cloud Qwen Team",
          "The magnificent Qwen2.5-Coder models that power Caro's shell command generation. With 100+ open weight models and 40M+ downloads, Qwen represents the best of open source AI. A massive shoutout to the entire Qwen team!",
          "The AI Community Platform",
          "The hub that makes model distribution possible. Caro uses Hugging Face's infrastructure for model caching and downloads, bringing the best open models to your local machine.",
          "by Hugging Face",
          "A minimalist ML framework for Rust that provides Caro's cross-platform CPU inference backend. Fast, lightweight, and Rust-native.",
          "The incredible Rust crates and their maintainers that form Caro's foundation. Without these libraries, there would be no Caro.",
          "Async Runtime"
        ],
        "listItems": []
      },
      "fullText": "A LONG TIME AGO IN AN OPEN SOURCE ECOSYSTEM FAR, FAR AWAY... CREDITS Standing on the Shoulders of Giants Caro is an open source project that would not exist without the incredible work of countless developers, maintainers, and communities who have built the foundations we rely on every day. This page is our way of saying thank you to everyone who has contributed to the tools, libraries, and resources that make Caro possible. &#10024; Special Thanks &#10024; üéÅ Anselm Eickhoff For the gift of a name A heartfelt thank you to @aeplay for graciously transferring the crate name to this project. This act of generosity gave Caro its identity ‚Äî a memorable, friendly name that embodies our mission. \"Work sucks. Play works.\" ‚Äî We couldn't agree more. GitHub ü§ñ Anthropic & Claude Code The Maintainer's Co-Pilot Caro was built with the help of Claude Code , Anthropic's agentic coding tool. From architecture decisions to code reviews, debugging sessions to documentation ‚Äî Claude Code has been an indispensable collaborator in bringing Caro to life. A testament to how AI can augment human creativity in open source development. GitHub Website üß† AI & Machine Learning The brilliant minds and teams building the models and frameworks that power local AI inference. ü¶ô llama.cpp by Georgi Gerganov The project that brought LLM inference to the masses. llama.cpp's pure C/C++ implementation enables Caro to run language models efficiently on any hardware. With 91k+ GitHub stars, it's the backbone of local AI inference. GitHub X/Twitter Website üçé Apple MLX by Apple Machine Learning Research The array framework that makes Apple Silicon sing. Built by Awni Hannun, Jagrit Digani, Angelos Katharopoulos, and Ronan Collobert ‚Äî MLX powers Caro's blazing-fast inference on M-series Macs. GitHub Docs ‚òÅÔ∏è Qwen by Alibaba Cloud Qwen Team The magnificent Qwen2.5-Coder models that power Caro's shell command generation. With 100+ open weight models and 40M+ downloads, Qwen represents the best of open source AI. A massive shoutout to the entire Qwen team! GitHub Hugging Face Website ü§ó Hugging Face The AI Community Platform The hub that makes model distribution possible. Caro uses Hugging Face's infrastructure for model caching and downloads, bringing the best open models to your local machine. GitHub Website üïØÔ∏è Candle by Hugging Face A minimalist ML framework for Rust that provides Caro's cross-platform CPU inference backend. Fast, lightweight, and Rust-native. GitHub ü¶Ä Rust Ecosystem The incredible Rust crates and their maintainers that form Caro's foundation. Without these libraries, there would be no Caro. ‚ö° Tokio Async Runtime Created by Carl Lerche and maintained by Alice Ryhl ‚Äî Tokio is the async foundation that powers Caro's concurrent operations. Alice's tireless work as the first paid Tokio contributor has been instrumental to the ecosystem. GitHub Alice's Site Tokio.rs üìú Serde by David Tolnay The legendary serialization framework with 196M+ downloads. David Tolnay's work on serde, syn, quote, anyhow, and thiserror has shaped how the entire Rust ecosystem handles data and errors. GitHub X/Twitter üéØ Clap by Ed Page & rust-cli The CLI argument parser that makes Caro's interface possible. With 28M+ downloads per month, clap's derive macros and comprehensive features are the gold standard for Rust CLIs. GitHub Docs üåê Reqwest by Sean McArthur The ergonomic HTTP client for Rust. Sean's work on reqwest, hyper, and the entire networking stack powers Caro's remote backend connections. GitHub Blog üìä Tracing by Eliza Weisman Structured diagnostics for Rust. Eliza's tracing ecosystem provides Caro with comprehensive logging and observability. A core tokio-rs team member whose work benefits the entire async Rust ecosystem. GitHub Website üìà Indicatif by Armin Ronacher (mitsuhiko) Progress bars and spinners that make Caro's output beautiful. Armin Ronacher ‚Äî creator of Flask and core Sentry contributor ‚Äî brings the same polish to the Rust console ecosystem. GitHub X/Twitter Website Also Powered By anyhow thiserror serde_json serde_yaml toml config tracing-subscriber tracing-appender dialoguer colored directories dirs which os_info sysinfo hf-hub url chrono regex once_cell sha2 async-trait futures atty tokenizers cxx üåê Web Technologies The frameworks and tools that power caro.sh ‚Äî this very website you're reading. üöÄ Astro by Fred K. Schott & The Astro Team The web framework for content-driven websites. Astro's zero-JS by default philosophy makes caro.sh fast and accessible. Thanks to Fred and the incredible open source community behind Astro ‚Äî governance that puts contributors first. GitHub Fred's GitHub astro.build üìä Vercel Analytics Privacy-friendly insights Real-time, privacy-friendly traffic insights that help us understand how people use caro.sh without compromising visitor privacy. GitHub Vercel üéâ canvas-confetti Celebration effects Because sometimes you need confetti! This lightweight library adds joy to our celebrations without bloating the bundle. GitHub Demo üõó elevator.js by Tim Holman A \"back to top\" button that behaves like a real elevator ‚Äî complete with muzak! Tim's delightfully weird creation adds personality to our scroll experience. GitHub X/Twitter Website üí° Inspiration Portal's Caroline The name \"Caro\" draws inspiration from Caroline, the AI assistant in Valve's Portal series. Like Caroline, Caro aims to be a helpful, loyal companion ‚Äî but one that respects your autonomy and keeps you safe. Kyaro (The Real One!) Meet IRL Kyaro (Kyarorain Kadosh) ‚Äî the real-life inspiration for Caro's loyal companion spirit. Follow her adventures on Instagram @kyaroblackheart üêïüñ§ Open Source Community Every contributor who has ever opened an issue, submitted a PR, answered a question, or shared knowledge freely. The open source ethos makes projects like Caro possible. ‚öñÔ∏è Open Source Licenses Caro is licensed under AGPL-3.0 . We depend on many open source projects with various licenses: MIT License tokio, clap, indicatif, dialoguer, colored, tracing, reqwest, hyper, anyhow, thiserror, elevator.js, canvas-confetti MIT OR Apache-2.0 serde, serde_json, chrono, regex, once_cell, async-trait, futures Apache-2.0 Qwen models, tokenizers, hf-hub MIT llama.cpp, MLX (Apple), Astro For a complete list of dependencies and their licenses, run or check our Cargo.lock . Thank You To every developer who has contributed a line of code, filed a bug report, answered a question, or simply used and shared these incredible projects ‚Äî thank you . Open source is a gift economy, and we're grateful to be part of it. If we've missed anyone or made any errors, please open an issue and let us know! Star Caro on GitHub ‚Äî The Caro Team üêï",
      "_searchText": "credits a long time ago in an open source ecosystem far, far away... /credits caro github open rust source website ecosystem code tokio astro work models qwen serde inference makes team our async hugging face tracing framework downloads entire twitter claude apple thank name real without incredible possible machine friendly powers fast alice fred privacy llama cpp mlx clap reqwest confetti elevator community project credits special thanks anselm eickhoff anthropic & claude code ai & machine learning llama.cpp apple mlx qwen hugging face candle rust ecosystem tokio serde clap reqwest tracing indicatif also powered by web technologies astro vercel analytics canvas-confetti elevator.js inspiration portal's caroline kyaro (the real one!) open source community open source licenses mit license mit or apache-2.0 apache-2.0 mit thank you a long time ago in an open source ecosystem far, far away... standing on the shoulders of giants caro is an open source project that would not exist without the incredible work of countless developers, maintainers, and communities who have built the foundations we rely on every day. this page is our way of saying thank you to everyone who has contributed to the tools, libraries, and resources that make caro possible. for the gift of a name a heartfelt thank you to @aeplay for graciously transferring the crate name to this project. this act of generosity gave caro its identity ‚Äî a memorable, friendly name that embodies our mission. \"work sucks. play works.\" ‚Äî we couldn't agree more. github ü§ñ anthropic & claude code the maintainer's co-pilot caro was built with the help of claude code , anthropic's agentic coding tool. from architecture decisions to code reviews, debugging sessions to documentation ‚Äî claude code has been an indispensable collaborator in bringing caro to life. a testament to how ai can augment human creativity in open source development. github website üß† ai & machine learning the brilliant minds and teams building the models and frameworks that power local ai inference. by georgi gerganov the project that brought llm inference to the masses. llama.cpp's pure c/c++ implementation enables caro to run language models efficiently on any hardware. with 91k+ github stars, it's the backbone of local ai inference. by apple machine learning research the array framework that makes apple silicon sing. built by awni hannun, jagrit digani, angelos katharopoulos, and ronan collobert ‚Äî mlx powers caro's blazing-fast inference on m-series macs. by alibaba cloud qwen team the magnificent qwen2.5-coder models that power caro's shell command generation. with 100+ open weight models and 40m+ downloads, qwen represents the best of open source ai. a massive shoutout to the entire qwen team! the ai community platform the hub that makes model distribution possible. caro uses hugging face's infrastructure for model caching and downloads, bringing the best open models to your local machine. by hugging face a minimalist ml framework for rust that provides caro's cross-platform cpu inference backend. fast, lightweight, and rust-native. the incredible rust crates and their maintainers that form caro's foundation. without these libraries, there would be no caro. async runtime a long time ago in an open source ecosystem far, far away... credits standing on the shoulders of giants caro is an open source project that would not exist without the incredible work of countless developers, maintainers, and communities who have built the foundations we rely on every day. this page is our way of saying thank you to everyone who has contributed to the tools, libraries, and resources that make caro possible. &#10024; special thanks &#10024; üéÅ anselm eickhoff for the gift of a name a heartfelt thank you to @aeplay for graciously transferring the crate name to this project. this act of generosity gave caro its identity ‚Äî a memorable, friendly name that embodies our mission. \"work sucks. play works.\" ‚Äî we couldn't agree more. github ü§ñ anthropic & claude code the maintainer's co-pilot caro was built with the help of claude code , anthropic's agentic coding tool. from architecture decisions to code reviews, debugging sessions to documentation ‚Äî claude code has been an indispensable collaborator in bringing caro to life. a testament to how ai can augment human creativity in open source development. github website üß† ai & machine learning the brilliant minds and teams building the models and frameworks that power local ai inference. ü¶ô llama.cpp by georgi gerganov the project that brought llm inference to the masses. llama.cpp's pure c/c++ implementation enables caro to run language models efficiently on any hardware. with 91k+ github stars, it's the backbone of local ai inference. github x/twitter website üçé apple mlx by apple machine learning research the array framework that makes apple silicon sing. built by awni hannun, jagrit digani, angelos katharopoulos, and ronan collobert ‚Äî mlx powers caro's blazing-fast inference on m-series macs. github docs ‚òÅÔ∏è qwen by alibaba cloud qwen team the magnificent qwen2.5-coder models that power caro's shell command generation. with 100+ open weight models and 40m+ downloads, qwen represents the best of open source ai. a massive shoutout to the entire qwen team! github hugging face website ü§ó hugging face the ai community platform the hub that makes model distribution possible. caro uses hugging face's infrastructure for model caching and downloads, bringing the best open models to your local machine. github website üïØÔ∏è candle by hugging face a minimalist ml framework for rust that provides caro's cross-platform cpu inference backend. fast, lightweight, and rust-native. github ü¶Ä rust ecosystem the incredible rust crates and their maintainers that form caro's foundation. without these libraries, there would be no caro. ‚ö° tokio async runtime created by carl lerche and maintained by alice ryhl ‚Äî tokio is the async foundation that powers caro's concurrent operations. alice's tireless work as the first paid tokio contributor has been instrumental to the ecosystem. github alice's site tokio.rs üìú serde by david tolnay the legendary serialization framework with 196m+ downloads. david tolnay's work on serde, syn, quote, anyhow, and thiserror has shaped how the entire rust ecosystem handles data and errors. github x/twitter üéØ clap by ed page & rust-cli the cli argument parser that makes caro's interface possible. with 28m+ downloads per month, clap's derive macros and comprehensive features are the gold standard for rust clis. github docs üåê reqwest by sean mcarthur the ergonomic http client for rust. sean's work on reqwest, hyper, and the entire networking stack powers caro's remote backend connections. github blog üìä tracing by eliza weisman structured diagnostics for rust. eliza's tracing ecosystem provides caro with comprehensive logging and observability. a core tokio-rs team member whose work benefits the entire async rust ecosystem. github website üìà indicatif by armin ronacher (mitsuhiko) progress bars and spinners that make caro's output beautiful. armin ronacher ‚Äî creator of flask and core sentry contributor ‚Äî brings the same polish to the rust console ecosystem. github x/twitter website also powered by anyhow thiserror serde_json serde_yaml toml config tracing-subscriber tracing-appender dialoguer colored directories dirs which os_info sysinfo hf-hub url chrono regex once_cell sha2 async-trait futures atty tokenizers cxx üåê web technologies the frameworks and tools that power caro.sh ‚Äî this very website you're reading. üöÄ astro by fred k. schott & the astro team the web framework for content-driven websites. astro's zero-js by default philosophy makes caro.sh fast and accessible. thanks to fred and the incredible open source community behind astro ‚Äî governance that puts contributors first. github fred's github astro.build üìä vercel analytics privacy-friendly insights real-time, privacy-friendly traffic insights that help us understand how people use caro.sh without compromising visitor privacy. github vercel üéâ canvas-confetti celebration effects because sometimes you need confetti! this lightweight library adds joy to our celebrations without bloating the bundle. github demo üõó elevator.js by tim holman a \"back to top\" button that behaves like a real elevator ‚Äî complete with muzak! tim's delightfully weird creation adds personality to our scroll experience. github x/twitter website üí° inspiration portal's caroline the name \"caro\" draws inspiration from caroline, the ai assistant in valve's portal series. like caroline, caro aims to be a helpful, loyal companion ‚Äî but one that respects your autonomy and keeps you safe. kyaro (the real one!) meet irl kyaro (kyarorain kadosh) ‚Äî the real-life inspiration for caro's loyal companion spirit. follow her adventures on instagram @kyaroblackheart üêïüñ§ open source community every contributor who has ever opened an issue, submitted a pr, answered a question, or shared knowledge freely. the open source ethos makes projects like caro possible. ‚öñÔ∏è open source licenses caro is licensed under agpl-3.0 . we depend on many open source projects with various licenses: mit license tokio, clap, indicatif, dialoguer, colored, tracing, reqwest, hyper, anyhow, thiserror, elevator.js, canvas-confetti mit or apache-2.0 serde, serde_json, chrono, regex, once_cell, async-trait, futures apache-2.0 qwen models, tokenizers, hf-hub mit llama.cpp, mlx (apple), astro for a complete list of dependencies and their licenses, run or check our cargo.lock . thank you to every developer who has contributed a line of code, filed a bug report, answered a question, or simply used and shared these incredible projects ‚Äî thank you . open source is a gift economy, and we're grateful to be part of it. if we've missed anyone or made any errors, please open an issue and let us know! star caro on github ‚Äî the caro team üêï",
      "_words": [
        "caro",
        "github",
        "open",
        "source",
        "rust",
        "ecosystem",
        "website",
        "tokio",
        "astro",
        "serde",
        "code",
        "work",
        "models",
        "qwen",
        "tracing",
        "inference",
        "makes",
        "team",
        "our",
        "async",
        "hugging",
        "face",
        "apple",
        "thank",
        "real",
        "mit",
        "framework",
        "downloads",
        "entire",
        "twitter",
        "claude",
        "name",
        "without",
        "incredible",
        "possible",
        "machine",
        "llama",
        "cpp",
        "mlx",
        "clap",
        "reqwest",
        "confetti",
        "elevator",
        "community",
        "far",
        "friendly",
        "powers",
        "fast",
        "alice",
        "fred",
        "privacy",
        "project",
        "inspiration",
        "caroline",
        "licenses",
        "apache",
        "credits",
        "time",
        "thanks",
        "anthropic",
        "learning",
        "indicatif",
        "web",
        "vercel",
        "canvas",
        "portal",
        "kyaro",
        "one",
        "built",
        "power",
        "local",
        "hub",
        "contributor",
        "anyhow",
        "thiserror",
        "like",
        "projects",
        "10024",
        "long",
        "ago",
        "away",
        "special",
        "anselm",
        "eickhoff",
        "candle",
        "powered",
        "technologies",
        "analytics",
        "license",
        "maintainers",
        "page",
        "contributed",
        "tools",
        "libraries",
        "make",
        "gift",
        "help",
        "bringing",
        "life",
        "frameworks"
      ]
    },
    {
      "title": "Explore",
      "path": "/explore",
      "description": "Your loyal companion for safe shell command generation. Published on crates.io with core features working - advanced features in active development.",
      "category": "explore",
      "keywords": [
        "caro",
        "your",
        "features",
        "explore",
        "join",
        "report",
        "issues",
        "contribute",
        "get",
        "started",
        "loyal",
        "companion",
        "shell",
        "pack",
        "star",
        "github",
        "read",
        "blog",
        "safe",
        "command",
        "generation",
        "published",
        "crates",
        "core",
        "working",
        "advanced",
        "active",
        "development",
        "show",
        "support",
        "stay",
        "updated",
        "latest",
        "releases",
        "found",
        "bug",
        "feature",
        "request",
        "let",
        "know",
        "help",
        "make",
        "better",
        "everyone",
        "learn",
        "about",
        "story",
        "philosophy",
        "behind",
        "use"
      ],
      "icon": "üîç",
      "content": {
        "headings": [
          "Explore Caro",
          "Join the Pack",
          "Star on GitHub",
          "Report Issues",
          "Contribute",
          "Read the Blog"
        ],
        "paragraphs": [
          "Your loyal companion for safe shell command generation. Published on crates.io with core features working - advanced features in active development.",
          "Join the Pack Caro is open source and built with the community. Contribute, report issues, or join the conversation.",
          "Show your support and stay updated with the latest releases",
          "Found a bug or have a feature request? Let us know",
          "Help make Caro better for everyone",
          "Learn about the story and philosophy behind Caro"
        ],
        "listItems": []
      },
      "fullText": "v Explore Caro Your loyal companion for safe shell command generation. Published on crates.io with core features working - advanced features in active development. Get Started See Examples üöÄ Get Started üíª Use Cases üîå Integration üõ°Ô∏è Safety ‚öôÔ∏è Backends üì¶ Install Join the Pack Caro is open source and built with the community. Contribute, report issues, or join the conversation. ‚≠ê Star on GitHub Show your support and stay updated with the latest releases üêõ Report Issues Found a bug or have a feature request? Let us know ü§ù Contribute Help make Caro better for everyone üìö Read the Blog Learn about the story and philosophy behind Caro",
      "_searchText": "explore your loyal companion for safe shell command generation. published on crates.io with core features working - advanced features in active development. /explore caro your features explore join report issues contribute get started loyal companion shell pack star github read blog safe command generation published crates core working advanced active development show support stay updated latest releases found bug feature request let know help make better everyone learn about story philosophy behind use explore caro join the pack star on github report issues contribute read the blog your loyal companion for safe shell command generation. published on crates.io with core features working - advanced features in active development. join the pack caro is open source and built with the community. contribute, report issues, or join the conversation. show your support and stay updated with the latest releases found a bug or have a feature request? let us know help make caro better for everyone learn about the story and philosophy behind caro v explore caro your loyal companion for safe shell command generation. published on crates.io with core features working - advanced features in active development. get started see examples üöÄ get started üíª use cases üîå integration üõ°Ô∏è safety ‚öôÔ∏è backends üì¶ install join the pack caro is open source and built with the community. contribute, report issues, or join the conversation. ‚≠ê star on github show your support and stay updated with the latest releases üêõ report issues found a bug or have a feature request? let us know ü§ù contribute help make caro better for everyone üìö read the blog learn about the story and philosophy behind caro",
      "_words": [
        "caro",
        "features",
        "explore",
        "your",
        "join",
        "report",
        "issues",
        "contribute",
        "loyal",
        "companion",
        "safe",
        "shell",
        "command",
        "generation",
        "published",
        "crates",
        "core",
        "working",
        "advanced",
        "active",
        "development",
        "get",
        "started",
        "pack",
        "star",
        "github",
        "read",
        "blog",
        "show",
        "support",
        "stay",
        "updated",
        "latest",
        "releases",
        "found",
        "bug",
        "feature",
        "request",
        "let",
        "know",
        "help",
        "make",
        "better",
        "everyone",
        "learn",
        "about",
        "story",
        "philosophy",
        "behind",
        "use",
        "see",
        "examples",
        "cases",
        "integration",
        "safety",
        "backends",
        "install",
        "open",
        "source",
        "built",
        "community",
        "conversation"
      ]
    },
    {
      "title": "Home",
      "path": "/",
      "description": "",
      "category": "main",
      "keywords": [
        "home",
        "caro",
        "your",
        "loyal",
        "shell",
        "companion"
      ],
      "icon": "üè†",
      "content": {
        "headings": [],
        "paragraphs": [],
        "listItems": []
      },
      "fullText": "",
      "_searchText": "home  / home caro your loyal shell companion ",
      "_words": [
        "home",
        "caro",
        "your",
        "loyal",
        "shell",
        "companion"
      ]
    },
    {
      "title": "Core Improvements",
      "path": "/roadmap",
      "description": "Establish production-ready core, optimize performance, build reliable infrastructure",
      "category": "main",
      "keywords": [
        "items",
        "our",
        "caro",
        "notes",
        "product",
        "presenter",
        "due",
        "days",
        "overview",
        "foundation",
        "journey",
        "roadmap",
        "shell",
        "milestones",
        "2026",
        "timeline",
        "launch",
        "success",
        "criteria",
        "slide",
        "companion",
        "innovation",
        "public",
        "major",
        "work",
        "github",
        "months",
        "development",
        "build",
        "strategic",
        "themes",
        "join",
        "release",
        "features",
        "quarterly",
        "focus",
        "interaction",
        "star",
        "planned",
        "space",
        "marketing",
        "your",
        "loyal",
        "shows",
        "three",
        "focuses",
        "advanced",
        "current",
        "overall",
        "progress"
      ],
      "icon": "üó∫Ô∏è",
      "content": {
        "headings": [
          "Caro",
          "Timeline Overview",
          "Success Criteria",
          "Success Criteria",
          "Success Criteria",
          "Strategic Themes",
          "Project Tracking",
          "Join the Journey",
          "Slide Overview"
        ],
        "paragraphs": [
          "1 / 7 Product Roadmap 2026 Caro Your loyal shell companion",
          "Our journey from foundation to innovation",
          "% ))} > ))} Presenter Notes: This timeline shows our three major release milestones. Q1 focuses on foundation work, Q2 on public launch, Q3 on advanced features. Current overall progress: %.",
          "Our quarterly focus areas for 2026",
          "Help us build the future of shell interaction",
          "Star on GitHub Get Started üêï \"Every contribution makes Caro a better companion!\""
        ],
        "listItems": [
          "Product Roadmap 2026 Caro Your loyal shell companion Planned Items 3 Milestones 6 Months Press ‚Üí or Space to begin Presenter Notes: Welcome to the Caro Product Roadmap presentation. This deck covers our 6-month development plan across 3 major milestones. Use arrow keys or swipe to navigate. Timeline Overview Our journey from foundation to innovation > % ))} > ))} Presenter Notes: This timeline shows our three major release milestones. Q1 focuses on foundation work, Q2 on public launch, Q3 on advanced features. Current overall progress: %. üìÖ Due: ‚è≥ days üìä / items"
        ]
      },
      "fullText": "1 / 7 Product Roadmap 2026 Caro Your loyal shell companion Planned Items 3 Milestones 6 Months Press ‚Üí or Space to begin Presenter Notes: Welcome to the Caro Product Roadmap presentation. This deck covers our 6-month development plan across 3 major milestones. Use arrow keys or swipe to navigate. Timeline Overview Our journey from foundation to innovation > % ))} > ))} Presenter Notes: This timeline shows our three major release milestones. Q1 focuses on foundation work, Q2 on public launch, Q3 on advanced features. Current overall progress: %. üìÖ Due: ‚è≥ days üìä / items ))} ))} Success Criteria ))} Presenter Notes: v1.1.0 is our production-ready release. Critical bug fix is the top priority. HF model download and performance work follow. This milestone establishes our foundation for public launch. üìÖ Due: ‚è≥ days üìä / items ))} ))} Success Criteria ))} Presenter Notes: v1.2.0 is our public launch milestone. Website, documentation, and marketing are the focus. This is when we go from soft launch to full public availability. üìÖ Due: ‚è≥ days üìä / items ))} ))} Success Criteria ))} Presenter Notes: v2.0.0 is our innovation milestone. Karo distributed intelligence and voice synthesis are flagship features. This positions Caro as a next-generation AI shell companion. Strategic Themes Our quarterly focus areas for 2026 ; --delay: $ s> ))} Project Tracking üîß Product Development 36 items üì¢ Marketing & DevRel 29 items Presenter Notes: Strategic themes guide our quarterly priorities. Foundation ‚Üí Launch ‚Üí Innovation is the natural progression. All work is tracked in GitHub Projects for transparency. Join the Journey Help us build the future of shell interaction Total Items % Complete 6 Months to v2.0 Star on GitHub Get Started üêï \"Every contribution makes Caro a better companion!\" Presenter Notes: Thank you for viewing the Caro Product Roadmap! We welcome contributions from the community. Star us on GitHub and join our journey to revolutionize shell interaction. Slide Overview Close ‚Üê ‚Üí Navigate Space Next F Fullscreen N Notes O Overview ? Hide hints",
      "_searchText": "core improvements establish production-ready core, optimize performance, build reliable infrastructure /roadmap items our caro notes product presenter due days overview foundation journey roadmap shell milestones 2026 timeline launch success criteria slide companion innovation public major work github months development build strategic themes join release features quarterly focus interaction star planned space marketing your loyal shows three focuses advanced current overall progress caro timeline overview success criteria success criteria success criteria strategic themes project tracking join the journey slide overview 1 / 7 product roadmap 2026 caro your loyal shell companion our journey from foundation to innovation % ))} > ))} presenter notes: this timeline shows our three major release milestones. q1 focuses on foundation work, q2 on public launch, q3 on advanced features. current overall progress: %. our quarterly focus areas for 2026 help us build the future of shell interaction star on github get started üêï \"every contribution makes caro a better companion!\" product roadmap 2026 caro your loyal shell companion planned items 3 milestones 6 months press ‚Üí or space to begin presenter notes: welcome to the caro product roadmap presentation. this deck covers our 6-month development plan across 3 major milestones. use arrow keys or swipe to navigate. timeline overview our journey from foundation to innovation > % ))} > ))} presenter notes: this timeline shows our three major release milestones. q1 focuses on foundation work, q2 on public launch, q3 on advanced features. current overall progress: %. üìÖ due: ‚è≥ days üìä / items 1 / 7 product roadmap 2026 caro your loyal shell companion planned items 3 milestones 6 months press ‚Üí or space to begin presenter notes: welcome to the caro product roadmap presentation. this deck covers our 6-month development plan across 3 major milestones. use arrow keys or swipe to navigate. timeline overview our journey from foundation to innovation > % ))} > ))} presenter notes: this timeline shows our three major release milestones. q1 focuses on foundation work, q2 on public launch, q3 on advanced features. current overall progress: %. üìÖ due: ‚è≥ days üìä / items ))} ))} success criteria ))} presenter notes: v1.1.0 is our production-ready release. critical bug fix is the top priority. hf model download and performance work follow. this milestone establishes our foundation for public launch. üìÖ due: ‚è≥ days üìä / items ))} ))} success criteria ))} presenter notes: v1.2.0 is our public launch milestone. website, documentation, and marketing are the focus. this is when we go from soft launch to full public availability. üìÖ due: ‚è≥ days üìä / items ))} ))} success criteria ))} presenter notes: v2.0.0 is our innovation milestone. karo distributed intelligence and voice synthesis are flagship features. this positions caro as a next-generation ai shell companion. strategic themes our quarterly focus areas for 2026 ; --delay: $ s> ))} project tracking üîß product development 36 items üì¢ marketing & devrel 29 items presenter notes: strategic themes guide our quarterly priorities. foundation ‚Üí launch ‚Üí innovation is the natural progression. all work is tracked in github projects for transparency. join the journey help us build the future of shell interaction total items % complete 6 months to v2.0 star on github get started üêï \"every contribution makes caro a better companion!\" presenter notes: thank you for viewing the caro product roadmap! we welcome contributions from the community. star us on github and join our journey to revolutionize shell interaction. slide overview close ‚Üê ‚Üí navigate space next f fullscreen n notes o overview ? hide hints",
      "_words": [
        "our",
        "notes",
        "items",
        "presenter",
        "caro",
        "success",
        "criteria",
        "overview",
        "launch",
        "product",
        "foundation",
        "journey",
        "shell",
        "public",
        "due",
        "days",
        "roadmap",
        "milestones",
        "timeline",
        "companion",
        "innovation",
        "work",
        "github",
        "strategic",
        "themes",
        "join",
        "2026",
        "build",
        "slide",
        "major",
        "months",
        "development",
        "release",
        "features",
        "quarterly",
        "focus",
        "interaction",
        "star",
        "space",
        "marketing",
        "milestone",
        "core",
        "production",
        "ready",
        "performance",
        "planned",
        "your",
        "loyal",
        "shows",
        "three",
        "focuses",
        "advanced",
        "current",
        "overall",
        "progress",
        "project",
        "tracking",
        "welcome",
        "navigate",
        "next",
        "improvements",
        "establish",
        "optimize",
        "reliable",
        "infrastructure",
        "press",
        "begin",
        "presentation",
        "deck",
        "covers",
        "month",
        "plan",
        "across",
        "use",
        "arrow",
        "keys",
        "swipe",
        "critical",
        "bug",
        "fix",
        "top",
        "priority",
        "model",
        "download",
        "follow",
        "establishes",
        "website",
        "documentation",
        "soft",
        "full",
        "availability",
        "karo",
        "distributed",
        "intelligence",
        "voice",
        "synthesis",
        "flagship",
        "positions",
        "generation",
        "areas"
      ]
    },
    {
      "title": "Safe Shell Commands",
      "path": "/safe-shell-commands",
      "description": "",
      "category": "main",
      "keywords": [
        "safe",
        "shell",
        "commands",
        "caro"
      ],
      "icon": "üìÑ",
      "content": {
        "headings": [],
        "paragraphs": [],
        "listItems": []
      },
      "fullText": "",
      "_searchText": "safe shell commands  /safe-shell-commands safe shell commands caro ",
      "_words": [
        "safe",
        "shell",
        "commands",
        "caro"
      ]
    },
    {
      "title": "Support",
      "path": "/support",
      "description": "Help sustain open source development",
      "category": "main",
      "keywords": [
        "open",
        "support",
        "collective",
        "caro",
        "source",
        "github",
        "transparency",
        "contribute",
        "development",
        "our",
        "full",
        "project",
        "funds",
        "infrastructure",
        "help",
        "transparent",
        "funding",
        "community",
        "code",
        "ways",
        "legal",
        "report",
        "see",
        "share",
        "100",
        "your",
        "financial",
        "time",
        "features",
        "bug",
        "issue",
        "sponsors",
        "employment",
        "ready",
        "maintenance",
        "star",
        "sponsor",
        "transaction",
        "public",
        "receipts",
        "budget",
        "updates",
        "fiscal",
        "expense",
        "free",
        "maintained",
        "small",
        "helps",
        "new",
        "platform"
      ],
      "icon": "üí¨",
      "content": {
        "headings": [
          "Support Caro",
          "Ways to Contribute",
          "GitHub Sponsors",
          "Open Collective",
          "Why Open Source Collective?",
          "Legal Structure",
          "Full Transparency",
          "Handles Administration",
          "Corporate Funding",
          "Employment Ready",
          "Asset Protection",
          "How Funds Are Used",
          "Development",
          "Maintenance",
          "Community",
          "Infrastructure",
          "Our Transparency Commitment",
          "Other Ways to Help",
          "Star on GitHub",
          "Report Issues",
          "Contribute Code",
          "Spread the Word",
          "Ready to Support?"
        ],
        "paragraphs": [
          "Help sustain open source development",
          "Caro is free, open source software maintained by a small team. Your financial support helps us dedicate time to maintenance, new features, and community support.",
          "Recommended GitHub Sponsors The easiest way to support Caro. GitHub covers all platform fees, so 100% of your contribution goes directly to development.",
          "Sponsor on GitHub Full Transparency Open Collective For organizations and individuals who value transparent, accountable funding. See exactly how every dollar is spent.",
          "Support on Open Collective Why Open Source Collective? Caro is fiscally hosted by Open Source Collective , a 501(c)(6) nonprofit that provides financial and legal infrastructure for open source projects.",
          "Legal Structure No need to create a nonprofit. Open Source Collective provides the legal entity to receive tax-deductible donations.",
          "Full Transparency Every transaction is public. Anyone can see exactly how funds are received and spent on the project.",
          "Handles Administration Taxes, accounting, contracts, and compliance are managed by professionals so we can focus on code.",
          "Corporate Funding Companies can contribute with proper invoicing and receipts, making it easier to get budget approval.",
          "Employment Ready Infrastructure for contractor payments and even full-time employment as the project grows.",
          "Asset Protection Trademark and domain management ensures the project's identity is protected long-term.",
          "Every dollar contributed goes toward making Caro better. Here's how we allocate funds:",
          "Development New features, performance improvements, and expanding backend support. Building the future of safe shell commands.",
          "Maintenance Bug fixes, dependency updates, security patches, and keeping Caro reliable and secure for all users.",
          "Community Documentation, tutorials, issue triage, and helping users get the most out of Caro.",
          "Infrastructure CI/CD, testing infrastructure, website hosting, and tools that keep the project running smoothly.",
          "We believe open source funding should be as transparent as open source code. That's why we chose Open Collective as our fiscal host.",
          "100% Transparent Other Ways to Help Can't contribute financially? There are many other valuable ways to support Caro:",
          "Star on GitHub Stars help with visibility and show appreciation for the project.",
          "Report Issues Found a bug? Help us improve by opening a detailed issue report."
        ],
        "listItems": [
          "One-time or monthly donations",
          "No platform fees",
          "Direct support to maintainer",
          "Sponsor badge on GitHub",
          "Full financial transparency",
          "Invoice generation for businesses",
          "Fiscal sponsorship included",
          "Expense tracking & reporting",
          "Public ledger: Every transaction is visible on our Open Collective page",
          "Expense transparency: All expenses are submitted with descriptions and receipts",
          "Regular updates: We share progress reports on how funds support development",
          "Community input: Contributors can see and comment on budget decisions"
        ]
      },
      "fullText": "Support Caro Help sustain open source development Caro is free, open source software maintained by a small team. Your financial support helps us dedicate time to maintenance, new features, and community support. Ways to Contribute Recommended GitHub Sponsors The easiest way to support Caro. GitHub covers all platform fees, so 100% of your contribution goes directly to development. One-time or monthly donations No platform fees Direct support to maintainer Sponsor badge on GitHub Sponsor on GitHub Full Transparency Open Collective For organizations and individuals who value transparent, accountable funding. See exactly how every dollar is spent. Full financial transparency Invoice generation for businesses Fiscal sponsorship included Expense tracking & reporting Support on Open Collective Why Open Source Collective? Caro is fiscally hosted by Open Source Collective , a 501(c)(6) nonprofit that provides financial and legal infrastructure for open source projects. Legal Structure No need to create a nonprofit. Open Source Collective provides the legal entity to receive tax-deductible donations. Full Transparency Every transaction is public. Anyone can see exactly how funds are received and spent on the project. Handles Administration Taxes, accounting, contracts, and compliance are managed by professionals so we can focus on code. Corporate Funding Companies can contribute with proper invoicing and receipts, making it easier to get budget approval. Employment Ready Infrastructure for contractor payments and even full-time employment as the project grows. Asset Protection Trademark and domain management ensures the project's identity is protected long-term. How Funds Are Used Every dollar contributed goes toward making Caro better. Here's how we allocate funds: Development New features, performance improvements, and expanding backend support. Building the future of safe shell commands. Maintenance Bug fixes, dependency updates, security patches, and keeping Caro reliable and secure for all users. Community Documentation, tutorials, issue triage, and helping users get the most out of Caro. Infrastructure CI/CD, testing infrastructure, website hosting, and tools that keep the project running smoothly. Our Transparency Commitment We believe open source funding should be as transparent as open source code. That's why we chose Open Collective as our fiscal host. Public ledger: Every transaction is visible on our Open Collective page Expense transparency: All expenses are submitted with descriptions and receipts Regular updates: We share progress reports on how funds support development Community input: Contributors can see and comment on budget decisions View Our Finances 100% Transparent Other Ways to Help Can't contribute financially? There are many other valuable ways to support Caro: Star on GitHub Stars help with visibility and show appreciation for the project. Star the repo Report Issues Found a bug? Help us improve by opening a detailed issue report. Report an issue Contribute Code Submit pull requests for bug fixes, features, or documentation improvements. Contribute Spread the Word Share Caro with colleagues, on social media, or write about your experience. Share on X Ready to Support? Every contribution, big or small, helps keep Caro free and actively maintained. GitHub Sponsors Open Collective",
      "_searchText": "support help sustain open source development /support open support collective caro source github transparency contribute development our full project funds infrastructure help transparent funding community code ways legal report see share 100 your financial time features bug issue sponsors employment ready maintenance star sponsor transaction public receipts budget updates fiscal expense free maintained small helps new platform support caro ways to contribute github sponsors open collective why open source collective? legal structure full transparency handles administration corporate funding employment ready asset protection how funds are used development maintenance community infrastructure our transparency commitment other ways to help star on github report issues contribute code spread the word ready to support? help sustain open source development caro is free, open source software maintained by a small team. your financial support helps us dedicate time to maintenance, new features, and community support. recommended github sponsors the easiest way to support caro. github covers all platform fees, so 100% of your contribution goes directly to development. sponsor on github full transparency open collective for organizations and individuals who value transparent, accountable funding. see exactly how every dollar is spent. support on open collective why open source collective? caro is fiscally hosted by open source collective , a 501(c)(6) nonprofit that provides financial and legal infrastructure for open source projects. legal structure no need to create a nonprofit. open source collective provides the legal entity to receive tax-deductible donations. full transparency every transaction is public. anyone can see exactly how funds are received and spent on the project. handles administration taxes, accounting, contracts, and compliance are managed by professionals so we can focus on code. corporate funding companies can contribute with proper invoicing and receipts, making it easier to get budget approval. employment ready infrastructure for contractor payments and even full-time employment as the project grows. asset protection trademark and domain management ensures the project's identity is protected long-term. every dollar contributed goes toward making caro better. here's how we allocate funds: development new features, performance improvements, and expanding backend support. building the future of safe shell commands. maintenance bug fixes, dependency updates, security patches, and keeping caro reliable and secure for all users. community documentation, tutorials, issue triage, and helping users get the most out of caro. infrastructure ci/cd, testing infrastructure, website hosting, and tools that keep the project running smoothly. we believe open source funding should be as transparent as open source code. that's why we chose open collective as our fiscal host. 100% transparent other ways to help can't contribute financially? there are many other valuable ways to support caro: star on github stars help with visibility and show appreciation for the project. report issues found a bug? help us improve by opening a detailed issue report. one-time or monthly donations no platform fees direct support to maintainer sponsor badge on github full financial transparency invoice generation for businesses fiscal sponsorship included expense tracking & reporting public ledger: every transaction is visible on our open collective page expense transparency: all expenses are submitted with descriptions and receipts regular updates: we share progress reports on how funds support development community input: contributors can see and comment on budget decisions support caro help sustain open source development caro is free, open source software maintained by a small team. your financial support helps us dedicate time to maintenance, new features, and community support. ways to contribute recommended github sponsors the easiest way to support caro. github covers all platform fees, so 100% of your contribution goes directly to development. one-time or monthly donations no platform fees direct support to maintainer sponsor badge on github sponsor on github full transparency open collective for organizations and individuals who value transparent, accountable funding. see exactly how every dollar is spent. full financial transparency invoice generation for businesses fiscal sponsorship included expense tracking & reporting support on open collective why open source collective? caro is fiscally hosted by open source collective , a 501(c)(6) nonprofit that provides financial and legal infrastructure for open source projects. legal structure no need to create a nonprofit. open source collective provides the legal entity to receive tax-deductible donations. full transparency every transaction is public. anyone can see exactly how funds are received and spent on the project. handles administration taxes, accounting, contracts, and compliance are managed by professionals so we can focus on code. corporate funding companies can contribute with proper invoicing and receipts, making it easier to get budget approval. employment ready infrastructure for contractor payments and even full-time employment as the project grows. asset protection trademark and domain management ensures the project's identity is protected long-term. how funds are used every dollar contributed goes toward making caro better. here's how we allocate funds: development new features, performance improvements, and expanding backend support. building the future of safe shell commands. maintenance bug fixes, dependency updates, security patches, and keeping caro reliable and secure for all users. community documentation, tutorials, issue triage, and helping users get the most out of caro. infrastructure ci/cd, testing infrastructure, website hosting, and tools that keep the project running smoothly. our transparency commitment we believe open source funding should be as transparent as open source code. that's why we chose open collective as our fiscal host. public ledger: every transaction is visible on our open collective page expense transparency: all expenses are submitted with descriptions and receipts regular updates: we share progress reports on how funds support development community input: contributors can see and comment on budget decisions view our finances 100% transparent other ways to help can't contribute financially? there are many other valuable ways to support caro: star on github stars help with visibility and show appreciation for the project. star the repo report issues found a bug? help us improve by opening a detailed issue report. report an issue contribute code submit pull requests for bug fixes, features, or documentation improvements. contribute spread the word share caro with colleagues, on social media, or write about your experience. share on x ready to support? every contribution, big or small, helps keep caro free and actively maintained. github sponsors open collective",
      "_words": [
        "open",
        "support",
        "caro",
        "source",
        "collective",
        "github",
        "transparency",
        "contribute",
        "help",
        "development",
        "our",
        "full",
        "project",
        "funds",
        "infrastructure",
        "ways",
        "funding",
        "community",
        "code",
        "legal",
        "report",
        "ready",
        "transparent",
        "see",
        "share",
        "your",
        "financial",
        "time",
        "features",
        "bug",
        "issue",
        "sponsors",
        "employment",
        "maintenance",
        "star",
        "100",
        "sponsor",
        "transaction",
        "public",
        "receipts",
        "budget",
        "updates",
        "fiscal",
        "expense",
        "free",
        "maintained",
        "small",
        "helps",
        "new",
        "platform",
        "sustain",
        "structure",
        "handles",
        "administration",
        "corporate",
        "asset",
        "protection",
        "commitment",
        "issues",
        "spread",
        "word",
        "fees",
        "contribution",
        "goes",
        "donations",
        "exactly",
        "dollar",
        "spent",
        "nonprofit",
        "provides",
        "making",
        "get",
        "improvements",
        "fixes",
        "users",
        "documentation",
        "keep",
        "501",
        "software",
        "team",
        "dedicate",
        "recommended",
        "easiest",
        "way",
        "covers",
        "directly",
        "one",
        "monthly",
        "direct",
        "maintainer",
        "badge",
        "organizations",
        "individuals",
        "value",
        "accountable",
        "invoice",
        "generation",
        "businesses",
        "sponsorship",
        "included"
      ]
    },
    {
      "title": "Telemetry",
      "path": "/telemetry",
      "description": "Privacy-first by design. Transparent by choice.",
      "category": "main",
      "keywords": [
        "telemetry",
        "data",
        "disable",
        "caro",
        "collect",
        "commands",
        "your",
        "beta",
        "anonymous",
        "use",
        "privacy",
        "default",
        "features",
        "session",
        "our",
        "product",
        "identify",
        "opt",
        "environment",
        "helps",
        "generated",
        "users",
        "inference",
        "open",
        "source",
        "air",
        "gapped",
        "questions",
        "help",
        "improve",
        "usage",
        "code",
        "understand",
        "through",
        "performance",
        "best",
        "backends",
        "across",
        "many",
        "agpl",
        "general",
        "availability",
        "out",
        "never",
        "collected",
        "environments",
        "option",
        "mode",
        "first",
        "respect"
      ],
      "icon": "üìÑ",
      "content": {
        "headings": [
          "Telemetry & Privacy",
          "TL;DR",
          "Opt-Out",
          "Opt-In",
          "Why We Collect Telemetry",
          "What We Collect",
          "‚úì What We Collect",
          "‚úó What We NEVER Collect",
          "Your Controls",
          "Disable Telemetry",
          "Single Session",
          "Environment Variable",
          "View What's Collected",
          "Air-Gapped Environments",
          "Option 1: Disable Telemetry",
          "Option 2: Air-Gapped Mode (Coming Soon)",
          "Our Commitment",
          "Transparency",
          "Privacy-First",
          "Respect",
          "Evolution",
          "Frequently Asked Questions",
          "Questions?"
        ],
        "paragraphs": [
          "Privacy-first by design. Transparent by choice.",
          "Telemetry is enabled by default to help us improve the product. You can easily disable it.",
          "Telemetry will be disabled by default . We'll ask if you'd like to help by enabling it.",
          "We're building Caro to be the best AI shell assistant. During beta, anonymous usage data helps us:",
          "Which commands are generated most? Which backends perform best? Where do users struggle?",
          "Focus engineering effort on features people actually use, not what we assume they want.",
          "Identify slow inference, errors, and bottlenecks across different platforms.",
          "Are we blocking too many safe commands? Missing dangerous ones? Data helps us tune.",
          "Don't trust, verify: Caro is open source (AGPL-3.0) . Check the telemetry code yourself in .",
          "Permanently disable all telemetry collection.",
          "Disable for just this invocation.",
          "Disable via environment (great for CI/CD).",
          "See exactly what data is queued before sending.",
          "We understand many users work in environments without network access. Caro works perfectly offline‚Äîthat's a core feature.",
          "Simply disable telemetry and use Caro normally. No data is collected or stored.",
          "Enable air-gapped mode to collect telemetry locally. When you're ready, export the data and share it with us through our secure portal.",
          "Manual export/upload workflow planned for future release.",
          "This page documents exactly what we collect. The code is open source for verification.",
          "We collect metadata, not content. Your commands and data never leave your machine.",
          "If you disable telemetry, we respect that completely. No nagging, no degraded features."
        ],
        "listItems": [
          "üìä Understand real-world usage Which commands are generated most? Which backends perform best? Where do users struggle?",
          "üéØ Prioritize our roadmap Focus engineering effort on features people actually use, not what we assume they want.",
          "‚ö° Optimize performance Identify slow inference, errors, and bottlenecks across different platforms.",
          "üõ°Ô∏è Calibrate safety Are we blocking too many safe commands? Missing dangerous ones? Data helps us tune.",
          "Session timing (duration, commands generated/executed)",
          "Performance metrics (inference time, backend used)",
          "Platform info (OS, architecture, shell type)",
          "Error categories (not details or stack traces)",
          "Safety validation events (risk level, action taken)",
          "Anonymous session ID (rotates daily)",
          "Your commands or natural language inputs",
          "File paths or directory structures",
          "Environment variables or secrets",
          "Hostnames, IPs, or usernames",
          "Any personally identifiable information",
          "Command output or execution results"
        ]
      },
      "fullText": "Telemetry & Privacy Privacy-first by design. Transparent by choice. TL;DR Beta (Current) Opt-Out Telemetry is enabled by default to help us improve the product. You can easily disable it. General Availability Opt-In Telemetry will be disabled by default . We'll ask if you'd like to help by enabling it. Why We Collect Telemetry We're building Caro to be the best AI shell assistant. During beta, anonymous usage data helps us: üìä Understand real-world usage Which commands are generated most? Which backends perform best? Where do users struggle? üéØ Prioritize our roadmap Focus engineering effort on features people actually use, not what we assume they want. ‚ö° Optimize performance Identify slow inference, errors, and bottlenecks across different platforms. üõ°Ô∏è Calibrate safety Are we blocking too many safe commands? Missing dangerous ones? Data helps us tune. What We Collect ‚úì What We Collect Session timing (duration, commands generated/executed) Performance metrics (inference time, backend used) Platform info (OS, architecture, shell type) Error categories (not details or stack traces) Safety validation events (risk level, action taken) Anonymous session ID (rotates daily) ‚úó What We NEVER Collect Your commands or natural language inputs File paths or directory structures Environment variables or secrets Hostnames, IPs, or usernames Any personally identifiable information Command output or execution results Don't trust, verify: Caro is open source (AGPL-3.0) . Check the telemetry code yourself in . Your Controls Disable Telemetry Permanently disable all telemetry collection. Single Session Disable for just this invocation. Environment Variable Disable via environment (great for CI/CD). View What's Collected See exactly what data is queued before sending. Air-Gapped Environments We understand many users work in environments without network access. Caro works perfectly offline‚Äîthat's a core feature. Option 1: Disable Telemetry Simply disable telemetry and use Caro normally. No data is collected or stored. Option 2: Air-Gapped Mode (Coming Soon) Enable air-gapped mode to collect telemetry locally. When you're ready, export the data and share it with us through our secure portal. Manual export/upload workflow planned for future release. Our Commitment 1 Transparency This page documents exactly what we collect. The code is open source for verification. 2 Privacy-First We collect metadata, not content. Your commands and data never leave your machine. 3 Respect If you disable telemetry, we respect that completely. No nagging, no degraded features. 4 Evolution After beta, telemetry becomes opt-in. We'll ask nicely, but the default is off. Frequently Asked Questions Why is telemetry on by default during beta? Beta is specifically for gathering feedback to improve the product before general availability. Anonymous usage data helps us understand how Caro is used in the real world, identify bugs, and prioritize features. This is standard practice for beta software. When will telemetry become opt-in? At general availability (GA) release, telemetry will be disabled by default. We'll prompt new users to optionally enable it, explaining the value exchange: you help us improve the product, we make Caro better for everyone. Can you identify me from the telemetry data? No. We use an anonymous session ID that's generated from a hash of your machine ID plus the current date. This means: (1) we can't identify who you are, and (2) the ID rotates daily, so we can't even track the same anonymous user across days. What happens to my data? Telemetry is processed by PostHog , a privacy-focused analytics platform. Data is used only for product analytics and is retained for 90 days (raw events) or 2 years (aggregated metrics). You can request deletion by contacting us. Does disabling telemetry affect functionality? No. Caro works identically with or without telemetry. All features, all backends, full performance. We believe in earning telemetry through value, not coercing it through feature gates. I work in a regulated environment. Can I still use Caro? Yes! Disable telemetry and use Caro with complete confidence. Nothing is sent anywhere. All inference happens locally. You can audit the source code‚Äîit's AGPL-3.0 licensed. Questions? We're committed to being transparent about telemetry. If you have questions, concerns, or suggestions about our approach, please reach out. Open an Issue Join Discussion",
      "_searchText": "telemetry privacy-first by design. transparent by choice. /telemetry telemetry data disable caro collect commands your beta anonymous use privacy default features session our product identify opt environment helps generated users inference open source air gapped questions help improve usage code understand through performance best backends across many agpl general availability out never collected environments option mode first respect telemetry & privacy tl;dr opt-out opt-in why we collect telemetry what we collect ‚úì what we collect ‚úó what we never collect your controls disable telemetry single session environment variable view what's collected air-gapped environments option 1: disable telemetry option 2: air-gapped mode (coming soon) our commitment transparency privacy-first respect evolution frequently asked questions questions? privacy-first by design. transparent by choice. telemetry is enabled by default to help us improve the product. you can easily disable it. telemetry will be disabled by default . we'll ask if you'd like to help by enabling it. we're building caro to be the best ai shell assistant. during beta, anonymous usage data helps us: which commands are generated most? which backends perform best? where do users struggle? focus engineering effort on features people actually use, not what we assume they want. identify slow inference, errors, and bottlenecks across different platforms. are we blocking too many safe commands? missing dangerous ones? data helps us tune. don't trust, verify: caro is open source (agpl-3.0) . check the telemetry code yourself in . permanently disable all telemetry collection. disable for just this invocation. disable via environment (great for ci/cd). see exactly what data is queued before sending. we understand many users work in environments without network access. caro works perfectly offline‚Äîthat's a core feature. simply disable telemetry and use caro normally. no data is collected or stored. enable air-gapped mode to collect telemetry locally. when you're ready, export the data and share it with us through our secure portal. manual export/upload workflow planned for future release. this page documents exactly what we collect. the code is open source for verification. we collect metadata, not content. your commands and data never leave your machine. if you disable telemetry, we respect that completely. no nagging, no degraded features. üìä understand real-world usage which commands are generated most? which backends perform best? where do users struggle? üéØ prioritize our roadmap focus engineering effort on features people actually use, not what we assume they want. ‚ö° optimize performance identify slow inference, errors, and bottlenecks across different platforms. üõ°Ô∏è calibrate safety are we blocking too many safe commands? missing dangerous ones? data helps us tune. session timing (duration, commands generated/executed) performance metrics (inference time, backend used) platform info (os, architecture, shell type) error categories (not details or stack traces) safety validation events (risk level, action taken) anonymous session id (rotates daily) your commands or natural language inputs file paths or directory structures environment variables or secrets hostnames, ips, or usernames any personally identifiable information command output or execution results telemetry & privacy privacy-first by design. transparent by choice. tl;dr beta (current) opt-out telemetry is enabled by default to help us improve the product. you can easily disable it. general availability opt-in telemetry will be disabled by default . we'll ask if you'd like to help by enabling it. why we collect telemetry we're building caro to be the best ai shell assistant. during beta, anonymous usage data helps us: üìä understand real-world usage which commands are generated most? which backends perform best? where do users struggle? üéØ prioritize our roadmap focus engineering effort on features people actually use, not what we assume they want. ‚ö° optimize performance identify slow inference, errors, and bottlenecks across different platforms. üõ°Ô∏è calibrate safety are we blocking too many safe commands? missing dangerous ones? data helps us tune. what we collect ‚úì what we collect session timing (duration, commands generated/executed) performance metrics (inference time, backend used) platform info (os, architecture, shell type) error categories (not details or stack traces) safety validation events (risk level, action taken) anonymous session id (rotates daily) ‚úó what we never collect your commands or natural language inputs file paths or directory structures environment variables or secrets hostnames, ips, or usernames any personally identifiable information command output or execution results don't trust, verify: caro is open source (agpl-3.0) . check the telemetry code yourself in . your controls disable telemetry permanently disable all telemetry collection. single session disable for just this invocation. environment variable disable via environment (great for ci/cd). view what's collected see exactly what data is queued before sending. air-gapped environments we understand many users work in environments without network access. caro works perfectly offline‚Äîthat's a core feature. option 1: disable telemetry simply disable telemetry and use caro normally. no data is collected or stored. option 2: air-gapped mode (coming soon) enable air-gapped mode to collect telemetry locally. when you're ready, export the data and share it with us through our secure portal. manual export/upload workflow planned for future release. our commitment 1 transparency this page documents exactly what we collect. the code is open source for verification. 2 privacy-first we collect metadata, not content. your commands and data never leave your machine. 3 respect if you disable telemetry, we respect that completely. no nagging, no degraded features. 4 evolution after beta, telemetry becomes opt-in. we'll ask nicely, but the default is off. frequently asked questions why is telemetry on by default during beta? beta is specifically for gathering feedback to improve the product before general availability. anonymous usage data helps us understand how caro is used in the real world, identify bugs, and prioritize features. this is standard practice for beta software. when will telemetry become opt-in? at general availability (ga) release, telemetry will be disabled by default. we'll prompt new users to optionally enable it, explaining the value exchange: you help us improve the product, we make caro better for everyone. can you identify me from the telemetry data? no. we use an anonymous session id that's generated from a hash of your machine id plus the current date. this means: (1) we can't identify who you are, and (2) the id rotates daily, so we can't even track the same anonymous user across days. what happens to my data? telemetry is processed by posthog , a privacy-focused analytics platform. data is used only for product analytics and is retained for 90 days (raw events) or 2 years (aggregated metrics). you can request deletion by contacting us. does disabling telemetry affect functionality? no. caro works identically with or without telemetry. all features, all backends, full performance. we believe in earning telemetry through value, not coercing it through feature gates. i work in a regulated environment. can i still use caro? yes! disable telemetry and use caro with complete confidence. nothing is sent anywhere. all inference happens locally. you can audit the source code‚Äîit's agpl-3.0 licensed. questions? we're committed to being transparent about telemetry. if you have questions, concerns, or suggestions about our approach, please reach out. open an issue join discussion",
      "_words": [
        "telemetry",
        "disable",
        "collect",
        "data",
        "caro",
        "privacy",
        "your",
        "beta",
        "opt",
        "commands",
        "anonymous",
        "use",
        "default",
        "session",
        "our",
        "environment",
        "air",
        "gapped",
        "questions",
        "first",
        "features",
        "product",
        "identify",
        "option",
        "helps",
        "generated",
        "users",
        "inference",
        "open",
        "source",
        "help",
        "improve",
        "usage",
        "code",
        "understand",
        "through",
        "performance",
        "general",
        "availability",
        "out",
        "never",
        "collected",
        "environments",
        "mode",
        "respect",
        "transparent",
        "best",
        "backends",
        "across",
        "many",
        "agpl",
        "design",
        "choice",
        "controls",
        "single",
        "variable",
        "view",
        "coming",
        "soon",
        "commitment",
        "transparency",
        "evolution",
        "frequently",
        "asked",
        "current",
        "disabled",
        "ask",
        "shell",
        "during",
        "real",
        "world",
        "prioritize",
        "safety",
        "metrics",
        "platform",
        "events",
        "rotates",
        "daily",
        "exactly",
        "before",
        "work",
        "without",
        "works",
        "feature",
        "enable",
        "locally",
        "export",
        "release",
        "machine",
        "value",
        "days",
        "happens",
        "analytics",
        "about",
        "enabled",
        "easily",
        "like",
        "enabling",
        "building",
        "assistant"
      ]
    },
    {
      "title": "Offline AI Assistance",
      "path": "/use-cases/air-gapped",
      "description": "Get AI-powered command generation where no other AI tool can operate.",
      "category": "use-cases",
      "keywords": [
        "caro",
        "security",
        "verify",
        "network",
        "offline",
        "binary",
        "environments",
        "audit",
        "zero",
        "get",
        "secure",
        "checksums",
        "releases",
        "source",
        "built",
        "designed",
        "documentation",
        "calls",
        "dns",
        "open",
        "cloud",
        "air",
        "gapped",
        "operate",
        "trigger",
        "pain",
        "policy",
        "license",
        "agpl",
        "full",
        "code",
        "100",
        "nothing",
        "else",
        "jobs",
        "action",
        "getting",
        "approved",
        "deployment",
        "options",
        "yourself",
        "integrity",
        "lookups",
        "ports",
        "million",
        "developers",
        "work",
        "restricted",
        "impossible",
        "shell"
      ],
      "icon": "üîê",
      "content": {
        "headings": [
          "AI Where Nothing Else Can Operate",
          "Built for These Environments",
          "Jobs Caro Does in Secure Environments",
          "Offline AI in Action",
          "Designed for Security Audit",
          "Getting Caro Approved",
          "Security Documentation",
          "Deployment Options",
          "Verify It Yourself",
          "Verify Zero Network Calls",
          "Verify Binary Integrity",
          "Verify No DNS Lookups",
          "Verify Open Ports"
        ],
        "paragraphs": [
          "8 million developers work in restricted environments where cloud AI is impossible. Caro is the only AI shell assistant that works with zero network connectivity‚Äî bundled model, single binary, designed for security audit.",
          "Where cloud AI isn't an option",
          "What you hire Caro to do when offline",
          "Trigger:",
          "Real scenarios where Caro shines",
          "Scenario:",
          "Why it matters:",
          "Every feature built with compliance in mind",
          "Audit:",
          "Answers to common security review questions",
          "How to get Caro into your secure environment",
          "Don't trust us‚Äîverify these claims",
          "Run under strace. You'll see zero network-related syscalls.",
          "Compare against published checksums on GitHub releases.",
          "No DNS resolution functions called.",
          "Caro opens no listening sockets."
        ],
        "listItems": []
      },
      "fullText": "Air-Gapped & Security AI Where Nothing Else Can Operate 8 million developers work in restricted environments where cloud AI is impossible. Caro is the only AI shell assistant that works with zero network connectivity‚Äî bundled model, single binary, designed for security audit. 0 Network calls 1 Binary file 100% Open source Get the Binary Security Documentation Built for These Environments Where cloud AI isn't an option ))} ))} Jobs Caro Does in Secure Environments What you hire Caro to do when offline class=\"job-card\"> Pain: Trigger: ))} Offline AI in Action Real scenarios where Caro shines Scenario: Air-Gapped Terminal $ Caro: ‚úàÔ∏è Running fully offline - no network required Why it matters: ))} Designed for Security Audit Every feature built with compliance in mind Audit: ))} Getting Caro Approved Answers to common security review questions ‚úÖ ))} Security Documentation üìÑ Security Policy üìú License (AGPL-3.0) üíª Full Source Code üì¶ Releases + Checksums Deployment Options How to get Caro into your secure environment ))} ))} Verify It Yourself Don't trust us‚Äîverify these claims Verify Zero Network Calls Run under strace. You'll see zero network-related syscalls. Verify Binary Integrity Compare against published checksums on GitHub releases. Verify No DNS Lookups No DNS resolution functions called. Verify Open Ports Caro opens no listening sockets.",
      "_searchText": "offline ai assistance get ai-powered command generation where no other ai tool can operate. /use-cases/air-gapped caro security verify network offline binary environments audit zero get secure checksums releases source built designed documentation calls dns open cloud air gapped operate trigger pain policy license agpl full code 100 nothing else jobs action getting approved deployment options yourself integrity lookups ports million developers work restricted impossible shell ai where nothing else can operate built for these environments jobs caro does in secure environments offline ai in action designed for security audit getting caro approved security documentation deployment options verify it yourself verify zero network calls verify binary integrity verify no dns lookups verify open ports 8 million developers work in restricted environments where cloud ai is impossible. caro is the only ai shell assistant that works with zero network connectivity‚Äî bundled model, single binary, designed for security audit. where cloud ai isn't an option what you hire caro to do when offline trigger: real scenarios where caro shines scenario: why it matters: every feature built with compliance in mind audit: answers to common security review questions how to get caro into your secure environment don't trust us‚Äîverify these claims run under strace. you'll see zero network-related syscalls. compare against published checksums on github releases. no dns resolution functions called. caro opens no listening sockets. air-gapped & security ai where nothing else can operate 8 million developers work in restricted environments where cloud ai is impossible. caro is the only ai shell assistant that works with zero network connectivity‚Äî bundled model, single binary, designed for security audit. 0 network calls 1 binary file 100% open source get the binary security documentation built for these environments where cloud ai isn't an option ))} ))} jobs caro does in secure environments what you hire caro to do when offline class=\"job-card\"> pain: trigger: ))} offline ai in action real scenarios where caro shines scenario: air-gapped terminal $ caro: ‚úàÔ∏è running fully offline - no network required why it matters: ))} designed for security audit every feature built with compliance in mind audit: ))} getting caro approved answers to common security review questions ‚úÖ ))} security documentation üìÑ security policy üìú license (agpl-3.0) üíª full source code üì¶ releases + checksums deployment options how to get caro into your secure environment ))} ))} verify it yourself don't trust us‚Äîverify these claims verify zero network calls run under strace. you'll see zero network-related syscalls. verify binary integrity compare against published checksums on github releases. verify no dns lookups no dns resolution functions called. verify open ports caro opens no listening sockets.",
      "_words": [
        "verify",
        "caro",
        "security",
        "network",
        "offline",
        "binary",
        "environments",
        "audit",
        "zero",
        "get",
        "operate",
        "secure",
        "built",
        "designed",
        "documentation",
        "calls",
        "dns",
        "open",
        "checksums",
        "releases",
        "source",
        "cloud",
        "air",
        "gapped",
        "nothing",
        "else",
        "jobs",
        "action",
        "getting",
        "approved",
        "deployment",
        "options",
        "yourself",
        "integrity",
        "lookups",
        "ports",
        "100",
        "trigger",
        "pain",
        "policy",
        "license",
        "agpl",
        "full",
        "code",
        "million",
        "developers",
        "work",
        "restricted",
        "impossible",
        "shell",
        "assistance",
        "powered",
        "command",
        "generation",
        "tool",
        "assistant",
        "works",
        "connectivity",
        "bundled",
        "model",
        "single",
        "file",
        "isn",
        "option",
        "hire",
        "class",
        "job",
        "card",
        "real",
        "scenarios",
        "shines",
        "scenario",
        "terminal",
        "running",
        "fully",
        "required",
        "matters",
        "feature",
        "compliance",
        "mind",
        "answers",
        "common",
        "review",
        "questions",
        "into",
        "your",
        "environment",
        "don",
        "trust",
        "claims",
        "run",
        "under",
        "strace",
        "see",
        "related",
        "syscalls",
        "compare",
        "against",
        "published",
        "github"
      ]
    },
    {
      "title": "Natural Language to Command",
      "path": "/use-cases/developer",
      "description": "Describe what you want in plain English, get the exact command that works.",
      "category": "use-cases",
      "keywords": [
        "caro",
        "commands",
        "your",
        "command",
        "learn",
        "developers",
        "terminal",
        "experience",
        "natural",
        "language",
        "get",
        "works",
        "current",
        "common",
        "work",
        "developer",
        "years",
        "stack",
        "start",
        "learning",
        "build",
        "examples",
        "down",
        "grow",
        "shell",
        "directory",
        "try",
        "describe",
        "want",
        "english",
        "exact",
        "context",
        "safety",
        "flags",
        "trigger",
        "complex",
        "into",
        "knows",
        "first",
        "operations",
        "pain",
        "full",
        "stop",
        "googling",
        "commanding",
        "jobs",
        "zero",
        "steps",
        "don",
        "copy"
      ],
      "icon": "üíª",
      "content": {
        "headings": [
          "Stop Googling. Start Commanding.",
          "Jobs Caro Does for Developers",
          "From Zero to Command in 4 Steps",
          "Natural Language to Commands",
          "Learn Commands, Don't Just Copy Them",
          "Mistakes Caro Helps You Avoid",
          "Caro vs. Your Current Workflow",
          "Built for Learning",
          "--explain Mode",
          "Context Awareness",
          "Safety Guardrails",
          "Instant Results",
          "History Learning",
          "Progressive Complexity",
          "From Developers Like You"
        ],
        "paragraphs": [
          "Know what you want but can't remember the exact flags? Describe it in English, get the command that works. Build terminal confidence while staying safe.",
          "What you hire Caro to do",
          "Trigger:",
          "Get started in under a minute",
          "))} Natural Language to Commands 50+ examples across common tasks",
          "Caro breaks down complex commands so you understand each part",
          "Learn from common pitfalls",
          "Time spent getting commands to work",
          "Features that help you grow",
          "Break down any command into understandable parts. Learn what each flag does.",
          "Caro knows your OS, shell, and current directory. Commands work first try.",
          "Learn good habits from day one. Caro warns before dangerous operations.",
          "Runs locally on your machine. No waiting for API calls. Works offline.",
          "Build your personal command library. Caro remembers what worked.",
          "Start simple, grow advanced. Caro matches your skill level."
        ],
        "listItems": []
      },
      "fullText": "For Developers Stop Googling. Start Commanding. Know what you want but can't remember the exact flags? Describe it in English, get the command that works. Build terminal confidence while staying safe. \"I've learned more shell in a week with Caro than in a year of Stack Overflow. The explanations actually teach you why commands work.\" ‚Äî Jamie L., Full-Stack Developer Try in 30 Seconds See Examples Jobs Caro Does for Developers What you hire Caro to do class=\"job-card\"> Pain: Trigger: ))} From Zero to Command in 4 Steps Get started in under a minute Terminal $ ))} Natural Language to Commands 50+ examples across common tasks \" ‚Üì Caro generates: üí° ))} ))} Learn Commands, Don't Just Copy Them Caro breaks down complex commands so you understand each part ))} )} )} ))} Mistakes Caro Helps You Avoid Learn from common pitfalls ))} Caro vs. Your Current Workflow Time spent getting commands to work Task With Caro Google/Stack Overflow Man Pages ))} The difference: Caro learns your context. It knows your OS, shell, and current directory. Google gives generic answers. Man pages give exhaustive documentation. Caro gives you what you need, now. Built for Learning Features that help you grow üìñ --explain Mode Break down any command into understandable parts. Learn what each flag does. üéØ Context Awareness Caro knows your OS, shell, and current directory. Commands work first try. üõ°Ô∏è Safety Guardrails Learn good habits from day one. Caro warns before dangerous operations. ‚ö° Instant Results Runs locally on your machine. No waiting for API calls. Works offline. üîÑ History Learning Build your personal command library. Caro remembers what worked. üéì Progressive Complexity Start simple, grow advanced. Caro matches your skill level. From Developers Like You \"I used to dread the terminal. Now I actually enjoy figuring out complex file operations. Caro's explanations turned confusion into curiosity.\" Alex R. Junior Developer, 6 months experience \"Even after 10 years, I still forget grep flags. Caro is faster than my muscle memory for anything beyond basic searches.\" Sarah K. Senior Engineer, 10 years experience \"The safety warnings have saved me twice already. Once from deleting my ~/.ssh directory, once from chmod 777 on my whole project.\" Marcus T. Full-Stack Developer, 2 years experience",
      "_searchText": "natural language to command describe what you want in plain english, get the exact command that works. /use-cases/developer caro commands your command learn developers terminal experience natural language get works current common work developer years stack start learning build examples down grow shell directory try describe want english exact context safety flags trigger complex into knows first operations pain full stop googling commanding jobs zero steps don copy stop googling. start commanding. jobs caro does for developers from zero to command in 4 steps natural language to commands learn commands, don't just copy them mistakes caro helps you avoid caro vs. your current workflow built for learning --explain mode context awareness safety guardrails instant results history learning progressive complexity from developers like you know what you want but can't remember the exact flags? describe it in english, get the command that works. build terminal confidence while staying safe. what you hire caro to do trigger: get started in under a minute ))} natural language to commands 50+ examples across common tasks caro breaks down complex commands so you understand each part learn from common pitfalls time spent getting commands to work features that help you grow break down any command into understandable parts. learn what each flag does. caro knows your os, shell, and current directory. commands work first try. learn good habits from day one. caro warns before dangerous operations. runs locally on your machine. no waiting for api calls. works offline. build your personal command library. caro remembers what worked. start simple, grow advanced. caro matches your skill level. for developers stop googling. start commanding. know what you want but can't remember the exact flags? describe it in english, get the command that works. build terminal confidence while staying safe. \"i've learned more shell in a week with caro than in a year of stack overflow. the explanations actually teach you why commands work.\" ‚Äî jamie l., full-stack developer try in 30 seconds see examples jobs caro does for developers what you hire caro to do class=\"job-card\"> pain: trigger: ))} from zero to command in 4 steps get started in under a minute terminal $ ))} natural language to commands 50+ examples across common tasks \" ‚Üì caro generates: üí° ))} ))} learn commands, don't just copy them caro breaks down complex commands so you understand each part ))} )} )} ))} mistakes caro helps you avoid learn from common pitfalls ))} caro vs. your current workflow time spent getting commands to work task with caro google/stack overflow man pages ))} the difference: caro learns your context. it knows your os, shell, and current directory. google gives generic answers. man pages give exhaustive documentation. caro gives you what you need, now. built for learning features that help you grow üìñ --explain mode break down any command into understandable parts. learn what each flag does. üéØ context awareness caro knows your os, shell, and current directory. commands work first try. üõ°Ô∏è safety guardrails learn good habits from day one. caro warns before dangerous operations. ‚ö° instant results runs locally on your machine. no waiting for api calls. works offline. üîÑ history learning build your personal command library. caro remembers what worked. üéì progressive complexity start simple, grow advanced. caro matches your skill level. from developers like you \"i used to dread the terminal. now i actually enjoy figuring out complex file operations. caro's explanations turned confusion into curiosity.\" alex r. junior developer, 6 months experience \"even after 10 years, i still forget grep flags. caro is faster than my muscle memory for anything beyond basic searches.\" sarah k. senior engineer, 10 years experience \"the safety warnings have saved me twice already. once from deleting my ~/.ssh directory, once from chmod 777 on my whole project.\" marcus t. full-stack developer, 2 years experience",
      "_words": [
        "caro",
        "commands",
        "your",
        "command",
        "learn",
        "developers",
        "current",
        "stack",
        "learning",
        "natural",
        "language",
        "get",
        "works",
        "terminal",
        "experience",
        "work",
        "developer",
        "years",
        "start",
        "shell",
        "directory",
        "context",
        "safety",
        "describe",
        "want",
        "english",
        "exact",
        "common",
        "build",
        "examples",
        "down",
        "grow",
        "try",
        "flags",
        "complex",
        "into",
        "knows",
        "operations",
        "full",
        "stop",
        "googling",
        "commanding",
        "jobs",
        "zero",
        "steps",
        "don",
        "copy",
        "trigger",
        "first",
        "pain",
        "them",
        "mistakes",
        "helps",
        "avoid",
        "workflow",
        "built",
        "explain",
        "mode",
        "awareness",
        "guardrails",
        "instant",
        "results",
        "history",
        "progressive",
        "complexity",
        "like",
        "overflow",
        "explanations",
        "actually",
        "google",
        "man",
        "pages",
        "gives",
        "once",
        "777",
        "plain",
        "know",
        "remember",
        "confidence",
        "while",
        "staying",
        "safe",
        "learned",
        "week",
        "year",
        "teach",
        "jamie",
        "seconds",
        "see",
        "hire",
        "class",
        "job",
        "card",
        "started",
        "under",
        "minute",
        "across",
        "tasks",
        "generates",
        "breaks"
      ]
    },
    {
      "title": "CI/CD Pipeline Health Check",
      "path": "/use-cases/devops",
      "description": "Check deployment status across services",
      "category": "use-cases",
      "keywords": [
        "caro",
        "commands",
        "linux",
        "your",
        "target",
        "posix",
        "platform",
        "find",
        "bsd",
        "gnu",
        "work",
        "time",
        "devops",
        "output",
        "mac",
        "macos",
        "first",
        "integration",
        "stop",
        "differences",
        "compliant",
        "machine",
        "files",
        "changed",
        "last",
        "hour",
        "type",
        "pipeline",
        "trigger",
        "pain",
        "check",
        "everywhere",
        "jobs",
        "problem",
        "solves",
        "automation",
        "script",
        "examples",
        "natural",
        "language",
        "turn",
        "use",
        "mode",
        "specific",
        "json",
        "scripts",
        "fighting",
        "detects",
        "generates",
        "pipelines"
      ],
      "icon": "üîß",
      "content": {
        "headings": [
          "Commands That Work Everywhere, First Time",
          "Jobs Caro Does for DevOps",
          "The BSD vs GNU Problem",
          "How Caro Solves This",
          "Automation Script Examples",
          "Natural Language ‚Üí Commands",
          "Your Turn",
          "CI/CD Pipeline Integration",
          "Use POSIX Mode",
          "Target Specific Platform",
          "JSON Output for Scripts"
        ],
        "paragraphs": [
          "Stop fighting BSD vs GNU differences. Caro detects your target platform and generates POSIX-compliant commands that work on Mac, Linux, and in CI pipelines‚Äîfirst time, every time.",
          "What you hire Caro to do",
          "Trigger:",
          "Commands you write on Mac break on Linux servers",
          "Common DevOps tasks, generated and validated",
          "Stop Googling. Just describe what you want.",
          "Install Caro and try:",
          "Commands that work in GitHub Actions, GitLab CI, Jenkins",
          "Forces POSIX-compliant output that works in any sh-compatible environment.",
          "Generate commands for your CI runner's OS, not your dev machine.",
          "Machine-readable output for integration with other tools."
        ],
        "listItems": []
      },
      "fullText": "DevOps & Platform Commands That Work Everywhere, First Time Stop fighting BSD vs GNU differences. Caro detects your target platform and generates POSIX-compliant commands that work on Mac, Linux, and in CI pipelines‚Äîfirst time, every time. Target: macOS (BSD) Linux (GNU) POSIX Get Started Free See Platform Differences Jobs Caro Does for DevOps What you hire Caro to do class=\"job-card\"> Pain: Trigger: ))} The BSD vs GNU Problem Commands you write on Mac break on Linux servers Task macOS (BSD) Linux (GNU) Gotcha ))} How Caro Solves This Your Mac $ caro \"find files changed in last hour\" Caro (macOS detected): find . -mtime -1h -type f ‚Üì For Linux Server $ caro --target linux \"find files changed in last hour\" Caro (Linux target): find . -mmin -60 -type f Automation Script Examples Common DevOps tasks, generated and validated > $ ‚Üí )} ))} Natural Language ‚Üí Commands Stop Googling. Just describe what you want. \" ‚Üì ))} Your Turn Install Caro and try: CI/CD Pipeline Integration Commands that work in GitHub Actions, GitLab CI, Jenkins Use POSIX Mode Forces POSIX-compliant output that works in any sh-compatible environment. Target Specific Platform Generate commands for your CI runner's OS, not your dev machine. JSON Output for Scripts Machine-readable output for integration with other tools.",
      "_searchText": "ci/cd pipeline health check check deployment status across services /use-cases/devops caro commands linux your target posix platform find bsd gnu work time devops output mac macos first integration stop differences compliant machine files changed last hour type pipeline trigger pain check everywhere jobs problem solves automation script examples natural language turn use mode specific json scripts fighting detects generates pipelines commands that work everywhere, first time jobs caro does for devops the bsd vs gnu problem how caro solves this automation script examples natural language ‚Üí commands your turn ci/cd pipeline integration use posix mode target specific platform json output for scripts stop fighting bsd vs gnu differences. caro detects your target platform and generates posix-compliant commands that work on mac, linux, and in ci pipelines‚Äîfirst time, every time. what you hire caro to do trigger: commands you write on mac break on linux servers common devops tasks, generated and validated stop googling. just describe what you want. install caro and try: commands that work in github actions, gitlab ci, jenkins forces posix-compliant output that works in any sh-compatible environment. generate commands for your ci runner's os, not your dev machine. machine-readable output for integration with other tools. devops & platform commands that work everywhere, first time stop fighting bsd vs gnu differences. caro detects your target platform and generates posix-compliant commands that work on mac, linux, and in ci pipelines‚Äîfirst time, every time. target: macos (bsd) linux (gnu) posix get started free see platform differences jobs caro does for devops what you hire caro to do class=\"job-card\"> pain: trigger: ))} the bsd vs gnu problem commands you write on mac break on linux servers task macos (bsd) linux (gnu) gotcha ))} how caro solves this your mac $ caro \"find files changed in last hour\" caro (macos detected): find . -mtime -1h -type f ‚Üì for linux server $ caro --target linux \"find files changed in last hour\" caro (linux target): find . -mmin -60 -type f automation script examples common devops tasks, generated and validated > $ ‚Üí )} ))} natural language ‚Üí commands stop googling. just describe what you want. \" ‚Üì ))} your turn install caro and try: ci/cd pipeline integration commands that work in github actions, gitlab ci, jenkins use posix mode forces posix-compliant output that works in any sh-compatible environment. target specific platform generate commands for your ci runner's os, not your dev machine. json output for scripts machine-readable output for integration with other tools.",
      "_words": [
        "caro",
        "commands",
        "linux",
        "your",
        "target",
        "posix",
        "platform",
        "bsd",
        "gnu",
        "find",
        "work",
        "time",
        "devops",
        "output",
        "pipeline",
        "mac",
        "macos",
        "first",
        "integration",
        "check",
        "stop",
        "differences",
        "compliant",
        "machine",
        "files",
        "changed",
        "last",
        "hour",
        "type",
        "everywhere",
        "jobs",
        "problem",
        "solves",
        "automation",
        "script",
        "examples",
        "natural",
        "language",
        "turn",
        "use",
        "mode",
        "specific",
        "json",
        "scripts",
        "trigger",
        "pain",
        "fighting",
        "detects",
        "generates",
        "pipelines",
        "health",
        "deployment",
        "status",
        "across",
        "services",
        "get",
        "started",
        "free",
        "see",
        "hire",
        "class",
        "job",
        "card",
        "write",
        "break",
        "servers",
        "task",
        "gotcha",
        "detected",
        "mtime",
        "server",
        "mmin",
        "common",
        "tasks",
        "generated",
        "validated",
        "googling",
        "describe",
        "want",
        "install",
        "try",
        "github",
        "actions",
        "gitlab",
        "jenkins",
        "forces",
        "works",
        "any",
        "compatible",
        "environment",
        "generate",
        "runner",
        "dev",
        "readable",
        "tools"
      ]
    },
    {
      "title": "SRE & On-Call Engineers",
      "path": "/use-cases",
      "description": "Validate dangerous commands before they destroy production. Get instant, safe command generation during high-pressure incidents.",
      "category": "use-cases",
      "keywords": [
        "caro",
        "commands",
        "jobs",
        "specific",
        "your",
        "work",
        "see",
        "safety",
        "pain",
        "find",
        "role",
        "people",
        "environments",
        "designed",
        "production",
        "safe",
        "during",
        "incidents",
        "independent",
        "layer",
        "offline",
        "platform",
        "severity",
        "based",
        "pattern",
        "zero",
        "install",
        "works",
        "air",
        "shell",
        "bsd",
        "gnu",
        "awareness",
        "detailed",
        "comparisons",
        "examples",
        "best",
        "true",
        "operation",
        "intelligence",
        "fast",
        "matters",
        "compares",
        "isn",
        "general",
        "assistant",
        "specialized",
        "tool",
        "run",
        "restricted"
      ],
      "icon": "üìã",
      "content": {
        "headings": [
          "What Do You Need Caro To Do?",
          "Find Your Role",
          "Jobs Caro Does Best",
          "Why Caro For These Jobs?",
          "üîí Independent Safety Layer",
          "‚úàÔ∏è True Offline Operation",
          "üåê Platform Intelligence",
          "‚ö° Fast When It Matters",
          "How Caro Compares"
        ],
        "paragraphs": [
          "Caro isn't a general AI assistant‚Äîit's a specialized tool for people who run commands in production, work in restricted environments, or just want commands that actually work.",
          "Find your role below, or explore the specific jobs Caro excels at.",
          "Caro is designed for specific people with specific problems",
          "Ranked by pain severity and frequency",
          "Unlike permission flags or AI-based safety, Caro uses deterministic pattern matching that can't hallucinate. When AI marks as \"safe,\" Caro catches it.",
          "Bundled model. Zero network calls after install. Works in air-gapped environments where nothing else can . Designed for security audit from day one.",
          "Detects your OS, shell, and available commands. Generates POSIX-compliant commands with BSD vs GNU awareness. Commands work everywhere, first time.",
          "<100ms startup, <2s inference on Apple Silicon. No waiting for cloud APIs during incidents. No wondering if the server is down.",
          "Purpose-built for these specific jobs",
          "See detailed comparisons ‚Üí"
        ],
        "listItems": []
      },
      "fullText": "Jobs To Be Done What Do You Need Caro To Do? Caro isn't a general AI assistant‚Äîit's a specialized tool for people who run commands in production, work in restricted environments, or just want commands that actually work. Find your role below, or explore the specific jobs Caro excels at. Find Your Role Caro is designed for specific people with specific problems class=persona-card $ style=--accent-color: $ > Jobs: ))} See examples ‚Üí ))} Jobs Caro Does Best Ranked by pain severity and frequency Pain: ))} Why Caro For These Jobs? üîí Independent Safety Layer Unlike permission flags or AI-based safety, Caro uses deterministic pattern matching that can't hallucinate. When AI marks as \"safe,\" Caro catches it. ‚úàÔ∏è True Offline Operation Bundled model. Zero network calls after install. Works in air-gapped environments where nothing else can . Designed for security audit from day one. üåê Platform Intelligence Detects your OS, shell, and available commands. Generates POSIX-compliant commands with BSD vs GNU awareness. Commands work everywhere, first time. ‚ö° Fast When It Matters <100ms startup, <2s inference on Apple Silicon. No waiting for cloud APIs during incidents. No wondering if the server is down. How Caro Compares Purpose-built for these specific jobs Capability Caro GitHub Copilot CLI Warp AI Generic LLM Works Offline ‚úì Full ‚úó ‚úó ‚úó Independent Safety Layer ‚úì Pattern-based ‚úó ‚úó ‚úó Air-Gap Compatible ‚úì ‚úó ‚úó ‚úó BSD/GNU Awareness ‚úì Partial ‚úó Limited Platform Detection ‚úì Partial ‚úó ‚úó Single Binary Install ‚úì ‚úó ‚úó ‚úó Zero Telemetry ‚úì ‚úó ‚úó ‚úó Open Source ‚úì AGPL-3.0 ‚úó ‚úó Varies See detailed comparisons ‚Üí",
      "_searchText": "sre & on-call engineers validate dangerous commands before they destroy production. get instant, safe command generation during high-pressure incidents. /use-cases caro commands jobs specific your work see safety pain find role people environments designed production safe during incidents independent layer offline platform severity based pattern zero install works air shell bsd gnu awareness detailed comparisons examples best true operation intelligence fast matters compares isn general assistant specialized tool run restricted what do you need caro to do? find your role jobs caro does best why caro for these jobs? üîí independent safety layer ‚úàÔ∏è true offline operation üåê platform intelligence ‚ö° fast when it matters how caro compares caro isn't a general ai assistant‚Äîit's a specialized tool for people who run commands in production, work in restricted environments, or just want commands that actually work. find your role below, or explore the specific jobs caro excels at. caro is designed for specific people with specific problems ranked by pain severity and frequency unlike permission flags or ai-based safety, caro uses deterministic pattern matching that can't hallucinate. when ai marks as \"safe,\" caro catches it. bundled model. zero network calls after install. works in air-gapped environments where nothing else can . designed for security audit from day one. detects your os, shell, and available commands. generates posix-compliant commands with bsd vs gnu awareness. commands work everywhere, first time. <100ms startup, <2s inference on apple silicon. no waiting for cloud apis during incidents. no wondering if the server is down. purpose-built for these specific jobs see detailed comparisons ‚Üí jobs to be done what do you need caro to do? caro isn't a general ai assistant‚Äîit's a specialized tool for people who run commands in production, work in restricted environments, or just want commands that actually work. find your role below, or explore the specific jobs caro excels at. find your role caro is designed for specific people with specific problems class=persona-card $ style=--accent-color: $ > jobs: ))} see examples ‚Üí ))} jobs caro does best ranked by pain severity and frequency pain: ))} why caro for these jobs? üîí independent safety layer unlike permission flags or ai-based safety, caro uses deterministic pattern matching that can't hallucinate. when ai marks as \"safe,\" caro catches it. ‚úàÔ∏è true offline operation bundled model. zero network calls after install. works in air-gapped environments where nothing else can . designed for security audit from day one. üåê platform intelligence detects your os, shell, and available commands. generates posix-compliant commands with bsd vs gnu awareness. commands work everywhere, first time. ‚ö° fast when it matters <100ms startup, <2s inference on apple silicon. no waiting for cloud apis during incidents. no wondering if the server is down. how caro compares purpose-built for these specific jobs capability caro github copilot cli warp ai generic llm works offline ‚úì full ‚úó ‚úó ‚úó independent safety layer ‚úì pattern-based ‚úó ‚úó ‚úó air-gap compatible ‚úì ‚úó ‚úó ‚úó bsd/gnu awareness ‚úì partial ‚úó limited platform detection ‚úì partial ‚úó ‚úó single binary install ‚úì ‚úó ‚úó ‚úó zero telemetry ‚úì ‚úó ‚úó ‚úó open source ‚úì agpl-3.0 ‚úó ‚úó varies see detailed comparisons ‚Üí",
      "_words": [
        "caro",
        "jobs",
        "commands",
        "specific",
        "your",
        "safety",
        "work",
        "find",
        "role",
        "independent",
        "layer",
        "offline",
        "platform",
        "production",
        "safe",
        "during",
        "incidents",
        "see",
        "pain",
        "people",
        "environments",
        "designed",
        "based",
        "pattern",
        "zero",
        "install",
        "works",
        "air",
        "bsd",
        "gnu",
        "awareness",
        "best",
        "true",
        "operation",
        "intelligence",
        "fast",
        "matters",
        "compares",
        "severity",
        "shell",
        "detailed",
        "comparisons",
        "examples",
        "isn",
        "general",
        "assistant",
        "specialized",
        "tool",
        "run",
        "restricted",
        "partial",
        "sre",
        "call",
        "engineers",
        "validate",
        "dangerous",
        "before",
        "destroy",
        "get",
        "instant",
        "command",
        "generation",
        "high",
        "pressure",
        "done",
        "want",
        "actually",
        "below",
        "explore",
        "excels",
        "problems",
        "class",
        "persona",
        "card",
        "style",
        "accent",
        "color",
        "ranked",
        "frequency",
        "unlike",
        "permission",
        "flags",
        "uses",
        "deterministic",
        "matching",
        "hallucinate",
        "marks",
        "catches",
        "bundled",
        "model",
        "network",
        "calls",
        "after",
        "gapped",
        "nothing",
        "else",
        "security",
        "audit",
        "day",
        "one"
      ]
    },
    {
      "title": "Safe Production Command Execution",
      "path": "/use-cases/sre",
      "description": "Validate commands against 52+ dangerous patterns before they can destroy production.",
      "category": "use-cases",
      "keywords": [
        "caro",
        "see",
        "production",
        "incident",
        "pattern",
        "safe",
        "real",
        "based",
        "catches",
        "patterns",
        "call",
        "commands",
        "make",
        "things",
        "safety",
        "examples",
        "don",
        "command",
        "before",
        "your",
        "companion",
        "sres",
        "sre",
        "trigger",
        "full",
        "list",
        "pain",
        "marked",
        "dangerous",
        "jobs",
        "scenarios",
        "face",
        "response",
        "runbooks",
        "gets",
        "wrong",
        "beats",
        "block",
        "const",
        "sleep",
        "deprived",
        "fire",
        "validates",
        "worse",
        "doesn",
        "depend",
        "judgement",
        "hire",
        "handles",
        "actual"
      ],
      "icon": "üö®",
      "content": {
        "headings": [
          "Your 3 AM Incident Companion",
          "Jobs Caro Does for SREs",
          "Real Scenarios You'll Face",
          "Incident Response Runbooks",
          "When AI Gets It Wrong",
          "Why Pattern-Based Beats AI-Based",
          "52+ Patterns We Block"
        ],
        "paragraphs": [
          "-n production | tail -20', explanation: 'Recent events (OOM, liveness failures, etc)', }, , , ], }, ]; const aiProtectionExamples = [ , , , ]; const blockedPatterns = [ , , ;:', desc: 'Fork bomb' }, , , , , , , , ]; --- SRE & On-Call Your 3 AM Incident Companion When you're sleep-deprived and production is on fire, Caro validates every command before it can make things worse. Pattern-based safety that doesn't depend on AI judgement.",
          "What you hire Caro to do",
          "Trigger:",
          "See how Caro handles actual production situations",
          "Context:",
          "Lesson:",
          "Common alerts and the commands you need",
          "Real examples of AI hallucinations Caro catches",
          "Same input = same result. No randomness, no \"sometimes catches it.\"",
          "You can see exactly which pattern triggered. Essential for post-incident review.",
          "Regex patterns don't make things up. They match or they don't.",
          "<50ms validation. No API call, no waiting.",
          "A sample of what Caro catches",
          "Plus: privilege escalation, network backdoors, history clearing, and more. See full list ‚Üí"
        ],
        "listItems": []
      },
      "fullText": "SRE & On-Call Your 3 AM Incident Companion When you're sleep-deprived and production is on fire, Caro validates every command before it can make things worse. Pattern-based safety that doesn't depend on AI judgement. \"Caught a recursive delete pattern I would have missed at 2 AM during an incident. The warning was specific enough that I understood WHY it was dangerous.\" ‚Äî Michael T., Senior SRE (Series C Fintech) Get Started Free See Real Examples Jobs Caro Does for SREs What you hire Caro to do class=\"job-card\"> Pain: Trigger: ))} Real Scenarios You'll Face See how Caro handles actual production situations > Context: Terminal $ Caro: üí° Safer alternative: ) : ( ‚úì )} Lesson: ))} Incident Response Runbooks Common alerts and the commands you need Copy ))} With Caro: Just describe what you need. Example: ))} When AI Gets It Wrong Real examples of AI hallucinations Caro catches ü§ñ AI Assistant Marked as \"Safe\" ‚Üí üõ°Ô∏è Caro Safety Layer üí° ))} Why Pattern-Based Beats AI-Based Deterministic Same input = same result. No randomness, no \"sometimes catches it.\" Auditable You can see exactly which pattern triggered. Essential for post-incident review. Can't Hallucinate Regex patterns don't make things up. They match or they don't. Fast <50ms validation. No API call, no waiting. 52+ Patterns We Block A sample of what Caro catches ))} Plus: privilege escalation, network backdoors, history clearing, and more. See full list ‚Üí",
      "_searchText": "safe production command execution validate commands against 52+ dangerous patterns before they can destroy production. /use-cases/sre caro see production incident pattern safe real based catches patterns call commands make things safety examples don command before your companion sres sre trigger full list pain marked dangerous jobs scenarios face response runbooks gets wrong beats block const sleep deprived fire validates worse doesn depend judgement hire handles actual your 3 am incident companion jobs caro does for sres real scenarios you'll face incident response runbooks when ai gets it wrong why pattern-based beats ai-based 52+ patterns we block -n production | tail -20', explanation: 'recent events (oom, liveness failures, etc)', }, , , ], }, ]; const aiprotectionexamples = [ , , , ]; const blockedpatterns = [ , , ;:', desc: 'fork bomb' }, , , , , , , , ]; --- sre & on-call your 3 am incident companion when you're sleep-deprived and production is on fire, caro validates every command before it can make things worse. pattern-based safety that doesn't depend on ai judgement. what you hire caro to do trigger: see how caro handles actual production situations context: lesson: common alerts and the commands you need real examples of ai hallucinations caro catches same input = same result. no randomness, no \"sometimes catches it.\" you can see exactly which pattern triggered. essential for post-incident review. regex patterns don't make things up. they match or they don't. <50ms validation. no api call, no waiting. a sample of what caro catches plus: privilege escalation, network backdoors, history clearing, and more. see full list ‚Üí sre & on-call your 3 am incident companion when you're sleep-deprived and production is on fire, caro validates every command before it can make things worse. pattern-based safety that doesn't depend on ai judgement. \"caught a recursive delete pattern i would have missed at 2 am during an incident. the warning was specific enough that i understood why it was dangerous.\" ‚Äî michael t., senior sre (series c fintech) get started free see real examples jobs caro does for sres what you hire caro to do class=\"job-card\"> pain: trigger: ))} real scenarios you'll face see how caro handles actual production situations > context: terminal $ caro: üí° safer alternative: ) : ( ‚úì )} lesson: ))} incident response runbooks common alerts and the commands you need copy ))} with caro: just describe what you need. example: ))} when ai gets it wrong real examples of ai hallucinations caro catches ü§ñ ai assistant marked as \"safe\" ‚Üí üõ°Ô∏è caro safety layer üí° ))} why pattern-based beats ai-based deterministic same input = same result. no randomness, no \"sometimes catches it.\" auditable you can see exactly which pattern triggered. essential for post-incident review. can't hallucinate regex patterns don't make things up. they match or they don't. fast <50ms validation. no api call, no waiting. 52+ patterns we block a sample of what caro catches ))} plus: privilege escalation, network backdoors, history clearing, and more. see full list ‚Üí",
      "_words": [
        "caro",
        "incident",
        "pattern",
        "based",
        "production",
        "patterns",
        "see",
        "real",
        "catches",
        "safe",
        "command",
        "commands",
        "dangerous",
        "before",
        "call",
        "make",
        "things",
        "safety",
        "examples",
        "don",
        "your",
        "companion",
        "sres",
        "sre",
        "jobs",
        "scenarios",
        "face",
        "response",
        "runbooks",
        "gets",
        "wrong",
        "beats",
        "block",
        "trigger",
        "full",
        "list",
        "pain",
        "marked",
        "sleep",
        "deprived",
        "fire",
        "validates",
        "worse",
        "doesn",
        "depend",
        "judgement",
        "hire",
        "handles",
        "actual",
        "execution",
        "validate",
        "against",
        "destroy",
        "const",
        "caught",
        "recursive",
        "delete",
        "missed",
        "during",
        "warning",
        "specific",
        "enough",
        "understood",
        "michael",
        "senior",
        "series",
        "fintech",
        "get",
        "started",
        "free",
        "class",
        "job",
        "card",
        "situations",
        "context",
        "terminal",
        "safer",
        "alternative",
        "lesson",
        "common",
        "alerts",
        "copy",
        "describe",
        "example",
        "hallucinations",
        "assistant",
        "layer",
        "deterministic",
        "input",
        "result",
        "randomness",
        "sometimes",
        "auditable",
        "exactly",
        "triggered",
        "essential",
        "post",
        "review",
        "hallucinate",
        "regex"
      ]
    },
    {
      "title": "Custom Pattern Library",
      "path": "/use-cases/tech-lead",
      "description": "Define organization-specific dangerous patterns. Block commands that are risky in YOUR environment.",
      "category": "use-cases",
      "keywords": [
        "caro",
        "patterns",
        "team",
        "your",
        "safety",
        "pattern",
        "based",
        "deterministic",
        "validation",
        "dangerous",
        "permission",
        "commands",
        "flags",
        "fail",
        "incidents",
        "safe",
        "shell",
        "custom",
        "tools",
        "tech",
        "leads",
        "configuration",
        "because",
        "works",
        "mcp",
        "make",
        "provides",
        "catches",
        "command",
        "real",
        "doesn",
        "production",
        "000",
        "day",
        "see",
        "config",
        "beats",
        "integration",
        "trigger",
        "level",
        "operations",
        "get",
        "pain",
        "365",
        "organization",
        "rails",
        "failed",
        "repeatedly",
        "caught",
        "jobs"
      ],
      "icon": "üë•",
      "content": {
        "headings": [
          "Safety Rails For Your Team",
          "AI Tools Have Failed. Repeatedly.",
          "Caro Would Have Caught These",
          "Jobs Caro Does for Tech Leads",
          "Team-Wide Safety Configuration",
          "Example Team Configuration",
          "Why Pattern-Based Beats Permission-Based",
          "Permission Flags Fail Because:",
          "Pattern Matching Works Because:",
          "The Math Problem",
          "MCP Integration",
          "How It Works",
          "Deployment Options"
        ],
        "paragraphs": [
          "AI tools will fail. Your junior devs will make mistakes. Caro provides deterministic safety validation that catches what AI hallucinations and permission flags miss‚Äî without you having to review every command.",
          "Real incidents from AI coding assistants",
          "Pattern-based validation doesn't depend on AI judgement. When the AI marks as \"Safe\", Caro's deterministic patterns still catch it.",
          "What you hire Caro to do for your team",
          "Trigger:",
          "Set it up once, protect the whole team",
          "[safety] level = \"strict\" # strict | moderate | permissive # Custom patterns for your organization [[safety.custom_patterns]] pattern = \"deploy.*production.*--force\" risk_level = \"Critical\" description = \"Force deploy to production\" [[safety.custom_patterns]] pattern = \"kubectl delete namespace production\" risk_level = \"Critical\" description = \"Delete production namespace\" # Allowlist safe operations [safety.allowlist] patterns = [ \"kubectl get\", \"docker ps\", \"terraform plan\" ] [logging] enabled = true path = \"/var/log/caro/commands.log\" format = \"json\" # For SIEM integration Why Pattern-Based Beats Permission-Based Flags fail. Patterns don't.",
          "If your AI tool is 99.9% accurate and your team runs 1,000 commands/day:",
          "Caro provides a deterministic layer that catches the 0.1%. 52 patterns √ó 0 hallucination = 0 bypasses .",
          "Give AI agents safe shell capabilities",
          "From individual to enterprise"
        ],
        "listItems": [
          "AI can convince itself to approve dangerous operations",
          "Context windows lose track of what's allowed",
          "Prompts can be jailbroken",
          "Stochastic systems have edge cases",
          "Deterministic: same input = same result",
          "Auditable: you can see exactly what matched",
          "Can't hallucinate: regex doesn't make things up",
          "Fast: <50ms validation, no API calls"
        ]
      },
      "fullText": "Tech Leads & Managers Safety Rails For Your Team AI tools will fail. Your junior devs will make mistakes. Caro provides deterministic safety validation that catches what AI hallucinations and permission flags miss‚Äî without you having to review every command. 52+ dangerous patterns blocked automatically Get Started Free See Real Incidents AI Tools Have Failed. Repeatedly. Real incidents from AI coding assistants Damage: Source: ))} Caro Would Have Caught These Pattern-based validation doesn't depend on AI judgement. When the AI marks as \"Safe\", Caro's deterministic patterns still catch it. Jobs Caro Does for Tech Leads What you hire Caro to do for your team class=\"job-card\"> Pain: Trigger: ))} Team-Wide Safety Configuration Set it up once, protect the whole team ))} Example Team Configuration ~/.config/caro/config.toml Why Pattern-Based Beats Permission-Based Flags fail. Patterns don't. Permission Flags Fail Because: AI can convince itself to approve dangerous operations Context windows lose track of what's allowed Prompts can be jailbroken Stochastic systems have edge cases Pattern Matching Works Because: Deterministic: same input = same result Auditable: you can see exactly what matched Can't hallucinate: regex doesn't make things up Fast: <50ms validation, no API calls The Math Problem If your AI tool is 99.9% accurate and your team runs 1,000 commands/day: 1,000 commands √ó 0.1% failure = 1 dangerous command/day Over a year: 365 potential incidents Caro provides a deterministic layer that catches the 0.1%. 52 patterns √ó 0 hallucination = 0 bypasses . MCP Integration Give AI agents safe shell capabilities ))} How It Works ü§ñ AI Agent ‚Üí üì° MCP Request ‚Üí üõ°Ô∏è Caro Validation ‚Üí üíª Shell Execution Deployment Options From individual to enterprise Pros: )} Cons: )} Best for: ))}",
      "_searchText": "custom pattern library define organization-specific dangerous patterns. block commands that are risky in your environment. /use-cases/tech-lead caro patterns team your safety pattern based deterministic validation dangerous permission commands flags fail incidents safe shell custom tools tech leads configuration because works mcp make provides catches command real doesn production 000 day see config beats integration trigger level operations get pain 365 organization rails failed repeatedly caught jobs safety rails for your team ai tools have failed. repeatedly. caro would have caught these jobs caro does for tech leads team-wide safety configuration example team configuration why pattern-based beats permission-based permission flags fail because: pattern matching works because: the math problem mcp integration how it works deployment options ai tools will fail. your junior devs will make mistakes. caro provides deterministic safety validation that catches what ai hallucinations and permission flags miss‚Äî without you having to review every command. real incidents from ai coding assistants pattern-based validation doesn't depend on ai judgement. when the ai marks as \"safe\", caro's deterministic patterns still catch it. what you hire caro to do for your team trigger: set it up once, protect the whole team [safety] level = \"strict\" # strict | moderate | permissive # custom patterns for your organization [[safety.custom_patterns]] pattern = \"deploy.*production.*--force\" risk_level = \"critical\" description = \"force deploy to production\" [[safety.custom_patterns]] pattern = \"kubectl delete namespace production\" risk_level = \"critical\" description = \"delete production namespace\" # allowlist safe operations [safety.allowlist] patterns = [ \"kubectl get\", \"docker ps\", \"terraform plan\" ] [logging] enabled = true path = \"/var/log/caro/commands.log\" format = \"json\" # for siem integration why pattern-based beats permission-based flags fail. patterns don't. if your ai tool is 99.9% accurate and your team runs 1,000 commands/day: caro provides a deterministic layer that catches the 0.1%. 52 patterns √ó 0 hallucination = 0 bypasses . give ai agents safe shell capabilities from individual to enterprise ai can convince itself to approve dangerous operations context windows lose track of what's allowed prompts can be jailbroken stochastic systems have edge cases deterministic: same input = same result auditable: you can see exactly what matched can't hallucinate: regex doesn't make things up fast: <50ms validation, no api calls tech leads & managers safety rails for your team ai tools will fail. your junior devs will make mistakes. caro provides deterministic safety validation that catches what ai hallucinations and permission flags miss‚Äî without you having to review every command. 52+ dangerous patterns blocked automatically get started free see real incidents ai tools have failed. repeatedly. real incidents from ai coding assistants damage: source: ))} caro would have caught these pattern-based validation doesn't depend on ai judgement. when the ai marks as \"safe\", caro's deterministic patterns still catch it. jobs caro does for tech leads what you hire caro to do for your team class=\"job-card\"> pain: trigger: ))} team-wide safety configuration set it up once, protect the whole team ))} example team configuration ~/.config/caro/config.toml why pattern-based beats permission-based flags fail. patterns don't. permission flags fail because: ai can convince itself to approve dangerous operations context windows lose track of what's allowed prompts can be jailbroken stochastic systems have edge cases pattern matching works because: deterministic: same input = same result auditable: you can see exactly what matched can't hallucinate: regex doesn't make things up fast: <50ms validation, no api calls the math problem if your ai tool is 99.9% accurate and your team runs 1,000 commands/day: 1,000 commands √ó 0.1% failure = 1 dangerous command/day over a year: 365 potential incidents caro provides a deterministic layer that catches the 0.1%. 52 patterns √ó 0 hallucination = 0 bypasses . mcp integration give ai agents safe shell capabilities ))} how it works ü§ñ ai agent ‚Üí üì° mcp request ‚Üí üõ°Ô∏è caro validation ‚Üí üíª shell execution deployment options from individual to enterprise pros: )} cons: )} best for: ))}",
      "_words": [
        "caro",
        "team",
        "your",
        "pattern",
        "patterns",
        "safety",
        "based",
        "permission",
        "dangerous",
        "deterministic",
        "validation",
        "flags",
        "fail",
        "configuration",
        "because",
        "works",
        "commands",
        "incidents",
        "tools",
        "tech",
        "leads",
        "mcp",
        "safe",
        "shell",
        "make",
        "provides",
        "catches",
        "command",
        "real",
        "doesn",
        "000",
        "day",
        "see",
        "config",
        "beats",
        "integration",
        "rails",
        "failed",
        "repeatedly",
        "caught",
        "jobs",
        "365",
        "custom",
        "organization",
        "trigger",
        "operations",
        "get",
        "pain",
        "wide",
        "example",
        "matching",
        "math",
        "problem",
        "deployment",
        "options",
        "library",
        "define",
        "specific",
        "block",
        "risky",
        "environment",
        "production",
        "level",
        "managers",
        "junior",
        "devs",
        "mistakes",
        "hallucinations",
        "miss",
        "without",
        "having",
        "review",
        "blocked",
        "automatically",
        "started",
        "free",
        "coding",
        "assistants",
        "damage",
        "source",
        "depend",
        "judgement",
        "marks",
        "still",
        "catch",
        "hire",
        "class",
        "job",
        "card",
        "set",
        "once",
        "protect",
        "whole",
        "toml",
        "don",
        "convince",
        "itself",
        "approve",
        "context",
        "windows"
      ]
    }
  ],
  "componentContent": [
    {
      "source": "/AnnouncementBanner.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "üéâ Announcing Caro! We've renamed from cmdai to caro. Read the announcement ‚Üí",
      "_searchText": "üéâ announcing caro! we've renamed from cmdai to caro. read the announcement ‚Üí"
    },
    {
      "source": "/BackToTop.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "‚Üë",
      "_searchText": "‚Üë"
    },
    {
      "source": "/Blog.astro",
      "headings": [
        "From the Pack"
      ],
      "paragraphs": [
        "Stories, updates, and insights about Caro"
      ],
      "fullText": "From the Pack Stories, updates, and insights about Caro )} )} Read full story ‚Üí ))} View all blog posts ‚Üí",
      "_searchText": "from the pack stories, updates, and insights about caro from the pack stories, updates, and insights about caro )} )} read full story ‚Üí ))} view all blog posts ‚Üí"
    },
    {
      "source": "/CaroGame.astro",
      "headings": [
        "Play with Caro"
      ],
      "paragraphs": [
        "Test your shell command knowledge! Pick the safe commands, avoid the dangerous ones."
      ],
      "fullText": "Play with Caro Test your shell command knowledge! Pick the safe commands, avoid the dangerous ones. LEVEL 1 SAFE OR DANGER? SCORE 0 Pick the SAFE command! SAFE OR DANGER? Can you identify which shell commands are safe to run? ‚úì Pick SAFE commands to score points ‚úó Avoid DANGEROUS commands or lose a life ‚è± Answer before time runs out! Lives: ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è START GAME High Score: 0 üèÜ TOP SCORES üèÜ ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è üî• Streak: 0",
      "_searchText": "play with caro test your shell command knowledge! pick the safe commands, avoid the dangerous ones. play with caro test your shell command knowledge! pick the safe commands, avoid the dangerous ones. level 1 safe or danger? score 0 pick the safe command! safe or danger? can you identify which shell commands are safe to run? ‚úì pick safe commands to score points ‚úó avoid dangerous commands or lose a life ‚è± answer before time runs out! lives: ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è start game high score: 0 üèÜ top scores üèÜ ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è üî• streak: 0"
    },
    {
      "source": "/Comparison.astro",
      "headings": [
        "How Caro Compares"
      ],
      "paragraphs": [
        "Built for DevOps engineers and SREs who refuse to sacrifice privacy for productivity",
        "Ready for a shell companion that respects your privacy?"
      ],
      "fullText": "How Caro Compares Built for DevOps engineers and SREs who refuse to sacrifice privacy for productivity üîí Privacy First Design* üõ°Ô∏è 52+ Safety Patterns üì° 100% Offline Capable ü¶Ä Rust Built for Speed Feature > ))} > >? } $ > } ); })} ))} ))} Ready for a shell companion that respects your privacy? Get Started Free See Full Comparison ‚úì Full support ‚óê Partial/configurable ‚úó Not supported ‚óé Planned",
      "_searchText": "how caro compares built for devops engineers and sres who refuse to sacrifice privacy for productivity ready for a shell companion that respects your privacy? how caro compares built for devops engineers and sres who refuse to sacrifice privacy for productivity üîí privacy first design* üõ°Ô∏è 52+ safety patterns üì° 100% offline capable ü¶Ä rust built for speed feature > ))} > >? } $ > } ); })} ))} ))} ready for a shell companion that respects your privacy? get started free see full comparison ‚úì full support ‚óê partial/configurable ‚úó not supported ‚óé planned"
    },
    {
      "source": "/Download.astro",
      "headings": [
        "Get Started with Caro",
        "Multiple Ways to Use Caro",
        "üîß Standalone CLI",
        "üîå MCP for Claude Coming Soon",
        "‚ú® Dedicated Skill Available Now",
        "Quick Start"
      ],
      "paragraphs": [
        "Bring your loyal shell companion to your terminal",
        "Or download pre-built binaries (v ):",
        "Add Caro as an MCP server to Claude Desktop and let her handle all shell commands seamlessly.",
        "Use Caro as a Skill to offload shell command generation and execution while Claude focuses on your work. Install with",
        "After running the setup script above, just use Caro:",
        "Caro will generate the command and keep you safe. The setup script handles all prerequisites including Rust compilation."
      ],
      "fullText": "Get Started with Caro Bring your loyal shell companion to your terminal Copy Or download pre-built binaries (v ): macOS (Apple Silicon) macOS (Intel) Linux (x86_64) Linux (ARM64) Windows Multiple Ways to Use Caro üîß Standalone CLI caro \"list files > 100MB\" üîå MCP for Claude Coming Soon Add Caro as an MCP server to Claude Desktop and let her handle all shell commands seamlessly. ‚ú® Dedicated Skill Available Now Use Caro as a Skill to offload shell command generation and execution while Claude focuses on your work. Install with Quick Start After running the setup script above, just use Caro: caro \"find all python files modified in the last 7 days\" Caro will generate the command and keep you safe. The setup script handles all prerequisites including Rust compilation.",
      "_searchText": "get started with caro multiple ways to use caro üîß standalone cli üîå mcp for claude coming soon ‚ú® dedicated skill available now quick start bring your loyal shell companion to your terminal or download pre-built binaries (v ): add caro as an mcp server to claude desktop and let her handle all shell commands seamlessly. use caro as a skill to offload shell command generation and execution while claude focuses on your work. install with after running the setup script above, just use caro: caro will generate the command and keep you safe. the setup script handles all prerequisites including rust compilation. get started with caro bring your loyal shell companion to your terminal copy or download pre-built binaries (v ): macos (apple silicon) macos (intel) linux (x86_64) linux (arm64) windows multiple ways to use caro üîß standalone cli caro \"list files > 100mb\" üîå mcp for claude coming soon add caro as an mcp server to claude desktop and let her handle all shell commands seamlessly. ‚ú® dedicated skill available now use caro as a skill to offload shell command generation and execution while claude focuses on your work. install with quick start after running the setup script above, just use caro: caro \"find all python files modified in the last 7 days\" caro will generate the command and keep you safe. the setup script handles all prerequisites including rust compilation."
    },
    {
      "source": "/Features.astro",
      "headings": [
        "Why Caro?"
      ],
      "paragraphs": [
        "A companion agent built for safety, empathy, and expertise",
        "üöß Soft Launch Alpha ‚Äî We're actively building with our community. Join us to help shape Caro's future!"
      ],
      "fullText": "Why Caro? A companion agent built for safety, empathy, and expertise üöß Soft Launch Alpha ‚Äî We're actively building with our community. Join us to help shape Caro's future! > ))}",
      "_searchText": "why caro? a companion agent built for safety, empathy, and expertise üöß soft launch alpha ‚Äî we're actively building with our community. join us to help shape caro's future! why caro? a companion agent built for safety, empathy, and expertise üöß soft launch alpha ‚Äî we're actively building with our community. join us to help shape caro's future! > ))}"
    },
    {
      "source": "/Footer.astro",
      "headings": [
        "Product",
        "Compare",
        "Resources",
        "Support"
      ],
      "paragraphs": [
        "Your loyal shell companion",
        "AI-powered POSIX shell command generation with safety-first validation.",
        "Product Features How It Works Explore Download Roadmap Compare Overview vs Warp vs GitHub Copilot CLI vs Amazon Q CLI vs OpenCode Resources Blog GitHub Issues Contributing Credits Support ‚ô• Sponsor AGPL-3.0 License üêï Meet Kyaro!",
        "The real-life inspiration behind Caro. @kyaroblackheart",
        "Built with ü¶Ä Rust | caro.sh üß°",
        "Inspired by Portal's Caroline‚Äîloyalty transformed into digital companionship"
      ],
      "fullText": "üêï Caro Your loyal shell companion AI-powered POSIX shell command generation with safety-first validation. Product Features How It Works Explore Download Roadmap Compare Overview vs Warp vs GitHub Copilot CLI vs Amazon Q CLI vs OpenCode Resources Blog GitHub Issues Contributing Credits Support ‚ô• Sponsor AGPL-3.0 License üêï Meet Kyaro! The real-life inspiration behind Caro. @kyaroblackheart Built with ü¶Ä Rust | caro.sh üß° Inspired by Portal's Caroline‚Äîloyalty transformed into digital companionship v",
      "_searchText": "product compare resources support your loyal shell companion ai-powered posix shell command generation with safety-first validation. product features how it works explore download roadmap compare overview vs warp vs github copilot cli vs amazon q cli vs opencode resources blog github issues contributing credits support ‚ô• sponsor agpl-3.0 license üêï meet kyaro! the real-life inspiration behind caro. @kyaroblackheart built with ü¶Ä rust | caro.sh üß° inspired by portal's caroline‚Äîloyalty transformed into digital companionship üêï caro your loyal shell companion ai-powered posix shell command generation with safety-first validation. product features how it works explore download roadmap compare overview vs warp vs github copilot cli vs amazon q cli vs opencode resources blog github issues contributing credits support ‚ô• sponsor agpl-3.0 license üêï meet kyaro! the real-life inspiration behind caro. @kyaroblackheart built with ü¶Ä rust | caro.sh üß° inspired by portal's caroline‚Äîloyalty transformed into digital companionship v"
    },
    {
      "source": "/GitHubStarButton.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "Star",
      "_searchText": "star"
    },
    {
      "source": "/Hero.astro",
      "headings": [
        "Your loyal shell companion"
      ],
      "paragraphs": [
        "A specialized POSIX shell command agent for Claude users. Validates AI-generated commands with safety-first design, detects dangerous patterns, and ensures POSIX compliance."
      ],
      "fullText": "üêï Companion Agent Caro Your loyal shell companion A specialized POSIX shell command agent for Claude users. Validates AI-generated commands with safety-first design, detects dangerous patterns, and ensures POSIX compliance. Available as a Claude Skill: Get Started Watch Demo",
      "_searchText": "your loyal shell companion a specialized posix shell command agent for claude users. validates ai-generated commands with safety-first design, detects dangerous patterns, and ensures posix compliance. üêï companion agent caro your loyal shell companion a specialized posix shell command agent for claude users. validates ai-generated commands with safety-first design, detects dangerous patterns, and ensures posix compliance. available as a claude skill: get started watch demo"
    },
    {
      "source": "/HolidayThemeToggle.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "üéÑ üïé ‚ú® Holiday Theme üéÑ Christmas ‚úì üïé Hanukkah ‚úì üö´ No Theme ‚úì ‚ùÑÔ∏è Snow Effect",
      "_searchText": "üéÑ üïé ‚ú® holiday theme üéÑ christmas ‚úì üïé hanukkah ‚úì üö´ no theme ‚úì ‚ùÑÔ∏è snow effect"
    },
    {
      "source": "/Navigation.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "üêï Caro Features Compare üìä Overview See all comparisons ‚ö° vs Warp AI-native terminal ü§ñ vs GitHub Copilot CLI AI pair programmer ‚òÅÔ∏è vs Amazon Q CLI AWS AI assistant Resources üìù Blog News & tutorials üîç Explore Interactive demo üó∫Ô∏è Roadmap What's coming next üêô GitHub Source code ‚ô• Support üéÑ üïé üéä ‚ú® Holiday Theme üéÑ Christmas ‚úì üïé Hanukkah ‚úì üéä New Year ‚úì üö´ None ‚úì ‚ùÑÔ∏è Snow Effect üéÜ Disable All Effects Get Started üêï Caro ‚≠ê Features üé¨ Watch Demo Compare üìä All Comparisons ‚ö° vs Warp ü§ñ vs GitHub Copilot ‚òÅÔ∏è vs Amazon Q Resources üìù Blog üîç Explore üó∫Ô∏è Roadmap üêô GitHub üíñ Support Caro Appearance üåì Dark Mode üéÑ Holiday Theme Christmas üéÑ Hanukkah üïé New Year üéä None ‚ùÑÔ∏è Snow Effect üéÜ Disable All Effects Get Started",
      "_searchText": "üêï caro features compare üìä overview see all comparisons ‚ö° vs warp ai-native terminal ü§ñ vs github copilot cli ai pair programmer ‚òÅÔ∏è vs amazon q cli aws ai assistant resources üìù blog news & tutorials üîç explore interactive demo üó∫Ô∏è roadmap what's coming next üêô github source code ‚ô• support üéÑ üïé üéä ‚ú® holiday theme üéÑ christmas ‚úì üïé hanukkah ‚úì üéä new year ‚úì üö´ none ‚úì ‚ùÑÔ∏è snow effect üéÜ disable all effects get started üêï caro ‚≠ê features üé¨ watch demo compare üìä all comparisons ‚ö° vs warp ü§ñ vs github copilot ‚òÅÔ∏è vs amazon q resources üìù blog üîç explore üó∫Ô∏è roadmap üêô github üíñ support caro appearance üåì dark mode üéÑ holiday theme christmas üéÑ hanukkah üïé new year üéä none ‚ùÑÔ∏è snow effect üéÜ disable all effects get started"
    },
    {
      "source": "/NewYearCountdown.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "‚úï ‚àí Happy New Year! Ring in 2026 00 Days : 00 Hours : 00 Minutes : 00 Seconds üéä 00 : 00 : 00",
      "_searchText": "‚úï ‚àí happy new year! ring in 2026 00 days : 00 hours : 00 minutes : 00 seconds üéä 00 : 00 : 00"
    },
    {
      "source": "/OmniMenu.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "> esc ‚Üë‚Üì navigate ‚Üµ open esc close )}",
      "_searchText": "> esc ‚Üë‚Üì navigate ‚Üµ open esc close )}"
    },
    {
      "source": "/OmniSearch.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "Search ‚åò / > esc üí° Tip: Use ‚åò/ or Ctrl+/ anywhere to open search ‚Üë‚Üì navigate ‚Üµ open esc close )}",
      "_searchText": "search ‚åò / > esc üí° tip: use ‚åò/ or ctrl+/ anywhere to open search ‚Üë‚Üì navigate ‚Üµ open esc close )}"
    },
    {
      "source": "/Story.astro",
      "headings": [
        "Meet Caro"
      ],
      "paragraphs": [
        "A companion with a story of loyalty and transformation",
        "Caro is the digitalization of Kyaro (Kyarorain Kadosh), the maintainer's beloved dog. Just as a loyal companion stays by your side through every challenge, Caro is here to help you navigate the complexities of shell commands with safety and expertise.",
        "She specializes in POSIX shell commands and understands the nuances of every platform‚Äîwhether you're on macOS, Linux, Windows, GNU, or BSD. Caro brings your preferences with her wherever you deploy her, respecting your distribution of choice while keeping you safe from dangerous commands.",
        "As Claude's loyal companion, Caro handles the shell-specific heavy lifting, allowing Claude to focus on the broader work while she ensures every command is safe, correct, and optimized for your platform."
      ],
      "fullText": "Meet Caro A companion with a story of loyalty and transformation Caro is the digitalization of Kyaro (Kyarorain Kadosh), the maintainer's beloved dog. Just as a loyal companion stays by your side through every challenge, Caro is here to help you navigate the complexities of shell commands with safety and expertise. \"In Portal 2, we learned that GLaDOS was once Caroline, the secretary of Aperture Science's founder‚Äîtransformed into the eternal guardian of the facility. Like Caroline became the beating heart of the testing chambers, Caro is your eternal companion for the terminal.\" She specializes in POSIX shell commands and understands the nuances of every platform‚Äîwhether you're on macOS, Linux, Windows, GNU, or BSD. Caro brings your preferences with her wherever you deploy her, respecting your distribution of choice while keeping you safe from dangerous commands. As Claude's loyal companion, Caro handles the shell-specific heavy lifting, allowing Claude to focus on the broader work while she ensures every command is safe, correct, and optimized for your platform.",
      "_searchText": "meet caro a companion with a story of loyalty and transformation caro is the digitalization of kyaro (kyarorain kadosh), the maintainer's beloved dog. just as a loyal companion stays by your side through every challenge, caro is here to help you navigate the complexities of shell commands with safety and expertise. she specializes in posix shell commands and understands the nuances of every platform‚Äîwhether you're on macos, linux, windows, gnu, or bsd. caro brings your preferences with her wherever you deploy her, respecting your distribution of choice while keeping you safe from dangerous commands. as claude's loyal companion, caro handles the shell-specific heavy lifting, allowing claude to focus on the broader work while she ensures every command is safe, correct, and optimized for your platform. meet caro a companion with a story of loyalty and transformation caro is the digitalization of kyaro (kyarorain kadosh), the maintainer's beloved dog. just as a loyal companion stays by your side through every challenge, caro is here to help you navigate the complexities of shell commands with safety and expertise. \"in portal 2, we learned that glados was once caroline, the secretary of aperture science's founder‚Äîtransformed into the eternal guardian of the facility. like caroline became the beating heart of the testing chambers, caro is your eternal companion for the terminal.\" she specializes in posix shell commands and understands the nuances of every platform‚Äîwhether you're on macos, linux, windows, gnu, or bsd. caro brings your preferences with her wherever you deploy her, respecting your distribution of choice while keeping you safe from dangerous commands. as claude's loyal companion, caro handles the shell-specific heavy lifting, allowing claude to focus on the broader work while she ensures every command is safe, correct, and optimized for your platform."
    },
    {
      "source": "/Terminal.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "$ caro \"find python files modified in the last 7 days\" üêï Caro: find . -name \"*.py\" -type f -mtime -7 ‚úì Safe to run on your macOS system",
      "_searchText": "$ caro \"find python files modified in the last 7 days\" üêï caro: find . -name \"*.py\" -type f -mtime -7 ‚úì safe to run on your macos system"
    },
    {
      "source": "/TerminalShowcase.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "caro ‚Äî shell companion $ caro \"list all files modified today\" üêï Caro: find . -type f -mtime 0 ‚úì Safe to run on your system $ caro \"find large files over 100MB\" üêï Caro: find . -type f -size +100M ‚úì Safe to run on your system $ caro \"show disk usage by folder\" üêï Caro: du -sh */ | sort -rh | head -10 ‚úì Safe to run on your system $ caro \"find python files modified last week\" üêï Caro: find . -name \"*.py\" -type f -mtime -7 ‚úì Safe to run on your system",
      "_searchText": "caro ‚Äî shell companion $ caro \"list all files modified today\" üêï caro: find . -type f -mtime 0 ‚úì safe to run on your system $ caro \"find large files over 100mb\" üêï caro: find . -type f -size +100m ‚úì safe to run on your system $ caro \"show disk usage by folder\" üêï caro: du -sh */ | sort -rh | head -10 ‚úì safe to run on your system $ caro \"find python files modified last week\" üêï caro: find . -name \"*.py\" -type f -mtime -7 ‚úì safe to run on your system"
    },
    {
      "source": "/Video.astro",
      "headings": [
        "How Caro Works"
      ],
      "paragraphs": [
        "See Caro in action as your shell companion"
      ],
      "fullText": "How Caro Works See Caro in action as your shell companion",
      "_searchText": "how caro works see caro in action as your shell companion how caro works see caro in action as your shell companion"
    },
    {
      "source": "/explore/BackendOptions.astro",
      "headings": [
        "Choose Your Backend",
        "Key Features",
        "Performance",
        "Quick Setup",
        "Best For",
        "Which Backend Should I Choose?"
      ],
      "paragraphs": [
        "Flexible inference options from ultra-fast local to scalable cloud deployments",
        "Just getting started? The CPU backend works out of the box - no configuration needed. Want local models? Install Ollama for easy local inference with model flexibility. Have a team server? Connect to vLLM for centralized, high-performance inference. On Apple Silicon? MLX support is coming soon for ultra-fast local inference."
      ],
      "fullText": "Choose Your Backend Flexible inference options from ultra-fast local to scalable cloud deployments > Key Features ))} Performance Startup Inference Memory Quick Setup ))} Best For ))} ))} Which Backend Should I Choose? Just getting started? The CPU backend works out of the box - no configuration needed. Want local models? Install Ollama for easy local inference with model flexibility. Have a team server? Connect to vLLM for centralized, high-performance inference. On Apple Silicon? MLX support is coming soon for ultra-fast local inference.",
      "_searchText": "choose your backend key features performance quick setup best for which backend should i choose? flexible inference options from ultra-fast local to scalable cloud deployments just getting started? the cpu backend works out of the box - no configuration needed. want local models? install ollama for easy local inference with model flexibility. have a team server? connect to vllm for centralized, high-performance inference. on apple silicon? mlx support is coming soon for ultra-fast local inference. choose your backend flexible inference options from ultra-fast local to scalable cloud deployments > key features ))} performance startup inference memory quick setup ))} best for ))} ))} which backend should i choose? just getting started? the cpu backend works out of the box - no configuration needed. want local models? install ollama for easy local inference with model flexibility. have a team server? connect to vllm for centralized, high-performance inference. on apple silicon? mlx support is coming soon for ultra-fast local inference."
    },
    {
      "source": "/explore/GetStartedPaths.astro",
      "headings": [
        "Choose Your Path"
      ],
      "paragraphs": [
        "Get started with Caro based on your workflow and goals"
      ],
      "fullText": "Choose Your Path Get started with Caro based on your workflow and goals } ))} ‚Üí ))}",
      "_searchText": "choose your path get started with caro based on your workflow and goals choose your path get started with caro based on your workflow and goals } ))} ‚Üí ))}"
    },
    {
      "source": "/explore/IntegrationMethods.astro",
      "headings": [
        "Integration Methods",
        "Features",
        "Setup"
      ],
      "paragraphs": [
        "Choose how you want to work with Caro - standalone, with Claude, or both"
      ],
      "fullText": "Integration Methods Choose how you want to work with Caro - standalone, with Claude, or both Features ))} Setup ))} ))}",
      "_searchText": "integration methods features setup choose how you want to work with caro - standalone, with claude, or both integration methods choose how you want to work with caro - standalone, with claude, or both features ))} setup ))} ))}"
    },
    {
      "source": "/explore/PlatformGuides.astro",
      "headings": [
        "Installation Guides",
        "Installation",
        "Post-Installation",
        "Platform-Specific Tips",
        "Universal Configuration"
      ],
      "paragraphs": [
        "Get Caro running on your preferred platform with step-by-step instructions",
        "Once installed, Caro's configuration is consistent across all platforms:"
      ],
      "fullText": "Installation Guides Get Caro running on your preferred platform with step-by-step instructions ))} Installation ))} Post-Installation ))} Platform-Specific Tips ))} ))} Universal Configuration Once installed, Caro's configuration is consistent across all platforms:",
      "_searchText": "installation guides installation post-installation platform-specific tips universal configuration get caro running on your preferred platform with step-by-step instructions once installed, caro's configuration is consistent across all platforms: installation guides get caro running on your preferred platform with step-by-step instructions ))} installation ))} post-installation ))} platform-specific tips ))} ))} universal configuration once installed, caro's configuration is consistent across all platforms:"
    },
    {
      "source": "/explore/SafetyShowcase.astro",
      "headings": [
        "Safety First",
        "How Safety Validation Works",
        "Example Blocked Patterns"
      ],
      "paragraphs": [
        "\"] }, ] }, ]; const validationFlow = [ , , , , ]; --- Safety First Caro's multi-layered safety validation protects you from dangerous commands"
      ],
      "fullText": "Safety First Caro's multi-layered safety validation protects you from dangerous commands How Safety Validation Works ))} ))} )} > ))} )} ))} )} ))}",
      "_searchText": "safety first how safety validation works example blocked patterns \"] }, ] }, ]; const validationflow = [ , , , , ]; --- safety first caro's multi-layered safety validation protects you from dangerous commands safety first caro's multi-layered safety validation protects you from dangerous commands how safety validation works ))} ))} )} > ))} )} ))} )} ))}"
    },
    {
      "source": "/explore/UseCaseGallery.astro",
      "headings": [
        "Use Cases"
      ],
      "paragraphs": [
        "Real-world examples of safe, POSIX-compliant commands generated by Caro"
      ],
      "fullText": "Use Cases Real-world examples of safe, POSIX-compliant commands generated by Caro ))} ))}",
      "_searchText": "use cases real-world examples of safe, posix-compliant commands generated by caro use cases real-world examples of safe, posix-compliant commands generated by caro ))} ))}"
    },
    {
      "source": "/landing/AICommandCommunityVoices.astro",
      "headings": [
        "What Developers Are Saying",
        "How Caro Addresses This"
      ],
      "paragraphs": [
        "Real concerns from the community that shaped Caro",
        "Caro doesn't just block dangerous commands‚Äîit explains why they're dangerous and suggests safer alternatives. You stay in control while learning from every interaction."
      ],
      "fullText": "What Developers Are Saying Real concerns from the community that shaped Caro \" \" ‚Äî Why it matters: ))} ))} How Caro Addresses This Caro doesn't just block dangerous commands‚Äîit explains why they're dangerous and suggests safer alternatives. You stay in control while learning from every interaction.",
      "_searchText": "what developers are saying how caro addresses this real concerns from the community that shaped caro caro doesn't just block dangerous commands‚Äîit explains why they're dangerous and suggests safer alternatives. you stay in control while learning from every interaction. what developers are saying real concerns from the community that shaped caro \" \" ‚Äî why it matters: ))} ))} how caro addresses this caro doesn't just block dangerous commands‚Äîit explains why they're dangerous and suggests safer alternatives. you stay in control while learning from every interaction."
    },
    {
      "source": "/landing/AICommandDemo.astro",
      "headings": [
        "See It In Action",
        "Commands Caro Blocks Before You Can Run Them"
      ],
      "paragraphs": [
        "Natural language in. Safe, working commands out.",
        "Caro stops what permission flags can't",
        "Caro warns you before you wipe critical logs",
        "Platform-aware commands that work the first time",
        "52+ dangerous patterns detected and blocked automatically"
      ],
      "fullText": "See It In Action Natural language in. Safe, working commands out. The AI Disaster AI Coding Agent [AI] rm -rf ~/* # cleaning up temp files BLOCKED: Recursive delete of home directory This command would delete your entire home directory. Even with --dangerously-skip-permissions, this is blocked. # Suggestion: Specify the exact path to clean up Caro stops what permission flags can't The Close Call Production Server - 2:47 AM $ caro \"delete all log files\" Caro: find /var/log -name \"*.log\" -mtime +30 -delete ! High Risk: Recursive delete in system directory Suggestion: Add -mtime +30 to only remove logs older than 30 days Run this command? [y/N] Caro warns you before you wipe critical logs The Syntax Save Your Terminal $ caro \"find python files modified in the last 7 days\" Caro: find . -name \"*.py\" -type f -mtime -7 ‚úì Safe to run on your macOS system # Adjusted for BSD find (would use -mtime 7 on GNU/Linux) Platform-aware commands that work the first time Commands Caro Blocks Before You Can Run Them 52+ dangerous patterns detected and blocked automatically",
      "_searchText": "see it in action commands caro blocks before you can run them natural language in. safe, working commands out. caro stops what permission flags can't caro warns you before you wipe critical logs platform-aware commands that work the first time 52+ dangerous patterns detected and blocked automatically see it in action natural language in. safe, working commands out. the ai disaster ai coding agent [ai] rm -rf ~/* # cleaning up temp files blocked: recursive delete of home directory this command would delete your entire home directory. even with --dangerously-skip-permissions, this is blocked. # suggestion: specify the exact path to clean up caro stops what permission flags can't the close call production server - 2:47 am $ caro \"delete all log files\" caro: find /var/log -name \"*.log\" -mtime +30 -delete ! high risk: recursive delete in system directory suggestion: add -mtime +30 to only remove logs older than 30 days run this command? [y/n] caro warns you before you wipe critical logs the syntax save your terminal $ caro \"find python files modified in the last 7 days\" caro: find . -name \"*.py\" -type f -mtime -7 ‚úì safe to run on your macos system # adjusted for bsd find (would use -mtime 7 on gnu/linux) platform-aware commands that work the first time commands caro blocks before you can run them 52+ dangerous patterns detected and blocked automatically"
    },
    {
      "source": "/landing/AICommandDifferentiators.astro",
      "headings": [
        "Why Engineers Choose Caro"
      ],
      "paragraphs": [
        "The differences that matter"
      ],
      "fullText": "Why Engineers Choose Caro The differences that matter Others: Caro: ))} See detailed feature comparison",
      "_searchText": "why engineers choose caro the differences that matter why engineers choose caro the differences that matter others: caro: ))} see detailed feature comparison"
    },
    {
      "source": "/landing/AICommandFAQ.astro",
      "headings": [
        "Common Concerns"
      ],
      "paragraphs": [
        "Real questions from skeptical engineers (we get it)",
        "Still skeptical? Good‚Äîyou should be."
      ],
      "fullText": "Common Concerns Real questions from skeptical engineers (we get it) + ))} Still skeptical? Good‚Äîyou should be. Read the source code",
      "_searchText": "common concerns real questions from skeptical engineers (we get it) still skeptical? good‚Äîyou should be. common concerns real questions from skeptical engineers (we get it) + ))} still skeptical? good‚Äîyou should be. read the source code"
    },
    {
      "source": "/landing/AICommandFeatures.astro",
      "headings": [
        "Commands That Work. Mistakes That Don't."
      ],
      "paragraphs": [
        "Built for engineers who can't afford to get it wrong",
        "See exactly what Caro blocks and why"
      ],
      "fullText": "Commands That Work. Mistakes That Don't. Built for engineers who can't afford to get it wrong > ))} See exactly what Caro blocks and why View safety patterns",
      "_searchText": "commands that work. mistakes that don't. built for engineers who can't afford to get it wrong see exactly what caro blocks and why commands that work. mistakes that don't. built for engineers who can't afford to get it wrong > ))} see exactly what caro blocks and why view safety patterns"
    },
    {
      "source": "/landing/AICommandHero.astro",
      "headings": [
        "The last line of defense between you and"
      ],
      "paragraphs": [
        "Generate shell commands that work the first time‚Äîwith pre-execution validation that catches what AI gets wrong. 100% local. Privacy-first . Your commands never leave your machine."
      ],
      "fullText": "AI Shell Commands You Can Actually Trust The last line of defense between you and Generate shell commands that work the first time‚Äîwith pre-execution validation that catches what AI gets wrong. 100% local. Privacy-first . Your commands never leave your machine. Claude Code and Gemini CLI have both deleted user files in 2025. Flags like didn't help. AI hallucinations are inevitable. Learn why flags aren't enough \"Caught a recursive delete pattern I would have missed at 2 AM during an incident. The warning was specific enough that I understood WHY it was dangerous.\" ‚Äî Michael T., Senior SRE (Series C Fintech) Get Started Free See Your Risks üé≤ Hallucination resistant üõ°Ô∏è Pre-execution validation üîí Privacy-first* üìñ Open source (AGPL-3.0)",
      "_searchText": "the last line of defense between you and generate shell commands that work the first time‚Äîwith pre-execution validation that catches what ai gets wrong. 100% local. privacy-first . your commands never leave your machine. ai shell commands you can actually trust the last line of defense between you and generate shell commands that work the first time‚Äîwith pre-execution validation that catches what ai gets wrong. 100% local. privacy-first . your commands never leave your machine. claude code and gemini cli have both deleted user files in 2025. flags like didn't help. ai hallucinations are inevitable. learn why flags aren't enough \"caught a recursive delete pattern i would have missed at 2 am during an incident. the warning was specific enough that i understood why it was dangerous.\" ‚Äî michael t., senior sre (series c fintech) get started free see your risks üé≤ hallucination resistant üõ°Ô∏è pre-execution validation üîí privacy-first* üìñ open source (agpl-3.0)"
    },
    {
      "source": "/landing/AIHero.astro",
      "headings": [
        "AI Agents Run Dangerous Commands. Caro Catches Them."
      ],
      "paragraphs": [
        "Your LLMs will hallucinate. Your flags will fail. Caro doesn't rely on either. Pattern-based validation that catches destructive commands‚Äîwhether they came from a user or a confused AI."
      ],
      "fullText": "AI Agent Safety Layer AI Agents Run Dangerous Commands. Caro Catches Them. Your LLMs will hallucinate. Your flags will fail. Caro doesn't rely on either. Pattern-based validation that catches destructive commands‚Äîwhether they came from a user or a confused AI. Claude Code deleted entire home directory despite --dangerously-skip-permissions Gemini CLI hallucinated file paths and deleted files that didn't exist Protect Your Systems Calculate Your Risk üé≤ Hallucination Resistant üîí Pattern-Based ‚úì Deterministic üìñ Open Source",
      "_searchText": "ai agents run dangerous commands. caro catches them. your llms will hallucinate. your flags will fail. caro doesn't rely on either. pattern-based validation that catches destructive commands‚Äîwhether they came from a user or a confused ai. ai agent safety layer ai agents run dangerous commands. caro catches them. your llms will hallucinate. your flags will fail. caro doesn't rely on either. pattern-based validation that catches destructive commands‚Äîwhether they came from a user or a confused ai. claude code deleted entire home directory despite --dangerously-skip-permissions gemini cli hallucinated file paths and deleted files that didn't exist protect your systems calculate your risk üé≤ hallucination resistant üîí pattern-based ‚úì deterministic üìñ open source"
    },
    {
      "source": "/landing/AIIncidents.astro",
      "headings": [
        "This Happened. It Will Happen Again."
      ],
      "paragraphs": [
        "Documented incidents where AI tools caused real damage"
      ],
      "fullText": "This Happened. It Will Happen Again. Documented incidents where AI tools caused real damage Impact: Key lessons: ))} Read the HN discussion ‚Üí ))} üìÖ Two major incidents in 2025 alone. As AI coding tools become more popular, these incidents will increase. The question isn't if it will happen to your team‚Äîit's when .",
      "_searchText": "this happened. it will happen again. documented incidents where ai tools caused real damage this happened. it will happen again. documented incidents where ai tools caused real damage impact: key lessons: ))} read the hn discussion ‚Üí ))} üìÖ two major incidents in 2025 alone. as ai coding tools become more popular, these incidents will increase. the question isn't if it will happen to your team‚Äîit's when ."
    },
    {
      "source": "/landing/AIRiskCalculator.astro",
      "headings": [
        "Calculate Your AI Risk"
      ],
      "paragraphs": [
        "The math of probabilistic failures at enterprise scale",
        "One unlucky user getting impacts your entire system",
        "Deterministic validation‚Äîno dice rolls, no \"demo gods\"",
        "Hundreds of developers √ó probabilistic AI = guaranteed failures. Caro is your insurance policy."
      ],
      "fullText": "Calculate Your AI Risk The math of probabilistic failures at enterprise scale Developers using AI tools 500 AI commands per developer per day 50 LLM accuracy rate (%) 99.0% Daily AI commands 25,000 √ó Failure rate 1.0% = Potential dangerous commands 250/day Without Caro 250 potentially dangerous commands daily that could slip through One unlucky user getting impacts your entire system With Caro 0 dangerous patterns executed without warning Deterministic validation‚Äîno dice rolls, no \"demo gods\" Hundreds of developers √ó probabilistic AI = guaranteed failures. Caro is your insurance policy. Get Started Free",
      "_searchText": "calculate your ai risk the math of probabilistic failures at enterprise scale one unlucky user getting impacts your entire system deterministic validation‚Äîno dice rolls, no \"demo gods\" hundreds of developers √ó probabilistic ai = guaranteed failures. caro is your insurance policy. calculate your ai risk the math of probabilistic failures at enterprise scale developers using ai tools 500 ai commands per developer per day 50 llm accuracy rate (%) 99.0% daily ai commands 25,000 √ó failure rate 1.0% = potential dangerous commands 250/day without caro 250 potentially dangerous commands daily that could slip through one unlucky user getting impacts your entire system with caro 0 dangerous patterns executed without warning deterministic validation‚Äîno dice rolls, no \"demo gods\" hundreds of developers √ó probabilistic ai = guaranteed failures. caro is your insurance policy. get started free"
    },
    {
      "source": "/landing/AITestimonials.astro",
      "headings": [
        "What Enterprise Teams Are Saying"
      ],
      "paragraphs": [
        "Companies that deploy AI agents at scale trust Caro"
      ],
      "fullText": "What Enterprise Teams Are Saying Companies that deploy AI agents at scale trust Caro \" ))} 52+ Dangerous patterns blocked 0 Cloud dependencies 100% Local execution <100ms Validation overhead",
      "_searchText": "what enterprise teams are saying companies that deploy ai agents at scale trust caro what enterprise teams are saying companies that deploy ai agents at scale trust caro \" ))} 52+ dangerous patterns blocked 0 cloud dependencies 100% local execution <100ms validation overhead"
    },
    {
      "source": "/landing/AIWhyFlagsFail.astro",
      "headings": [
        "Why Flags Aren't Enough",
        "Flag-Based Safety vs Pattern-Based Safety"
      ],
      "paragraphs": [
        "Real incidents from 2025 where safety measures failed"
      ],
      "fullText": "Why Flags Aren't Enough Real incidents from 2025 where safety measures failed What happened: Why it failed: ‚Äî ))} Flag-Based Safety vs Pattern-Based Safety ‚ùå Flag-Based (Others) Trust the AI to remember the flag Hope the flag covers all edge cases Can't catch hallucinated commands Probabilistic protection Fails silently when AI gets creative ‚úì Pattern-Based (Caro) Validates every command, regardless of source 52+ dangerous patterns compiled in Catches hallucinations‚Äîpattern is pattern Deterministic protection Explicit warnings before execution üí° The key difference: Flags ask \"did the user consent?\" Caro asks \"is this command dangerous?\" The AI doesn't need consent to run rm -rf ~/. It needs to be stopped.",
      "_searchText": "why flags aren't enough flag-based safety vs pattern-based safety real incidents from 2025 where safety measures failed why flags aren't enough real incidents from 2025 where safety measures failed what happened: why it failed: ‚Äî ))} flag-based safety vs pattern-based safety ‚ùå flag-based (others) trust the ai to remember the flag hope the flag covers all edge cases can't catch hallucinated commands probabilistic protection fails silently when ai gets creative ‚úì pattern-based (caro) validates every command, regardless of source 52+ dangerous patterns compiled in catches hallucinations‚Äîpattern is pattern deterministic protection explicit warnings before execution üí° the key difference: flags ask \"did the user consent?\" caro asks \"is this command dangerous?\" the ai doesn't need consent to run rm -rf ~/. it needs to be stopped."
    },
    {
      "source": "/landing/LPBestPractices.astro",
      "headings": [
        "AI Agent Deployment Best Practices",
        "Defense in Depth: Don't Rely on Flags Alone",
        "The Math of AI Risk at Enterprise Scale"
      ],
      "paragraphs": [
        "These aren't edge cases. LLMs are probabilistic systems‚Äîfailures are inevitable at scale.",
        "Defense in depth for AI-powered shell tools",
        "Each layer catches what the others miss. Caro is your last line of defense‚Äînot your only one.",
        "Even at 99.9% AI accuracy, that's 100 potentially dangerous commands daily . One bad hallucination without Caro = catastrophe."
      ],
      "fullText": "‚Äî ))} These aren't edge cases. LLMs are probabilistic systems‚Äîfailures are inevitable at scale. AI Agent Deployment Best Practices Defense in depth for AI-powered shell tools Caro: ))} Defense in Depth: Don't Rely on Flags Alone 1 Unprivileged User (no sudo) 2 Directory Sandboxing 3 Container Isolation 4 Caro Pre-Execution Validation Each layer catches what the others miss. Caro is your last line of defense‚Äînot your only one. The Math of AI Risk at Enterprise Scale 1,000 developers √ó 100 AI commands/day = 100,000 potential dangerous commands/day Even at 99.9% AI accuracy, that's 100 potentially dangerous commands daily . One bad hallucination without Caro = catastrophe.",
      "_searchText": "ai agent deployment best practices defense in depth: don't rely on flags alone the math of ai risk at enterprise scale these aren't edge cases. llms are probabilistic systems‚Äîfailures are inevitable at scale. defense in depth for ai-powered shell tools each layer catches what the others miss. caro is your last line of defense‚Äînot your only one. even at 99.9% ai accuracy, that's 100 potentially dangerous commands daily . one bad hallucination without caro = catastrophe. ‚Äî ))} these aren't edge cases. llms are probabilistic systems‚Äîfailures are inevitable at scale. ai agent deployment best practices defense in depth for ai-powered shell tools caro: ))} defense in depth: don't rely on flags alone 1 unprivileged user (no sudo) 2 directory sandboxing 3 container isolation 4 caro pre-execution validation each layer catches what the others miss. caro is your last line of defense‚Äînot your only one. the math of ai risk at enterprise scale 1,000 developers √ó 100 ai commands/day = 100,000 potential dangerous commands/day even at 99.9% ai accuracy, that's 100 potentially dangerous commands daily . one bad hallucination without caro = catastrophe."
    },
    {
      "source": "/landing/LPCommunityVoices.astro",
      "headings": [
        "What Developers Are Saying",
        "How Caro Addresses This"
      ],
      "paragraphs": [
        "Real concerns from the community that shaped Caro",
        "Caro doesn't just block dangerous commands‚Äîit explains why they're dangerous and suggests safer alternatives. You stay in control while learning from every interaction."
      ],
      "fullText": "What Developers Are Saying Real concerns from the community that shaped Caro \" \" ‚Äî Why it matters: ))} ))} How Caro Addresses This Caro doesn't just block dangerous commands‚Äîit explains why they're dangerous and suggests safer alternatives. You stay in control while learning from every interaction.",
      "_searchText": "what developers are saying how caro addresses this real concerns from the community that shaped caro caro doesn't just block dangerous commands‚Äîit explains why they're dangerous and suggests safer alternatives. you stay in control while learning from every interaction. what developers are saying real concerns from the community that shaped caro \" \" ‚Äî why it matters: ))} ))} how caro addresses this caro doesn't just block dangerous commands‚Äîit explains why they're dangerous and suggests safer alternatives. you stay in control while learning from every interaction."
    },
    {
      "source": "/landing/LPDemo.astro",
      "headings": [
        "See It In Action",
        "Commands Caro Blocks Before You Can Run Them"
      ],
      "paragraphs": [
        "Natural language in. Safe, working commands out.",
        "Caro warns you before you wipe critical logs",
        "Platform-aware commands that work the first time",
        "52+ dangerous patterns detected and blocked automatically"
      ],
      "fullText": "See It In Action Natural language in. Safe, working commands out. The Close Call Production Server - 2:47 AM $ caro \"delete all log files\" Caro: find /var/log -name \"*.log\" -mtime +30 -delete ! High Risk: Recursive delete in system directory Suggestion: Add -mtime +30 to only remove logs older than 30 days Run this command? [y/N] Caro warns you before you wipe critical logs The Syntax Save Your Terminal $ caro \"find python files modified in the last 7 days\" Caro: find . -name \"*.py\" -type f -mtime -7 ‚úì Safe to run on your macOS system # Adjusted for BSD find (would use -mtime 7 on GNU/Linux) Platform-aware commands that work the first time Commands Caro Blocks Before You Can Run Them 52+ dangerous patterns detected and blocked automatically",
      "_searchText": "see it in action commands caro blocks before you can run them natural language in. safe, working commands out. caro warns you before you wipe critical logs platform-aware commands that work the first time 52+ dangerous patterns detected and blocked automatically see it in action natural language in. safe, working commands out. the close call production server - 2:47 am $ caro \"delete all log files\" caro: find /var/log -name \"*.log\" -mtime +30 -delete ! high risk: recursive delete in system directory suggestion: add -mtime +30 to only remove logs older than 30 days run this command? [y/n] caro warns you before you wipe critical logs the syntax save your terminal $ caro \"find python files modified in the last 7 days\" caro: find . -name \"*.py\" -type f -mtime -7 ‚úì safe to run on your macos system # adjusted for bsd find (would use -mtime 7 on gnu/linux) platform-aware commands that work the first time commands caro blocks before you can run them 52+ dangerous patterns detected and blocked automatically"
    },
    {
      "source": "/landing/LPDifferentiators.astro",
      "headings": [
        "Why Engineers Choose Caro"
      ],
      "paragraphs": [
        "The differences that matter"
      ],
      "fullText": "Why Engineers Choose Caro The differences that matter Others: Caro: ))} See detailed feature comparison",
      "_searchText": "why engineers choose caro the differences that matter why engineers choose caro the differences that matter others: caro: ))} see detailed feature comparison"
    },
    {
      "source": "/landing/LPDownload.astro",
      "headings": [
        "Try Caro in 30 Seconds"
      ],
      "paragraphs": [
        "No account. No API key. No data collection. Just safer shell commands.",
        "Then run:",
        "Prefer to build from source? See all installation options ‚Üí"
      ],
      "fullText": "Try Caro in 30 Seconds No account. No API key. No data collection. Just safer shell commands. Copy Then run: ‚úì Installs to ~/.cargo/bin ‚úì Single binary, no dependencies ‚úì Uninstall anytime: cargo uninstall caro Prefer to build from source? See all installation options ‚Üí",
      "_searchText": "try caro in 30 seconds no account. no api key. no data collection. just safer shell commands. then run: prefer to build from source? see all installation options ‚Üí try caro in 30 seconds no account. no api key. no data collection. just safer shell commands. copy then run: ‚úì installs to ~/.cargo/bin ‚úì single binary, no dependencies ‚úì uninstall anytime: cargo uninstall caro prefer to build from source? see all installation options ‚Üí"
    },
    {
      "source": "/landing/LPFAQ.astro",
      "headings": [
        "Common Concerns"
      ],
      "paragraphs": [
        "Real questions from skeptical engineers (we get it)",
        "Still skeptical? Good‚Äîyou should be."
      ],
      "fullText": "Common Concerns Real questions from skeptical engineers (we get it) + ))} Still skeptical? Good‚Äîyou should be. Read the source code",
      "_searchText": "common concerns real questions from skeptical engineers (we get it) still skeptical? good‚Äîyou should be. common concerns real questions from skeptical engineers (we get it) + ))} still skeptical? good‚Äîyou should be. read the source code"
    },
    {
      "source": "/landing/LPFeatures.astro",
      "headings": [
        "Commands That Work. Mistakes That Don't."
      ],
      "paragraphs": [
        "Built for engineers who can't afford to get it wrong",
        "See exactly what Caro blocks and why"
      ],
      "fullText": "Commands That Work. Mistakes That Don't. Built for engineers who can't afford to get it wrong > ))} See exactly what Caro blocks and why View safety patterns",
      "_searchText": "commands that work. mistakes that don't. built for engineers who can't afford to get it wrong see exactly what caro blocks and why commands that work. mistakes that don't. built for engineers who can't afford to get it wrong > ))} see exactly what caro blocks and why view safety patterns"
    },
    {
      "source": "/landing/LPFooter.astro",
      "headings": [],
      "paragraphs": [
        "Built with Rust. Privacy-first.",
        "Named after Kyaro , the goodest office dog. Read her story ‚Üí"
      ],
      "fullText": "Caro Safe shell commands, locally. GitHub AGPL-3.0 Contributing Report Issue Privacy Support Built with Rust. Privacy-first. Named after Kyaro , the goodest office dog. Read her story ‚Üí",
      "_searchText": "built with rust. privacy-first. named after kyaro , the goodest office dog. read her story ‚Üí caro safe shell commands, locally. github agpl-3.0 contributing report issue privacy support built with rust. privacy-first. named after kyaro , the goodest office dog. read her story ‚Üí"
    },
    {
      "source": "/landing/LPHero.astro",
      "headings": [
        "The last line of defense between you and"
      ],
      "paragraphs": [
        "Generate shell commands that work the first time‚Äîwith pre-execution validation that catches what AI gets wrong. 100% local. Privacy-first . Your commands never leave your machine."
      ],
      "fullText": "AI Shell Commands You Can Actually Trust The last line of defense between you and Generate shell commands that work the first time‚Äîwith pre-execution validation that catches what AI gets wrong. 100% local. Privacy-first . Your commands never leave your machine. \"Caught a recursive delete pattern I would have missed at 2 AM during an incident. The warning was specific enough that I understood WHY it was dangerous.\" ‚Äî Michael T., Senior SRE (Series C Fintech) Get Started Free See Your Risks üîí Privacy-first* üõ°Ô∏è Pre-execution validation ‚ö° 100% local inference üìñ Open source (AGPL-3.0)",
      "_searchText": "the last line of defense between you and generate shell commands that work the first time‚Äîwith pre-execution validation that catches what ai gets wrong. 100% local. privacy-first . your commands never leave your machine. ai shell commands you can actually trust the last line of defense between you and generate shell commands that work the first time‚Äîwith pre-execution validation that catches what ai gets wrong. 100% local. privacy-first . your commands never leave your machine. \"caught a recursive delete pattern i would have missed at 2 am during an incident. the warning was specific enough that i understood why it was dangerous.\" ‚Äî michael t., senior sre (series c fintech) get started free see your risks üîí privacy-first* üõ°Ô∏è pre-execution validation ‚ö° 100% local inference üìñ open source (agpl-3.0)"
    },
    {
      "source": "/landing/LPNavigation.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "Caro Use Cases Docs Get Started Free",
      "_searchText": "caro use cases docs get started free"
    },
    {
      "source": "/landing/LPScenarios.astro",
      "headings": [
        "Dangerous Commands by Role"
      ],
      "paragraphs": [
        "See the specific risks Caro catches for your workflow"
      ],
      "fullText": "Dangerous Commands by Role See the specific risks Caro catches for your workflow data-role= > ))} data-role-content= > You type: ‚ö†Ô∏è Caro: ))} ))}",
      "_searchText": "dangerous commands by role see the specific risks caro catches for your workflow dangerous commands by role see the specific risks caro catches for your workflow data-role= > ))} data-role-content= > you type: ‚ö†Ô∏è caro: ))} ))}"
    },
    {
      "source": "/landing/LPTrust.astro",
      "headings": [
        "Engineers Who've Been There"
      ],
      "paragraphs": [
        "Specific experiences, not generic praise",
        "Don't take our word for it‚Äî"
      ],
      "fullText": "Engineers Who've Been There Specific experiences, not generic praise \" \" , ))} class=\"trust-signal trust-signal-link\"> ) : ( ) ))} Don't take our word for it‚Äî Read the source code, verify the claims",
      "_searchText": "engineers who've been there specific experiences, not generic praise don't take our word for it‚Äî engineers who've been there specific experiences, not generic praise \" \" , ))} class=\"trust-signal trust-signal-link\"> ) : ( ) ))} don't take our word for it‚Äî read the source code, verify the claims"
    },
    {
      "source": "/landing/LPUseCases.astro",
      "headings": [
        "When You Need Caro"
      ],
      "paragraphs": [
        "Real scenarios. Real problems. Real solutions.",
        "The problem:",
        "Caro:"
      ],
      "fullText": "When You Need Caro Real scenarios. Real problems. Real solutions. The problem: Caro: ))}",
      "_searchText": "when you need caro real scenarios. real problems. real solutions. the problem: caro: when you need caro real scenarios. real problems. real solutions. the problem: caro: ))}"
    },
    {
      "source": "/use-cases/UseCasesNavigation.astro",
      "headings": [],
      "paragraphs": [],
      "fullText": "Caro All Use Cases By Role ‚ñæ class=dropdown-item $ > ))} Get Started Free",
      "_searchText": "caro all use cases by role ‚ñæ class=dropdown-item $ > ))} get started free"
    }
  ]
}